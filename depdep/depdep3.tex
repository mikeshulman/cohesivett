\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{amssymb,amsthm,bbm}
\usepackage[centertags]{amsmath}
\usepackage[mathscr]{euscript}
\usepackage{tikz-cd}
\usepackage{mathpartir}
\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{ms}{anms}{\color{blue}MS}
\FXRegisterAuthor{todo}{andrl}{\color{red} }
\FXRegisterAuthor{mvr}{anmvr}{\color{olive}MVR}

\let\oldemptyset\emptyset
\let\emptyset\varnothing

\newcommand{\yields}{\vdash}
\newcommand{\cbar}{\, | \,}

\newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}
\newcommand{\CTX}{\,\,\mathsf{CTX}}
\newcommand{\ctx}{\,\,\mathsf{ctx}}
\newcommand{\TYPE}{\,\,\mathsf{TYPE}}
\newcommand{\type}{\,\,\mathsf{type}}
\newcommand{\TELE}{\,\,\mathsf{TELE}}
\newcommand{\tele}{\,\,\mathsf{tele}}

\newcommand\F[2]{\ensuremath{\mathsf{F}_{#1}(#2)}}
\newcommand\U[3]{\ensuremath{\mathsf{U}_{#1}(#2 \mid #3)}}
\newcommand\St[2]{\ensuremath{{#1}_*(#2)}}
\newcommand\StI[2]{\ensuremath{\mathsf{st}(#1,#2)}}
\newcommand\StE[2]{\ensuremath{\mathsf{unst}(#1,#2)}}
\newcommand\FE[3]{\ensuremath{\mathsf{split} \, #2 \, = \, {#1} \, \mathsf{in} \, #3}}
\newcommand\FI[1]{\ensuremath{\mathsf{F}{(#1)}}}
\newcommand\UE[2]{\ensuremath{#1(#2)}}
\newcommand\UI[2]{\ensuremath{\lambda #1.#2}}
\newcommand\Trd[2]{\ensuremath{#1_*(#2)}}

\newcommand\Set[0]{\ensuremath{\textbf{Set}}}
\newcommand\Hom[3]{\ensuremath{\textbf{hom}_{#1}(#2,#3)}}
\newcommand\just[1]{\ensuremath{\textsf{just}_{#1}}}
\newcommand\Dt[2]{\ensuremath{#1.#2}}

\newcommand\Push[3]{\ensuremath{#1 +_{#2} #3}}
\newcommand\Pushout[5]{\ensuremath{#1 +^{#4,#5}_{#2} #3}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}

\newcommand{\id}{\mathsf{id}}

\title{Adjoint Type Theory}
\author{}
\date{}

\begin{document}
\maketitle

\section{Syntax}

\subsection{Overview of Judgements}

Mode theory judgements:
\begin{itemize}
\item $\gamma \ctx$ (empty, extension)
\item $\gamma \yields \alpha \type$ (generators)
\item $\gamma \yields \delta \tele$ (empty, extension)
\item $\gamma \yields \mu : \alpha$ (variables, generators, ``coercion''
  along $s : \alpha \Rightarrow \beta \type$)
\item $\gamma \yields \theta : \delta$ (tuples)
\item $\gamma \yields s : \mu \Rightarrow \nu : \alpha$ (identity,
  composition, horizontal composition, generators)
\item $\gamma \yields s : \theta \Rightarrow \theta' : \delta$ (tuples)
\item $\gamma \yields s : \alpha \Rightarrow \beta \type$ (identity,
  composition, ap of a type constant on a telescope of 2-cells)
\end{itemize}
Top judgements: 
\begin{itemize}
\item $\yields_\gamma \Gamma \CTX$ over $\yields \gamma \ctx$
\item $\Gamma \yields_\alpha A \TYPE$ over $\gamma \yields \alpha \type$
\item $\Gamma \yields_\mu M : A$ over $\gamma \yields \mu : \alpha$
\item Telescopes $\Gamma \yields_\delta \Delta \TELE$ over $\gamma \yields \delta \tele$
\item Substitutions $\Gamma \yields_\theta \Theta : \Delta$ over $\gamma \yields \theta : \delta$
\end{itemize}

Coercion along 2-cells $s : \alpha \Rightarrow \beta \type$ is
\emph{contravariant} in the mode theory, but $s : \alpha \Rightarrow
\beta \type$ and $s : \mu \Rightarrow \mu : \alpha$ act \emph{covariantly}
on the subcripts of the term.

We expect structurality to be admissible for the base, and structurality
over that to be admissible for the top, e.g.:

\begin{mathpar}
\inferrule*[Left = weaken-over]
           {\Gamma,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,\gamma' \vdash \mu : \alpha)}
           {\Gamma,y:B,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,y:\beta,\gamma' \vdash \mu : \alpha)}

\inferrule*[Left = subst-over]
           {\Gamma,x:A,\Gamma' \yields_\nu N : C \and (\text{where } \gamma,x:\alpha,\gamma' \vdash \nu : \gamma) \\\\
            \Gamma \vdash_\mu M : A \and (\text{where } \gamma \vdash \mu : \alpha)
           }
           {\Gamma,\Gamma'[M/x] \yields_{\nu[\mu/x]} N[M/x] : A[M/x] \and (\text{where } \gamma,\gamma'[\mu/x] \vdash \nu[\mu/x] : \alpha[\mu/x])}
\end{mathpar}

\subsection{Mode Theory}

Some of the less obvious rules:

\begin{mathpar}
\inferrule*
    {\gamma \yields \mu : \beta \\
     \gamma \yields \alpha \Rightarrow \beta : \type
    }
    {\gamma \yields s_*(\mu) : \alpha}

\inferrule*
    {\gamma \yields s : \theta \Rightarrow \theta' : \delta \\
      \gamma \yields t : \mu \Rightarrow (\alpha[s])_*(\mu') : \alpha[\mu]}
    {\gamma \yields (s,t/x) : (\theta,\mu/x) \Rightarrow (\theta', \mu'/x) : \delta,x:\alpha}

\inferrule*
    {\gamma, \delta \yields \alpha : \type \\
     \gamma \yields s : \theta \Rightarrow \theta' : \delta}
    {\gamma \yields \alpha[s] : \alpha[\theta] \Rightarrow \alpha[\theta'] : \type}

\inferrule*
    {\gamma, \delta \yields s_1 : \mu \Rightarrow \mu' : \alpha \\
      \gamma \yields s_2 : \theta \Rightarrow \theta' : \delta}
    {\gamma \yields s_1[s_2] : \mu[\theta] \Rightarrow (\alpha[s_1])_*(\mu'[\theta']) : \mu[\theta]}
\end{mathpar}

Equations for $s_*(\alpha)$ are identity, composition -- anything else?

\subsection{Contexts and telescopes (boring lifting to tuples)}

\begin{mathpar}
  \inferrule*[Left = ctx-form]{ }
  {\yields_{\cdot} \cdot \CTX  } \and 

  \inferrule*[Left = ctx-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx) \\\\
    \Gamma \yields_\alpha A \TYPE \and (\text{where }  \gamma \yields \alpha \type)}
  {\yields_{\gamma, x : \alpha} \Gamma, x : A \CTX \and (\text{where } \yields \gamma,x:\alpha \ctx)  } \\

  \inferrule*[Left = tele-form]{ }
             {\Gamma \yields \cdot \TELE_{\cdot}  } \and

  \inferrule*[Left = tele-form]{
    \Gamma \yields_\delta \Delta \TELE \and  (\text{where } \gamma \yields \delta \tele) \\\\
    \Gamma,\Delta \yields_\alpha A \TYPE \and (\text{where } \gamma,\delta \yields \alpha \type)}
  {\Gamma \yields_{\delta, x : \alpha} \Delta, x : A \TELE  \and (\text{where } \gamma \yields \delta,x:\alpha \tele)} \\ \\

  \and

  \inferrule*[Left = sub1]{ }
             {\Gamma \yields_\cdot \cdot : {\cdot}  } \and 
  \inferrule*[Left = sub2]{
    \Gamma \yields_\theta \Theta : \Delta  \and (\text{where } \gamma \yields \theta : \delta) \\\\
    \Gamma \yields_{\mu} M : A[\Theta] \and (\text{where } \gamma,\delta \yields \mu : \alpha[\theta])}
  {\Gamma \yields_{\theta, \mu/x } (\Theta,M/x) : \Delta, x : A  \and (\text{where } \gamma \yields (\theta,\mu/x) : \delta,x:\alpha)} \\ \\
\end{mathpar}


\subsection{Types and Terms}

Note: we could build $s_*$ into the other rules, but there's not much
reason to in natural deduction.  

\begin{mathpar}
  \inferrule*[Left = var]{
    % \yields \Gamma, x : A, \Gamma' \CTX_{\gamma, x : \alpha, \gamma'}
  }
  {\Gamma, x : A, \Gamma' \yields_x x : A \and (\text{where } \gamma,x:\alpha,\gamma' \yields x : \alpha)} \and

 \inferrule*[Left = 2cell]{
   \Gamma \yields_\mu M : A 
   \and \gamma \yields s : (\mu \Rightarrow \nu) : \alpha
  }
  {\Gamma \yields_\nu s_*(M) : A} \\ \\

  \inferrule*[Left = *-form]{
    \Gamma, \yields_\alpha A \TYPE \and (\text{where } \gamma \yields \alpha \type)\\\\
    \and \gamma \yields s : \alpha \Rightarrow \beta : \type
  }{\Gamma \yields_\beta \St{s}{A} \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = *-intro]{
    \Gamma \yields_{s_*(\mu)} M : A \and (\text{where } \gamma \yields s_*(\mu) : \alpha)
  }
  {\Gamma \yields_{\mu} \StI{s}{M} : \St{s}{A}
    \and (\text{where } \gamma \yields \mu : \beta)
  } \\
  
  \inferrule*[Left = *-elim]{
    \Gamma \yields_\mu M : \St{s}{A} \and (\text{where } \gamma \yields \mu : \beta)
  }{
    \Gamma \yields_{s_*(\mu)} \StE{s}{M} : A \and (\text{where } \gamma \yields s_*(\mu) : \alpha)
  } \\
  
  \\
  \inferrule*[Left = F-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx)\\\\
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele) \\\\
    \gamma, \delta \yields \mu : \beta 
  }
  {\Gamma \yields_\beta F_\mu(\Delta) \TYPE \and (\text{where } \gamma \yields \beta \type) } \\
  
  \inferrule*[Left = F-intro]{
    \Gamma \yields_{\theta} \Theta : \Delta 
    \and (\text{where } \gamma \yields {\theta} : \delta)
    %% \and \gamma \yields \nu : \beta 
    %% \and \gamma \yields \mu[\theta] : \beta 
    %% \and \gamma \yields (\nu \Rightarrow \mu[\theta]) : \beta
  }
  {\Gamma \yields_{\mu[\theta]} \FI{\Theta} : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \mu[\theta] : \beta)} \\

  \inferrule*[Left = F-elim]{
    \Gamma, x : F_{\mu}(\Delta) \yields_{\alpha} C : \TYPE \and (\text{where } \gamma, x : \beta \yields \alpha : \type) \and \\
    \Gamma \yields_{\nu} M : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \nu : \beta) \and \\
    \Gamma, \Delta \yields_{\nu' [\mu / x]} N : C [\FI{\Delta/\Delta}/x]
    \and (\text{where } \gamma, \delta \yields \nu' [\mu / x] : \alpha [\mu / x] )}
  {\Gamma \yields_{\nu'[\nu/x]} \FE{M}{\Delta}{N} : C[M/x]  \and (\text{where } \gamma, \beta \yields {\nu'[\nu/x]} : \alpha[\nu/x])} \\
    \\ \\

  \inferrule*[Left = U-form]{
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele)\\\\
    \Gamma, \Delta \yields_\alpha A \TYPE \and (\text{where } \gamma, \delta \yields \alpha \type)\\\\
    \and \gamma, \delta, c : \beta \yields \mu : \alpha
  }{\Gamma \yields_\beta U_{c.\mu}(\Delta \vert A) \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = U-intro]{
    \Gamma, \Delta \yields_{\mu[\nu/c]} N : A \and (\text{where } \gamma,\delta \yields {\mu[\nu/c]} : \alpha)
  }
  {\Gamma \yields_{\nu} \UI \Delta N : U_{c.\mu}(\Delta \vert A)
    \and (\text{where } \gamma \yields \nu : \beta)
  } \\
  
  \inferrule*[Left = U-elim]{
    \Gamma \yields_\nu M : U_{c.\mu}(\Delta \vert A) \and (\text{where } \gamma \yields \nu : \beta)\\\\
    \Gamma \yields_\theta \Theta : \Delta \and (\text{where } \gamma \yields \theta : \delta)\\
  }{
    \Gamma \yields_{\mu[\theta,\nu/c]} \UE{M}{\Theta} : A[\Theta] \and (\text{where } \gamma \yields \mu[\theta,\nu/c] : \alpha[\theta])
  } \\
\end{mathpar}

Note that \St{s}{A} and \U{x.s_*(x)}{\cdot}{A} have the same intro/elim,
but \St{s}{A} has more definitional equalities:
\[
\begin{array}{rcl}
\St{1}{A} & \equiv & A \\
\St{(s;t)}{A} & \equiv & \St{t}{\St{s}{A}}\\
\St{\alpha[s]}{A[\Theta]} & \equiv & A[s_*(\Theta)]
\end{array}
\]

We should also have term definitional equalities over these (like
$\StI{1}{M} \equiv M$, $\StE{1}{M} \equiv M$).

In the final equation, the typing is
\begin{mathpar}
\gamma,\delta \yields \alpha : \type \and 
\Gamma,\Delta \yields_\alpha A : \type \and 
\Gamma \yields s : \theta \Rightarrow \theta' : \delta \and
\Gamma \yields_\theta \Theta : \Delta 
\end{mathpar}
This equation uses the operation
\begin{mathpar}
 \inferrule*[Left = 2cell-subst]{
   \Gamma \yields_\theta \Theta : \Delta 
   \and \gamma \yields s : (\theta \Rightarrow \theta') : \delta
  }
  {\Gamma \yields_{\theta'} s_*(\Theta) : A} 
\end{mathpar}
is admissible. The extension case is given
\begin{mathpar}
(s,t/x) : (\theta,\mu/x) \Rightarrow (\theta',\mu'/x) : \delta,x:\alpha
\and
\yields_{\theta,\mu/x} (\Theta,M/x) : \Delta,x:A
\end{mathpar}
as in the typing rules for these above, and constructs
\[
(s_*(\Theta), \StI{\alpha[s]}{t_*(M)})
\]
Note that the second component uses the same third equation above (at a
smaller context) to type check, because the term is supposed to have
type $A[s_*(\Theta)]$, which we construct via the intro rule for
$\St{(\alpha[s])}{A[\Theta]}$.

\subsection{Recovering Ordinary TT}

The basic idea is that a type is a list of variable dependencies, with some information attached to each dependency saying how it relates to the previously specified dependencies in the same type.

We use an auxilliary judgement $\gamma \mid \beta \yields \sigma : \alpha$ that places the type $\beta$ in a place we can treat it as a minicontext: we have been calling these `substitutions' but I think I will call them renamings in what follows. These are renamings/variable-for-variables substitutions between the lists that constitute $\alpha$ and $\beta$.

Weakening and exchange in the context and weakening the minicontext should be straightforwardly admissible. Exchange in the minicontext should also be admissible (wherever it makes sense), and to properly match the semantics, we should probably be identifying such rearrangements.

\begin{mathpar}
  \inferrule*[]{~}
  {\gamma \yields \emptyset \type  } \and 
  \inferrule*[]{ \gamma \yields \beta \type \and \gamma \mid \beta \yields \sigma : \alpha \and (x : \alpha) \in \gamma}
  {\gamma \yields (\beta, i : x[\sigma]) \type  } \\

  \inferrule*[]{ \gamma \yields \beta \type}
  {\gamma \mid \beta \yields () : \emptyset  } \and
  \inferrule*[]{ \gamma \mid \beta \yields \sigma : \alpha \and  \gamma \mid \alpha \yields \tau : \delta \and (j : x[\tau[\sigma]]) \in \beta}
  {\gamma \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])} \\
  
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields (\beta \mid \sigma)
   : \alpha} \\
   
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields \sigma : \alpha \Rightarrow \beta}  \and   \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \tau : \beta}
  {\gamma \yields s : (\beta \mid \sigma) \Rightarrow (\beta' \mid \sigma[\tau]) : \alpha} \\
\end{mathpar}

\subsubsection{Substitution}

It will take a bit of work to show that substitution is admissible. A substitution $\alpha[(\beta \mid \sigma) / x_0]$ (roughly) expands out to calculating the `pushout' of two natural transformations between types in terms of cell gluing. (Although it looks like an operation on two maps \emph{into} $\alpha$ using the substitution notation.) Intuitively is gluing the list $\beta$ into $\alpha$ everywhere that $x_0$ is used, identifying things as specified by $\sigma$.

This is not too hard to do by hand in simple cases, here are some examples. Let $!$ denotes the unique renaming into $\emptyset$. 

Working in the context $x : \emptyset, y : \emptyset, z : \emptyset$ we have things like:
\begin{align*}
(i : x[!])[(j : y[!], k : y[!] \mid\, !)/x] &= (j : y[!], k : y[!]) \\
(i : x[!], m : z[!])[(y[!], y[!] \mid\, !)/x] &= (j : y[!], k : y[!], m : z[!])
\end{align*}
In context $x : \emptyset, y : \emptyset, z : (i : y[!])$ we can do:
\begin{align*}
(i : y[!], j : z[i/i])[(i_1 : x[!], i_2 : x[!] \mid\, !)/ y] = (i_1 : x[!], i_2 : x[!], j : z[i_1/i_1, i_2/i_2])
\end{align*}
as the type of $z$ is now $(i_1 : x[!], i_2 : x[!])$. And as an example of some actual gluing, take the context $x : \emptyset, y : (i : x[!]), z : (i : x[!])$, we can do
\begin{align*}
(i : x[!], j : y[i/i])[(i : x[!] k : z[i/i] \mid i/i ) / y] = (i : x[!], k : z[i/i])
\end{align*}

To prove substitution is admissible, the main steps would be:
\begin{enumerate}
\item Composition for renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\item An identity renaming: $\gamma \mid \alpha \yields \id : \alpha$.
\item A `pushout' operation: 
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\delta}{\sigma}{\tau}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\delta}{\sigma}{\tau} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\delta}{\sigma}{\tau} \yields \inr : \delta$, so that $\sigma[\inl] = \tau[\inr]$.
\item The following Lemma, which looks morally like a more complicated version of $\inl$, (to be proven simultaneously with substitution I suppose)
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0 \mid \alpha \yields \tau : \alpha_0 \and (i : x_0[\tau]) \in \alpha \and \gamma \mid \beta \yields \sigma : \alpha_0}{\gamma \mid \alpha[(\beta \mid \sigma) / x_0] \yields \sigma' : \beta}
\end{mathpar}
such that $\sigma[\sigma'] = \tau[(\beta \mid \sigma)/x_0]$
\item Substitution itself, for types, terms, renamings.
\end{enumerate}

\subsubsection{$\Sigma$ and $\Pi$}

$\Sigma$ ought to be the $F$ type for \[\gamma, x : \alpha, y : (\alpha, i : x[\id_\alpha]) \yields (\alpha, i : x[\id_\alpha], j : y[\id_{(\alpha, x)}] \mid \alpha / \alpha) : \alpha\]

Let's call this $\sigma_x(y)$, or something. As a sanity check, we can test this with a simple case of $F$-left.
\begin{mathpar}
\inferrule*[Left=F-left]{\Gamma, x : A, y : B(x) \yields_{\id_{(\alpha, z)}[\sigma_x(y)/z]} c[\FI{x,y}/z] : C[\FI{x,y}/z]}{\Gamma, z : F_{\sigma_x(y)}(x:A, y : B(x)) \yields_{\id_{(\alpha, z)}} c : C}
\end{mathpar}
And presumably $\id_{(\alpha, z)}[\sigma_x(y)/z] = \id_{(\alpha, x, y)}$, as the pushout would identify $x$ and $y$'s dependence on an $\alpha$ with the existing $\alpha$ in $(\alpha, z)$.

And the $F$-intro rule 
\begin{mathpar}
\inferrule*[Left=F-right$^*$]{~}{\Gamma, x : A, y: B(x) \yields_{\sigma_x(y)} \mathsf{pair}(x,y) : F_{\sigma_x(y)}(x:A, y : B(x))}
\end{mathpar}
could be read as saying that the term $\mathsf{pair}(x,y) := \FI{x,y}$ uses exactly what the type $A$ does, plus one usage of $x$ and one usage of $y$.

$\Pi$ ought to be the $U$ type for \[\gamma, x : \alpha, y : \alpha \yields (\alpha, i : x[\id_\alpha], j : y[\id_{\alpha}] \mid \alpha / \alpha, i / i) : (\alpha, i : x[\id_\alpha])\]
If we call this $\pi_x(y)$, we can try the $U$-right rule in a simple case:
\begin{mathpar}
  \inferrule*[Left = U-right]{\Gamma, x : A \yields_{\pi_x(y)[(\alpha \mid \id_\alpha) / y]} N : B}
  {\Gamma \yields_{(\alpha \mid \id_\alpha)} \UI \Delta N : U_{y.\pi_x(y)}(A \vert B)} \\
\end{mathpar}
And then $\pi_x(y)[(\id_\alpha\vert \alpha)/y] = (\alpha, i : x[\id_\alpha] \mid \id) : (\alpha, i : x[\id_\alpha])$, as the $\alpha$ from the $y$ has been glued to the existing one.

\subsubsection{Structurality}
We can change what structural rules are available by fiddling with the final three rules, and only allowing some renamings to be used in each.

\begin{enumerate}
\item The term rule controls how the dependencies of a term relate to the dependencies of its type. By construction, the dependencies of a term bound the dependencies of the type, but we could restrict this further: Allowing only `relevant' renamings here would say that terms can't use variables that their types didn't.

We could choose to not consider types `up to ordering', so that the order of dependencies mattes. Then, allowing only identity renamings in the term rule would demand that terms have have the same dependencies as their types, in the same order. (Whatever this means!)

\item The type 2-cells control the structural rules in the types
\item The term 2-cells control the structural rules in the terms
\end{enumerate}

These choices cannot be totally arbitrary: if we want type 2-cells to act on terms, the renamings used for terms must be closed under composition with those for type 2-cells. Similarly, if we want term 2-cells to induce type 2-cells via substitution, \mvrnote{What exactly was required? Enough that term 2-cells are included in type 2-cells?}

As an example, it appears these choices could allow a type system where the types behave fully structurally and the terms behave linearly, but not vis versa.

\subsection{Modal Type Theories}
\subsection{Bunchy Type Theories}

\end{document}

