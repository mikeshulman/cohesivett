\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{amssymb,amsthm,bbm}
\usepackage[centertags]{amsmath}
\usepackage{stackengine}
\stackMath
\usepackage[mathscr]{euscript}
\usepackage{tikz-cd}
\usepackage{mathpartir}
\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{ms}{anms}{\color{blue}MS}
\FXRegisterAuthor{mvr}{anmvr}{\color{olive}MVR}
\FXRegisterAuthor{drl}{andrl}{\color{red}DRL}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}

\let\oldemptyset\emptyset
\let\emptyset\varnothing

\newcommand{\yields}{\vdash}
\newcommand{\cbar}{\, | \,}

\newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}
\newcommand{\CTX}{\,\,\mathsf{Ctx}}
\newcommand{\ctx}{\,\,\mathsf{mctx}}
\newcommand{\TYPE}{\,\,\mathsf{Type}}
\newcommand{\type}{\,\,\mathsf{mtype}}
\newcommand{\TELE}{\,\,\mathsf{Tele}}
\newcommand{\tele}{\,\,\mathsf{mtele}}

\newcommand\F[2]{\ensuremath{\mathsf{F}_{#1}(#2)}}
\newcommand\U[3]{\ensuremath{\mathsf{U}_{#1}(#2 \mid #3)}}
\newcommand\St[2]{\ensuremath{{#1}(#2)}}
\newcommand\StI[2]{\ensuremath{\mathsf{st}(#1,#2)}}
%\newcommand\StE[2]{\ensuremath{\mathsf{unst}(#1,#2)}}
\newcommand\StE[4]{\ensuremath{\mathsf{let} \, \StI{#2}{#3} \, = \, {#1} \, \mathsf{in} \, #4}}
\newcommand\FE[3]{\ensuremath{\mathsf{split} \, #2 \, = \, {#1} \, \mathsf{in} \, #3}}
\newcommand\FI[1]{\ensuremath{\mathsf{F}{(#1)}}}
\newcommand\UE[2]{\ensuremath{#1(#2)}}
\newcommand\UI[2]{\ensuremath{\lambda #1.#2}}
\newcommand\TypeTwo[4]{\ensuremath{#1 \mid #3 \vDash_\mathsf{ty} #2 : #4}}
\newcommand\TeleTwo[4]{\ensuremath{#1 \mid #3 \vDash_\mathsf{tele} #2 : #4}}
\newcommand\TermTwo[4]{\ensuremath{#1 \mid #3 \vDash_\mathsf{tm} #2 : #4}}
\newcommand\TermTwoT[5]{\ensuremath{#1 \mid #3 \vDash_\mathsf{tm} #2 :_{#5} #4}}
\newcommand\SubTwo[4]{\ensuremath{#1 \mid #3 \vDash_\mathsf{sub} #2 : #4}}
\newcommand\TrPlus[2]{\ensuremath{#1^+(#2)}}
\newcommand\TrCirc[2]{\ensuremath{#1^\circ(#2)}}

\newcommand\Set[0]{\ensuremath{\textbf{Set}}}
\newcommand\Hom[3]{\ensuremath{\textbf{hom}_{#1}(#2,#3)}}
\newcommand\just[1]{\ensuremath{\textsf{just}_{#1}}}
\newcommand\Dt[2]{\ensuremath{#1.#2}}

\newcommand\Push[3]{\ensuremath{#1 +_{#2} #3}}
\newcommand\Pushout[5]{\ensuremath{#1 +^{#4,#5}_{#2} #3}}
\newcommand{\case}{\mathsf{case}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}
\newcommand{\ini}{\mathsf{in}}

\newcommand{\id}{\mathsf{id}}
\DeclareMathOperator{\ob}{ob}

\title{Adjoint Type Theory}
\author{}
\date{}

\begin{document}
\maketitle

\section{Syntax}

\subsection{Overview of Judgements}

Mode theory judgements:
\begin{enumerate}
\item $\gamma \ctx$ (empty, extension)
\item $\gamma \yields \alpha \type$ 
\item $\gamma \yields \delta \tele$ (empty, extension)
\item $\gamma \yields \mu : \alpha$ (variables, action of mode type 2-cells)
\item $\gamma \yields \theta : \delta$ (empty, extension)
\item $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ (horizontal and vertical composition)
\item $\TeleTwo{\gamma}{s}{\delta}{\delta'}$ (empty, extension)
\item $\TermTwo{\gamma}{s}{\mu}{\nu}$ (identity,
  composition, horizontal composition)
\item $\SubTwo{\gamma}{s}{\theta}{\theta'}$ (tupled up term 2-cells)
\end{enumerate}
Top judgements: 
\begin{itemize}
\item $\yields_\gamma \Gamma \CTX$ over $\yields \gamma \ctx$
\item $\Gamma \yields_\alpha A \TYPE$ over $\gamma \yields \alpha \type$
\item $\Gamma \yields_\mu M : A$ over $\gamma \yields \mu : \alpha$
\item Telescopes $\Gamma \yields_\delta \Delta \TELE$ over $\gamma \yields \delta \tele$
\item Substitutions $\Gamma \yields_\theta \Theta : \Delta$ over $\gamma \yields \theta : \delta$
\end{itemize}

Coercion along 2-cells $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ acts in \emph{both directions} in the mode theory, but $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ and $\TermTwo{\gamma}{s}{\mu}{\nu}$ act \emph{contravariantly} on the subscripts of upstairs terms.

We expect structurality to be admissible for the base, and structurality
over that to be admissible for the top, e.g.:

\begin{mathpar}
\inferrule*[Left = weaken-over]
           {\Gamma,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,\gamma' \vdash \mu : \alpha)}
           {\Gamma,y:B,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,y:\beta,\gamma' \vdash \mu : \alpha)}

\inferrule*[Left = subst-over]
           {\Gamma,x:A,\Gamma' \yields_\nu N : C \and (\text{where } \gamma,x:\alpha,\gamma' \vdash \nu : \gamma) \\\\
            \Gamma \vdash_\mu M : A \and (\text{where } \gamma \vdash \mu : \alpha)
           }
           {\Gamma,\Gamma'[M/x] \yields_{\nu[\mu/x]} N[M/x] : A[M/x] \and (\text{where } \gamma,\gamma'[\mu/x] \vdash \nu[\mu/x] : \alpha[\mu/x])}
\end{mathpar}


\subsection{Mode Theory}

\begin{enumerate}

\item Contexts are as usual:

\begin{mathpar}
  \inferrule*{ }
             {\cdot \ctx}
             
  \inferrule*
    {\gamma \ctx \and
     \gamma \yields \alpha \type}
    {\gamma,x:\alpha \ctx}
\end{mathpar}

\item
  There are no types $\alpha$ stipulated for all mode theories; see below
for specific cases.  

\item Telescopes are tuples of types:

  \begin{mathpar}
  \inferrule*{ }
             {\gamma \yields \cdot \tele}
             
  \inferrule*
      {\gamma \yields \delta \tele \and
        \gamma,\delta \yields \alpha \type}
      {\gamma \yields \delta,x:\alpha \tele}
  \end{mathpar}

\item In all mode theories, terms must have: 

\begin{mathpar}
\inferrule*{ }
             {\gamma,x : \alpha, \gamma' \yields x : \alpha}
             
\inferrule*
    {\gamma \yields \mu : \beta \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{\mu} : \alpha}
    
\inferrule*
    {\gamma \yields \mu : \alpha \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrCirc{s}{\mu} : \beta}
\end{mathpar}

Equations for $\TrPlus{s}{\mu}$ and $\TrCirc{s}{\mu}$ are identity,
composition.

These are adjoint as $s^\circ \dashv s^+$, this is the direction that identifies $F_{s^+}$ and $U_{s^\circ}$---see the rules for term
2-cells below.  

\item Substitutions for telescopes

\begin{mathpar}

    \inferrule{ }
              {\gamma \yields \cdot : \cdot}
    
    \inferrule
    { \gamma \yields \theta : \delta \and 
      \gamma,\delta \yields \mu : \alpha[\theta]}
    {\gamma \yields (\theta,\mu/x) : \delta,x:\alpha}
\end{mathpar}

\item 2-cells between types:

  \begin{mathpar}
    \inferrule*{ }
          {\TypeTwo{\gamma}{\alpha/\alpha}{\alpha}{\alpha}}

    \inferrule*{{\TypeTwo{\gamma}{s_1}{\alpha_1}{\alpha_2}} \and
                {\TypeTwo{\gamma}{s_2}{\alpha_2}{\alpha_3}}
          }
          {\TypeTwo{\gamma}{s_2[s_3]}{\alpha_1}{\alpha_3}}

\inferrule*{\gamma,x:\alpha,\gamma' \yields {\beta} : \type \and
             \TermTwoT{\gamma}{t}{\mu}{\mu'}{\alpha}
           } 
           {\TypeTwo{\gamma,?}{\beta[t/x]}{\beta[\mu/x]}{\beta[\mu'/x]}}
\end{mathpar}

  %%% FIXME: make n-ary admissible?
  %% \inferrule*
  %%   {\gamma, \delta \yields \alpha \type \\
  %%    \SubTwo{\gamma}{s}{\theta}{\theta'}}
  %%   {\TypeTwo{\gamma}{\alpha[s]}{\alpha[\theta]}{\alpha[\theta']}}


  \drlnote{What happens to $\gamma'$ in the last rule?}

In LSR/renaming direction, these two should end up adjoint
as $s^\circ \dashv s^+$:

\item 2-cells between terms:

\begin{mathpar}
\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (x : \beta \in \gamma)
    }
    {\TermTwo{\gamma}{\varepsilon}{\TrCirc{s}{\TrPlus{s}{x}}}{x}}

\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (y : \alpha \in \gamma)
    }
    {\TermTwo{\gamma}{\eta}{y}{\TrPlus{s}{\TrCirc{s}{y}}}}
\end{mathpar}
Satisfying the triangle identities. \mvrnote{Is there a better way to enforce adjointness?}
\end{enumerate}

We can also tuple up the above kinds of 2-cell to get:
\begin{enumerate}
\item 2-cells between telescopes:
  \begin{mathpar}
    \inferrule*
    {\TeleTwo{\gamma}{t}{\delta}{\delta'} \\
     \TypeTwo{\gamma, \delta}{s}{\alpha}{\alpha'[\TrCirc{t}{\delta}/\delta']}}
    {\TeleTwo{\gamma}{(t,s)}{(\delta, \alpha)}{(\delta',\alpha')}}  
  \end{mathpar}
Above, this action $\TrCirc{t}{\delta}$ of $t$ on a telescope $\delta$ is defined inductively by:
  \begin{mathpar}
    \inferrule*
    {\gamma, \delta \yields \TrCirc{t}{\delta} : \delta' \\
     \gamma, \delta, x : \alpha \yields \TrCirc{s}{x} : \alpha'[\TrCirc{t}{\delta}/\delta']}
    {\gamma, (\delta, x : \alpha) \yields (\TrCirc{t}{\delta}, \TrCirc{s}{x}) : (\delta', x : \alpha') }  
  \end{mathpar}
  
We could instead tuple the 2-cells using $s^+$: 
\begin{mathpar}
    \inferrule*
    {\TeleTwo{\gamma}{t}{\delta}{\delta'} \\
     \TypeTwo{\gamma, \delta'}{s}{\alpha[\TrPlus{t}{\delta'}/\delta]}{\alpha'}}
    {\TeleTwo{\gamma}{(t,s)}{(\delta, \alpha)}{(\delta',\alpha')}}  
\end{mathpar}
where $\TrPlus{t}{\delta'}$ is defined by:
  \begin{mathpar}
    \inferrule*
    {\gamma, \delta' \yields \TrPlus{t}{\delta'} : \delta \\
     \gamma, \delta', x : \alpha' \yields \TrPlus{s}{x} : \alpha[\TrPlus{t}{\delta'}/\delta]}
    {\gamma, (\delta', x : \alpha') \yields (\TrPlus{t}{\delta}, \TrPlus{s}{x}) : (\delta, x : \alpha) }  
  \end{mathpar}

\item 2-cells between substitutions for telescopes:

  \begin{mathpar}

\inferrule*
    {\SubTwo{\gamma}{s}{\theta}{\theta'} \\
     \TermTwo{\gamma}{t}{\TrCirc{(\alpha[s])}{\mu}}{\mu'}}
    {\SubTwo{\gamma}{(s,t/x)}{(\theta, \mu/x)}{(\theta',\mu'/x)}}

\inferrule*
    {\TermTwo{\gamma, \delta}{s_1}{\mu}{\mu'} \\
      \SubTwo{\gamma}{s_2}{\theta}{\theta'}}
    {\TermTwo{\gamma}{s_1[s_2]}{\TrCirc{(s_1[\theta];\mu[s_2])}{\mu[\theta]}}{\mu'[\theta']}} 
\end{mathpar}
\end{enumerate}

\subsection{Contexts and telescopes (boring lifting to tuples)}

\begin{mathpar}
  \inferrule*[Left = ctx-form]{ }
  {\yields_{\cdot} \cdot \CTX  } \and 

  \inferrule*[Left = ctx-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx) \\\\
    \Gamma \yields_\alpha A \TYPE \and (\text{where }  \gamma \yields \alpha \type)}
  {\yields_{\gamma, x : \alpha} \Gamma, x : A \CTX \and (\text{where } \yields \gamma,x:\alpha \ctx)  } \\

  \inferrule*[Left = tele-form]{ }
             {\Gamma \yields \cdot \TELE_{\cdot}  } \and

  \inferrule*[Left = tele-form]{
    \Gamma \yields_\delta \Delta \TELE \and  (\text{where } \gamma \yields \delta \tele) \\\\
    \Gamma,\Delta \yields_\alpha A \TYPE \and (\text{where } \gamma,\delta \yields \alpha \type)}
  {\Gamma \yields_{\delta, x : \alpha} \Delta, x : A \TELE  \and (\text{where } \gamma \yields \delta,x:\alpha \tele)} \\ \\

  \and

  \inferrule*[Left = sub1]{ }
             {\Gamma \yields_\cdot \cdot : {\cdot}  } \and 
  \inferrule*[Left = sub2]{
    \Gamma \yields_\theta \Theta : \Delta  \and (\text{where } \gamma \yields \theta : \delta) \\\\
    \Gamma \yields_{\mu} M : A[\Theta] \and (\text{where } \gamma,\delta \yields \mu : \alpha[\theta])}
  {\Gamma \yields_{\theta, \mu/x } (\Theta,M/x) : \Delta, x : A  \and (\text{where } \gamma \yields (\theta,\mu/x) : \delta,x:\alpha)} \\ \\
\end{mathpar}


\subsection{Types and Terms}

\begin{mathpar}
  \inferrule*[Left = var]{
    % \yields \Gamma, x : A, \Gamma' \CTX_{\gamma, x : \alpha, \gamma'}
  }
  {\Gamma, x : A, \Gamma' \yields_x x : A \and (\text{where } \gamma,x:\alpha,\gamma' \yields x : \alpha)} \and

 \inferrule*[Left = 2cell]{
   \Gamma \yields_\mu M : A 
   \and \TermTwo{\gamma}{s}{\nu}{\mu}
  }
  {\Gamma \yields_\nu s(M) : A} \\ \\

  \inferrule*[Left = s-form]{
    \Gamma \yields_\alpha A \TYPE \and (\text{where } \gamma \yields \alpha \type)\\\\
    \and \TypeTwo{\gamma}{s}{\beta}{\alpha}
  }{\Gamma \yields_\beta \St{s}{A} \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = S-intro]{
    \Gamma \yields_{\mu} M : X
    \and (\text{where } \gamma \yields {\mu} : \xi)
  }
  {\Gamma \yields_{\TrPlus{s}{\mu}} \StI{s}{M} : \St{s}{X} \and (\text{where } \gamma \yields \TrPlus{s}{\mu} : \beta)} \\

  \inferrule*[Left = S-elim]{
    \Gamma, y : \St{s}{X} \yields_{\alpha} C \TYPE \and (\text{where } \gamma, y : \beta \yields \alpha \type) \and \\\\
    \Gamma \yields_{\nu} M : \St{s}{X} \and (\text{where } \gamma \yields \nu : \beta) \\\\
    \Gamma, x : X \yields_{\nu' [\TrPlus{s}{x} / y]} N : C [\StI{s}{x}/y]
    \and (\text{where } \gamma, x : \xi \yields \nu' [\TrPlus{s}{x} / y] : \alpha [\TrPlus{s}{x} / y] )}
  {\Gamma \yields_{\nu'[\nu/y]} \StE{M}{s}{x}{N} : C[M/y]  \and (\text{where } \gamma, \beta \yields {\nu'[\nu/y]} : \alpha[\nu/y])} \\
  
  \\
  \inferrule*[Left = F-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx)\\\\
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele) \\\\
    \gamma, \delta \yields \mu : \beta 
  }
  {\Gamma \yields_\beta F_\mu(\Delta) \TYPE \and (\text{where } \gamma \yields \beta \type) } \\
  
  \inferrule*[Left = F-intro]{
    \Gamma \yields_{\theta} \Theta : \Delta 
    \and (\text{where } \gamma \yields {\theta} : \delta)
    %% \and \gamma \yields \nu : \beta 
    %% \and \gamma \yields \mu[\theta] : \beta 
    %% \and \gamma \yields (\nu \Rightarrow \mu[\theta]) : \beta
  }
  {\Gamma \yields_{\mu[\theta]} \FI{\Theta} : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \mu[\theta] : \beta)} \\

  \inferrule*[Left = F-elim]{
    \Gamma, x : F_{\mu}(\Delta) \yields_{\alpha} C \TYPE \and (\text{where } \gamma, x : \beta \yields \alpha \type) \\\\
    \Gamma \yields_{\nu} M : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \nu : \beta) \\\\
    \Gamma, \Delta \yields_{\nu' [\mu / x]} N : C [\FI{\Delta/\Delta}/x]
    \and (\text{where } \gamma, \delta \yields \nu' [\mu / x] : \alpha [\mu / x] )}
  {\Gamma \yields_{\nu'[\nu/x]} \FE{M}{\Delta}{N} : C[M/x]  \and (\text{where } \gamma, \beta \yields {\nu'[\nu/x]} : \alpha[\nu/x])} \\
    \\ \\

  \inferrule*[Left = U-form]{
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele)\\\\
    \Gamma, \Delta \yields_\alpha A \TYPE \and (\text{where } \gamma, \delta \yields \alpha \type)\\\\
    \and \gamma, \delta, c : \beta \yields \mu : \alpha
  }{\Gamma \yields_\beta U_{c.\mu}(\Delta \vert A) \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = U-intro]{
    \Gamma, \Delta \yields_{\mu[\nu/c]} N : A \and (\text{where } \gamma,\delta \yields {\mu[\nu/c]} : \alpha)
  }
  {\Gamma \yields_{\nu} \UI \Delta N : U_{c.\mu}(\Delta \vert A)
    \and (\text{where } \gamma \yields \nu : \beta)
  } \\
  
  \inferrule*[Left = U-elim]{
    \Gamma \yields_\nu M : U_{c.\mu}(\Delta \vert A) \and (\text{where } \gamma \yields \nu : \beta)\\\\
    \Gamma \yields_\theta \Theta : \Delta \and (\text{where } \gamma \yields \theta : \delta)\\
  }{
    \Gamma \yields_{\mu[\theta,\nu/c]} \UE{M}{\Theta} : A[\Theta] \and (\text{where } \gamma \yields \mu[\theta,\nu/c] : \alpha[\theta])
  } \\
\end{mathpar}

Note that the intro/elim rules for \St{s}{A} only apply to base types $X$, and they are just the rules for $F$-types specialised to $\TrPlus{s}{-}$. For all other types the $s$ will push in via the following equalities:
\begin{align*}
\St{s}{\F{\mu}{\Delta}} &\equiv \F{\TrPlus{s}{\mu}}{\Delta} \\
\St{s}{\U{c.\mu}{\Delta}{A}} &\equiv \U{c.\mu[\TrCirc{s}{c}/c]}{\Delta}{A} \\
\St{s}{\St{t}{X}} &\equiv \St{t[s]}{X} \\
\St{\id_\xi}{X} &\equiv X
\end{align*}
And also the following, giving all the preconditions:
\begin{mathpar}
\inferrule*
{\Gamma \yields_{\delta_1, x_i' : \alpha_i', \delta_2} \Delta_1, x_i' : \St{s}{A_i}, \Delta_2 \TELE \and
     \gamma, \delta_1, x_i' : \alpha_i', \delta_2 \yields \mu : \alpha \and
     \TypeTwo{\gamma, \delta_1}{s}{\alpha_i'}{\alpha_i}
     }
{\Gamma \yields \F{\mu}{\Delta_1, x_i' : \St{s}{A_i}, \Delta_2} \equiv \F{\mu[\TrPlus{s}{x_i}/x_i']}{\Delta_1, x_i : A_i, \Delta_2[\StI{s}{x_i}/x_i']}} \\

\inferrule*{
    \Gamma \yields_{\delta_1, x_i' : \alpha_i', \delta_2} \Delta_1, x_i' : \St{s}{B_i}, \Delta_2 \TELE \and
    \Gamma, \Delta_1, x_i' : \St{s}{B_i}, \Delta_2 \yields_\alpha A \TYPE \\\\
%    \gamma, \delta_1, x_i' : \alpha_i', \delta_2 \yields \alpha \type \and
    \gamma, \delta_1, x_i' : \alpha_i', \delta_2, c : \beta \yields \mu : \alpha \and 
    \TypeTwo{\gamma, \delta_1}{s}{\alpha_i'}{\alpha_i}
  }{\Gamma \yields_\beta \U{c.\mu}{\Delta_1, x_i' : \St{s}{B_i}, \Delta_2}{A} 
     \equiv \U{c.\mu[\TrPlus{s}{x_i}/x_i']}{\Delta_1, x_i : B_i, \Delta_2[\StI{s}{x_i}/x_i']}{A[\StI{s}{x_i}/x_i']} 
     }   

\inferrule*{
    \Gamma \yields_\delta \Delta \TELE \and
    \Gamma, \Delta \yields_\alpha A \TYPE \and 
    \gamma, \delta, c : \beta \yields \mu : \alpha' \and
    \TypeTwo{\gamma, \delta_1}{s}{\alpha'}{\alpha}
  }{\Gamma \yields_\beta \U{c.\mu}{\Delta}{\St{s}{A}} \equiv \U{c.\TrCirc{s}{\mu}}{\Delta}{A}} 
\end{mathpar}
Note that these $F$ and $U$ types do actually live in the same mode: the type formation rules require that $\alpha$ and $\beta$ only depend on $\gamma$.

Then we should also be able to prove:
\[
\begin{array}{rcl}
\St{\id_\alpha}{A} & \equiv & A \\
\St{s}{\St{t}{A}} &\equiv & \St{t[s]}{A} \\
\St{\alpha[s]}{A[\Theta]} & \equiv & A[\St{s}{\Theta}]
\end{array}
\]
for general types, not just base types.

We should also have term definitional equalities over these (like
$\StI{\id_\alpha}{M} \equiv M$, $\StE{M}{\id_\alpha}{x}{x} \equiv M$).
%
%In the final equation, the typing is
%\begin{mathpar}
%\gamma,\delta \yields \alpha \type \and 
%\Gamma,\Delta \yields_\alpha A \type \and 
%\Gamma \yields s : \theta \Rightarrow \theta' : \delta \and
%\Gamma \yields_\theta \Theta : \Delta 
%\end{mathpar}
%This equation uses the operation
%\begin{mathpar}
% \inferrule*[Left = 2cell-subst]{
%   \Gamma \yields_\theta \Theta : \Delta 
%   \and \gamma \yields s : (\theta \Rightarrow \theta') : \delta
%  }
%  {\Gamma \yields_{\theta'} s_*(\Theta) : A} 
%\end{mathpar}
%is admissible. The extension case is given
%\begin{mathpar}
%(s,t/x) : (\theta,\mu/x) \Rightarrow (\theta',\mu'/x) : \delta,x:\alpha
%\and
%\yields_{\theta,\mu/x} (\Theta,M/x) : \Delta,x:A
%\end{mathpar}
%as in the typing rules for these above, and constructs
%\[
%(s_*(\Theta), \StI{\alpha[s]}{t_*(M)})
%\]
%Note that the second component uses the same third equation above (at a
%smaller context) to type check, because the term is supposed to have
%type $A[s_*(\Theta)]$, which we construct via the intro rule for
%$\St{(\alpha[s])}{A[\Theta]}$.

\subsection{Axiomatic Internal-Comprehension-Category Mode Theory (no
  strict equations on mode types (besides substitution))}

Just to make the point that we \emph{could} do it, here's what it looks
like to literally use standard dependent type theory with $\Sigma$ and
$=$ types as the mode theory.  I think it would be pretty unusable in
practice, because $\Sigma$ is only weakly associative, etc, so it would
be like using a weak monoid for linear logic, only with dependency.      
But it's a nice spec for the profunctor one.  

We need to give the rules for
\begin{enumerate}
\item $\gamma \ctx$ 
\item $\gamma \yields \alpha \type$ 
\item $\gamma \yields \mu : \alpha$ 
\item $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ 
\item $\TermTwo{\gamma}{s}{\mu}{\nu}$ 
\end{enumerate}

\begin{enumerate}

\item Mode \emph{types} are like contexts: if a mode is itself a
  comprehension category, then the \emph{types} are the objects of that
  comprehension category's category of contexts.  The mode \emph{terms}
  are the dependent types (note the level switch).

  \begin{mathpar}
  \inferrule*[]{~}
  {\gamma \yields \emptyset \type  } \and 

  \inferrule*[]{ \gamma \yields \beta \type \and \gamma \yields \mu : \beta}
               {\gamma \yields (\alpha, i : \mu) \type  } 
  \end{mathpar}

\item All mode theories must have the following rules for mode terms
  (which here are types, remember):
\begin{mathpar}
  \inferrule*{x : \alpha \in \gamma}
             {\gamma \yields x : \alpha}
             \qquad
  \inferrule*
    {\gamma \yields \mu : \beta \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{\mu} : \alpha}
\end{mathpar}
which here are the variable rule given by the comprehension
category, and the ``substitution'' of a dependent type
along a morphism in the category of contexts of the comprehension
category.  

The signature should say that the internal comprehension category has
$1,\Sigma,=$ types:
\begin{mathpar}
  \inferrule*{ }
             {\gamma \yields 1 : \alpha}
             \qquad
  \inferrule*
      {\gamma \yields \mu : \alpha \\
        \gamma \yields \mu' : (\alpha, i:\mu)
      }
      {\gamma \yields \Sigma i:\mu.\mu' : \alpha}
   \qquad
  \inferrule*
      {\gamma \mid \alpha \yields t : \mu \\
        \gamma \mid \alpha \yields t' : \mu
      }
      {\gamma \yields t =_\mu t' : \alpha}
\end{mathpar}
with equations like
\begin{mathpar}
\TrPlus{s}{1} = 1
\and
\TrPlus{s}{\Sigma i:\mu.\mu'} = \Sigma i':\TrPlus{s}{\mu}. \TrPlus{(s,i'/i)}{\mu'}
\and
\TrPlus{s}{t =_\mu t'} = \TrPlus{s}{t} =_{\TrPlus{s}{\mu}} \TrPlus{s}{t}
\end{mathpar}
We'd have to define \TrPlus{s}{t}
\[
  \inferrule*
    {\gamma \mid \beta \vdash t : \mu \\
      \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{t} : \TrPlus{s}{\mu}}
\]
too (which will also be the usual substitution rules).  

All mode theories must also have 
\[
\inferrule*
    {\gamma \yields \mu : \alpha \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrCirc{s}{\mu} : \beta}
\]
but this can be defined s in the categorical left-adjoint-to-pullback existential quantifier
$\exists_{f : A \to B}(P : A \to Prop) := \exists a:A. P(a) \times f(a) = b$.
In full this would need some iterated $\Sigma / =$ types but if  $\alpha$ and $\beta$ each have a single
variables, this is
\[
\inferrule*
    {\gamma \yields \mu : (i:\nu) \\
     \TypeTwo{\gamma}{s}{(i : \nu)}{(j:\nu')}
    }
    {\gamma \yields \TrCirc{s}{\mu} := (\Sigma i:\nu. \mu \times \TrPlus{s}{i} =_{\nu'} j) : j:\nu'}
\]
This is well-formed because
$\gamma \vdash \nu : (j : \mu')$ by weakening ($\nu$ has no free $i$ variables),
$\gamma \vdash \mu : (j:\nu', i:\nu)$ by weakening, 
and $\TrPlus{s}{i} =_{\nu'} j$ because both sides have type $\nu'$.
This should make the adjunction $s^\circ \dashv s^+$ true for the usual
reasons.  

\item For this mode theory, we take
  we take \TypeTwo{\gamma}{s}{\beta}{\alpha}
  to be all substitutions
  $\gamma \mid \beta \yields \sigma : \alpha$.  
  \begin{mathpar}
  \inferrule{ }
            { \gamma \mid \beta \yields \cdot : \cdot }
  \and 
  \inferrule{ \gamma \mid \beta \yields s : \alpha \and 
              \gamma \mid \beta \yields t : \TrPlus{\sigma}{\mu} }
            { \gamma \mid \beta \yields (s, t/i) : (\alpha, i : \mu) }
  \end{mathpar}

\item The substitution extension uses the following term-in-a-mode-term
  judgement $\gamma \mid \alpha \vdash t : \mu$ (for
  $\gamma \vdash \mu : \alpha$), which just has the familiar rules:
\begin{mathpar}
  \inferrule{  i : \mu \in \alpha  }
            { \gamma \mid \alpha \vdash i : {\mu} }
  \and
  \inferrule{ }
            { \gamma \mid \beta \vdash {()} : {1} }
  \\ \\
  \inferrule{ \gamma \mid \alpha \vdash {t} : {\alpha} \and 
              \gamma \mid \alpha \vdash {t'} : {\TrPlus{(t/i)}{\mu'}} }
            { \gamma \mid \alpha \vdash {(t,t')} : {\Sigma i:\mu.\mu'}  }
   \and 
  \inferrule{ \gamma \mid \alpha \vdash t : {\Sigma i:\mu.\mu'} }
            { \gamma \mid \alpha \vdash {\mathsf{fst}(t)} : {\mu} }
    \and 
  \inferrule{ \gamma \mid \alpha \vdash t : {\Sigma i:\mu.\mu'} }
            { \gamma \mid \alpha \vdash {\mathsf{snd}(t)} : {\TrPlus{(t/i)}{\mu'}} }
\end{mathpar}
where the $\Sigma$ rules use the following special case of
$\TrPlus{s}{\mu}$:
\[
  \inferrule*
    {\gamma \yields \mu' : \alpha,i:\mu \\
     \gamma \mid \alpha \yields t : \mu'
    }
    {\gamma \yields \TrPlus{(t/i)}{\mu'} : \alpha}
\]

The rules for $t =_\mu t'$ should presumably be refl, equality
reflection, UIP.  What happens if you put HoTT here?  :-)

Define a term 2-cell $\TermTwoT{\gamma}{t}{\mu}{\mu'}{\alpha}$ to be a
term $\gamma \mid \alpha,i:\mu \yields t : \mu'$.  

\end{enumerate}

\subsection{Axiomatic Strict Internal-Comprehension-Category Mode Theory}

We could also do a version where the internal comprehension category
\emph{types} (mode terms) are given by generators, but rather than
having a full dependent type theory, we make the universal properties of
those types strict equalities.  (This works because $\Sigma,1,=$ are all
left-invertible.)

\begin{enumerate}

\item Define mode types (contexts in the internal comprehension category) as in the previous section

\item Define mode terms (types in the internal comprehension category)
  as in the previous section

\item In place of the term-in-mode-term rules for $\Sigma,1,=$ (pairing,
  projection, etc), add equations like
\[
\begin{array}{c}
  \alpha, i : (\Sigma j:\mu.\mu'), \alpha' \equiv (\alpha, j:\mu, i:\mu',\TrPlus{(j,i)/i}{\alpha'})\\
  \alpha, i:1, \alpha' \equiv \alpha, \TrPlus{(()/i)}{\alpha'} \\
  \alpha, \TrPlus{s}{\mu} \equiv ? \\
  (\alpha, i : \mu, \alpha', i \equiv t, \alpha'') \equiv \alpha, \TrPlus{(t/x)}{\alpha',\alpha''} \\
  (\alpha, i : (t,t') = (u,u'), \alpha') \equiv (\alpha, i : t = u, j : t' = u', \alpha') \\
\end{array}
\]
(for $=$ present unification via rewrite rules)

Then for  \TypeTwo{\gamma}{s}{\beta}{\alpha} is it sufficient to
first rewrite both contexts into normal form and then do a renaming
(variable for variable substitution) as in the profunctor version?
\begin{mathpar}
  \inferrule*[]{  }
             {\gamma \mid \beta \yields () : \emptyset  }
             \and
  \inferrule*[]{ \gamma \mid \beta \yields s : \alpha \and
                 j : \TrPlus{s}{\mu} \in \beta}
  {\gamma \mid \beta \yields (\sigma, j/i) : (\alpha, i : \mu)} \\
\end{mathpar}

\item
Define a term 2-cell $\TermTwoT{\gamma}{t}{\mu}{\mu'}{\alpha}$ to be a
renaming $\gamma \mid \alpha,i:\mu \yields s : \alpha, i:\mu'$
that commutes with the projections to $\alpha$ as in the profunctor stuff?
\end{enumerate}

Then the profunctory one seems like it's taking the additonal step of
saying that the \emph{types} (mode terms) are exactly the 
(renamings) between mode contexts, and doing ``hereditary substitution''
to keep things in normal form all the time.  

\subsection{Modalities}

It seems like the $f_0, f_1$ idea from before fits here.  Suppose you
have two modes $p$ and $q$ that each are internal comprehension
categories, then we can have
\[
\inferrule*[]{ \gamma \vdash \alpha : \type_p}
             { \gamma \vdash f_0(\alpha) : \type_{q}} 
\]
for a modality on contexts, and 
\[
\inferrule*[]{ \gamma \vdash \mu : \alpha}
             { \gamma \vdash f_1(\mu) : f_0(\alpha)}
\]
if it's a fiberwise modality with
\begin{mathpar}
f_0(\alpha, i : \mu) = f_0(\alpha), i : f_1(\mu) \and
f_1(\Sigma i : \mu.\mu') = \Sigma i:f_1(\mu), f_1(\mu')
\end{mathpar}

Q: what does $f_1(t =_\mu t')$ do?

A binary constructor on mode types would get something bunchy where the bunches can't
depend on each other (this came up for the smash prodcut in the Eric
S-cohesion I think)
\[
\inferrule*[]{ \gamma \vdash \alpha : \type_p \and
               \gamma \vdash \beta : \type_p }
             { \gamma \vdash \alpha \otimes \beta : \type_{p} }
\]
but here we wouldn't want a corresponding version on mode terms.  

Q: if you do the profunctory kind of presentation, where do the $f_1's$
go, if it's something like $\flat$ that pushes all the way inside?


\subsection{Profunctory Internal-Comprehension-Category Mode Theory}

The basic idea is that a type is a list of variable dependencies, with some information attached to each dependency saying how it relates to the previously specified dependencies in the same type.

We use an auxilliary judgement $\gamma \mid \beta \yields \sigma : \alpha$ that places the type $\beta$ in a place we can treat it as a minicontext: we have been calling these `substitutions' but I think I will call them renamings in what follows. These are renamings/variable-for-variables substitutions between the lists that constitute $\alpha$ and $\beta$.

Weakening and exchange in the context and weakening the minicontext should be straightforwardly admissible. Exchange in the minicontext should also be admissible (wherever it makes sense), and to properly match the semantics, we should probably be identifying such rearrangements.

\begin{mathpar}
  \inferrule*[]{~}
  {\gamma \yields \emptyset \type  } \and 
  \inferrule*[]{ \gamma \yields \beta \type \and \gamma \mid \beta \yields \sigma : \alpha \and (x : \alpha) \in \gamma}
  {\gamma \yields (\beta, i : x[\sigma]) \type  } \\

  \inferrule*[]{ \gamma \yields \beta \type}
  {\gamma \mid \beta \yields () : \emptyset  } \and
  \inferrule*[]{ \gamma \mid \beta \yields \sigma : \alpha \and  \gamma \mid \alpha \yields \tau : \delta \and (j : x[\tau[\sigma]]) \in \beta}
  {\gamma \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])} \\
  
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields (\beta \mid \sigma)
   : \alpha} \\
\end{mathpar}

Where $\tau[\sigma]$ is an admissible substitution rule for renamings, defined below.

\subsubsection{Substitution}

It will take a bit of work to show that substitution is admissible. A substitution $\alpha[(\beta \mid \sigma) / x_0]$ (roughly) expands out to calculating the `pushout' of two natural transformations between types in terms of cell gluing. (Although it looks like an operation on two maps \emph{into} $\alpha$ using the substitution notation.) Intuitively is gluing the list $\beta$ into $\alpha$ everywhere that $x_0$ is used, identifying things as specified by $\sigma$.

This is not too hard to do by hand in simple cases, here are some examples. To reduce the clutter we will denote the unique renaming into $\emptyset$ by $\cdot$, and when it is used to attach a dependency, omit entirely.

Working in the context $x : \emptyset, y : \emptyset, z : \emptyset$ we have things like:
\begin{align*}
(i : x)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y) \\
(i : x, m : z)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y, m : z)
\end{align*}
In context $x : \emptyset, y : \emptyset, z : (i : y)$ we can do:
\begin{align*}
(i : y, j : z[i/i])[(i_1 : x, i_2 : x \mid\, \cdot)/ y] = (i_1 : x, i_2 : x, j : z[i_1/i_1, i_2/i_2])
\end{align*}
as the type of $z$ is now $(i_1 : x, i_2 : x)$. And as an example of some actual gluing, take the context $x : \emptyset, y : (i : x), z : (i : x)$, we can do
\begin{align*}
(i : x, j : y[i/i])[(i : x k : z[i/i] \mid i/i ) / y] = (i : x, k : z[i/i])
\end{align*}

To prove substitution is admissible, the main steps would be:
\begin{enumerate}
\item Composition for renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\item An identity renaming: $\gamma \mid \alpha \yields \id : \alpha$.
\item A `pushout' operation: 
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\item The following Lemma, which looks morally like a more complicated version of $\inl$, (to be proven simultaneously with substitution I suppose)
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0 \mid \alpha \yields \tau : \alpha_0 \and (i : x_0[\tau]) \in \alpha \and \gamma \mid \beta \yields \sigma : \alpha_0}{\gamma \mid \alpha[(\beta \mid \sigma) / x_0] \yields \sigma' : \beta}
\end{mathpar}
such that $\sigma[\sigma'] = \tau[(\beta \mid \sigma)/x_0]$
\item Substitution itself, for types, terms, renamings.
\end{enumerate}

So here we go:

\begin{lemma}
Weakening and exchange are admissible for the minicontext in renamings.
\end{lemma}

\begin{lemma}
Renamings actually work: 
\begin{mathpar}
\inferrule*[]{(i : x[\sigma]) \in \alpha \and \gamma \mid \beta \yields \tau : \alpha}{(j : x[\sigma[\tau]]) \in \beta}
\end{mathpar}
\end{lemma}
\begin{proof}
Note that in the judgement $(i : x[\sigma]) \in \alpha$, the $\sigma$ is being implicitly weakened from some prefix of $\alpha$.
\end{proof}

\begin{lemma}
Composition for renamings is admissible, and this composition is associative.
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\alpha$. When $\alpha = \emptyset$, we have the empty renaming $()$. 

If instead $\alpha = (\alpha', i : x[\theta])$, where $\gamma \mid \alpha' \yields \theta : \kappa$, we must have obtained $\gamma \mid \beta \yields \sigma : (\alpha', i : x[\theta])$ via the renaming-extension rule applied to $\gamma \mid \beta \yields \sigma' : \alpha'$ and $(j : x[\theta[\sigma']]) \in \beta$.

Now inductively we have $\gamma \mid \delta \yields \sigma'[\tau] : \alpha'$, and we reapply the renaming-extension rule with $(j : x[\theta [\sigma'][\tau]]) \in \delta$ (using associativity).

\mvrnote{todo associativity}
\end{proof}

\begin{lemma}
For any type there is an identity renaming $\gamma \mid \alpha \yields \id_\alpha : \alpha$, and $\sigma[\id] = \sigma = \id[\sigma]$.
\end{lemma}
\begin{proof}
When $\alpha = \emptyset$, use the empty renaming.

When $\alpha = (\alpha', i : x[\tau])$, inductively form $\id_{\alpha'}$, weaken the minicontext with $i : x[\tau]$, and apply the renaming-extension rule with $(i : x[\tau[\id_{\alpha'}]]) \in (\alpha', i : x[\tau]) $

\mvrnote{todo the properties}
\end{proof}

\begin{lemma}
Given $(i : x[\tau]) \in \alpha$ and $(i' : x[\tau]) \in \alpha$, there is a type $\alpha_{i=i'}$ where the two variables have been identified. This comes with a renaming $\gamma \mid \alpha_{i=i'} \yields \nabla_{i=i'} : \alpha$, and if $\gamma \mid \beta \yields \sigma : \alpha$ identifies $i$ and $i'$, then it factors through $\nabla_{i=i'}$, let us write this factorisation $\sigma = \nabla_{i=i'}[\sigma_{i=i'}]$.
\end{lemma}
\begin{proof}
Without loss of generality $\alpha$ is of the form $\alpha = (\alpha_1, i : x[\tau], \alpha_2, i' : x[\tau], \alpha_3)$. Set 
\begin{align*}
\alpha_{i=i'} &:= (\alpha_1, i : x[\tau], \alpha_2, \alpha_3[i/i']) \\
\nabla_{i=i'} &:= [\alpha_1/\alpha_1, i / i, \alpha_2/\alpha_2, i / i', \alpha_3/\alpha_3]
\end{align*}

\mvrnote{The factorisation thing seems clear to me but annoying to write down}
\end{proof}

\begin{lemma}
We can construct pushouts of renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\end{lemma}
\begin{proof}
Again induction on $\alpha$. If $\alpha = \emptyset$, then we must have $\sigma = \tau = ()$. We define $\Pushout{\beta}{\emptyset}{\beta'}{()}{()}$ to be just $\beta$ and $\beta'$ concatenated. There are evident $\inl$ and $\inr$ renamings that pick out the $\beta$ or $\beta'$ part, and $\sigma[\inl] = \sigma'[\inr]$ is vacuously true as these are renamings into $\emptyset$.

For the inductive case, suppose:
\begin{align*}
\alpha &= (\alpha, i : x[\tau]) \\
\sigma &= (\sigma, j/i) && \text{where } (j : x [\tau[\sigma]]) \in \beta \\
\sigma' &= (\sigma', j'/i) && \text{where } (j' : x [\tau[\sigma']]) \in \beta'
\end{align*}
Inductively we have $\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$ and the corresponding $\inl/\inr$. Pushing $j$ and $j'$ forward along $\inl$ and $\inr$, and using associativity of renamings, we have 
\begin{align*}
(j[\inl] : x[\tau[\sigma[\inl]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \\
(j'[\inr] : x[\tau[\sigma'[\inr]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}
\end{align*}
Because $\sigma[\inl] = \sigma'[\inr]$, these variables are a pair that can be identified, and so we do:
\begin{align*}
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma', j'/i)} := (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}
\end{align*}

Now to define $\inl$, we compose the inductively given $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ with the contraction substitution $\gamma \mid (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \yields \nabla : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. Define $\inr$ similarly.

Checking the equation amounts to verifying $\sigma[\inl[\nabla]] = \sigma'[\inr[\nabla]]$, but this is clear by associativity and the inductive hypothesis.
\end{proof}

\begin{lemma}
Universal property for pushout, i.e.:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha \\\\ 
\gamma \mid \delta \yields \theta : \beta \and \gamma \mid \delta \yields \theta' : \beta' \\\\ 
\sigma[\theta] = \sigma'[\theta']}
{\gamma \mid \delta \yields \case^{\sigma, \sigma'}_\alpha(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}}
\end{mathpar}
\end{lemma}
\begin{proof}
If $\alpha = \emptyset$, then the pushout is $(\beta, \beta')$, and we have the renaming $\gamma \mid \delta \yields (\theta / \beta, \theta' / \beta') : (\beta, \beta')$.

If $\alpha = (\alpha, i : x[\tau])$, we inductively have $\case(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. To get the renaming into $(\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}$, we just have to show that $\case(\theta, \theta')$ identifies $j[\inl]$ and $j'[\inr]$. This follows from the equation $\sigma[\theta] = \sigma'[\theta']$, as $j$ and $j'$ are $i$ pushed forward along $\sigma$ and $\sigma'$. \mvrnote{This is sketchy}. We then have an induced renaming $\case(\theta, \theta')_{j[\inl] = j'[\inr]}$.

Note: it appears we only need existence, not uniqueness.
\end{proof}

The following three lemmas all refer to each other so will be proven by mutual induction. In what follows, if $\gamma \yields \mu : \alpha$ is a term, let $\gamma \mid \bar \mu \yields \mu : \alpha$ be its underlying renaming.

\begin{lemma}\label{inl-sub}
$\inr$ for substitution:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \alpha \yields \tau : \alpha_0 \and (i_0 : x_0[\tau]) \in \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0}
\end{mathpar}
such that $\mu_0[\ini_{i_0}(\mu_0)] = \tau[\mu_0/x_0]$
\end{lemma}
\begin{proof}

Note that because $\tau$ is a substitution for $\alpha_0$, and $x_0$ is not used in $\alpha_0$, $\tau$ can't use any variable in $x_0 : \alpha_0, \gamma'$. This premise could be replaced by something like $\gamma \mid \alpha' \yields \tau : \alpha_0$ where $\alpha'$ the subset of $\alpha$ only containing variables from $\gamma$.

Induction on $\alpha$. We cannot have $\alpha = \emptyset$, as we have assumed $(i_0 : x_0[\tau]) \in \alpha$.

If $\alpha = (\alpha, i : x[\tau])$ with $i \neq i_0$, then $i_0$ must appear earlier in $\alpha$ somewhere and inductively we know $\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0$, and we can just weaken the minicontext to $(\alpha[\mu_0 / x_0], i : x[\tau[\mu_0 / x_0]])$. Inductively the equation holds, and weakening doesn't change this.

If instead $\alpha = (\alpha, i_0 : x[\tau])$, then by definition $(\alpha, i_0 : x[\tau])[\mu_0/x_0] = \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$ and we can use $\inr$. \mvrnote{todo equation}
\end{proof}

\begin{lemma}
Substitution into types:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \yields \beta \type \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\beta$. If $\beta = \emptyset$ there is nothing to do. \mvrnote{except deal with $\gamma'$}

If $\beta = (\beta, i : x[\sigma])$ for $x \neq x_0$, by the inductive step we have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$. We can then find $(x : \alpha[\mu_0/x_0]) \in \gamma, \gamma'[\mu_0/x_0]$ and reapply the rule.

If $\beta = (\beta, i : x_0[\sigma])$, then $\sigma$ here is $\gamma, x_0 : \alpha_0, \gamma'\mid \beta \yields \sigma : \alpha_0$. Again we inductively have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$ and $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha_0[\mu_0/x_0]$. Note here that $\alpha_0[\mu_0/x_0] = \alpha_0$ because $x_0$ does not occur in $\alpha_0$. 

We then form the pushout of this $\sigma[\mu_0/x_0]$ along the renaming underlying $\mu_0$, yielding the type \[\Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0}\] as our answer.
\end{proof}

\begin{lemma}
Substitution into renamings:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields \sigma : \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\sigma$. If $\sigma$ is the empty renaming there is nothing to do.

So suppose we have just applied the renaming-extension rule to get $\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])$, where $(j : x[\tau[\sigma]]) \in \beta$. Inductively we have $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]$. 

Again there are two cases. If $x \neq x_0$, we can reapply the rule with $(j : x[\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]]) \in \beta[\mu_0/x_0]$. (Here we have to use an interchange rule for renamings and substitution: $\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]] = \tau[\sigma][\mu_0/x_0]$)

If $x = x_0$, our goal is a renaming into $(\alpha, i : x_0[\tau])[\mu_0/x_0]$, which is $\Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$. For this we use the universal property of pushouts, applied to the following diagram (where confusingly the arrows go the opposite direction of renamings):
\[
\begin{tikzcd}
\alpha_0 \ar[r, "{\tau[\mu_0/x_0]}"] \ar[d, "\mu_0" swap] & \alpha[\mu_0/x_0] \ar[d] \ar[ddr, bend left, "{\sigma[\mu_0/x_0]}"] & \\
\bar \mu_0 \ar[r] \ar[drr, bend right, "\ini_j(\mu_0)" swap]& \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0} \ar[dr, dashed] & \\
& & \beta[\mu_0/x_0]
\end{tikzcd}
\]
\end{proof}

In summary:
\begin{align*}
\Pushout{\beta}{\emptyset}{\beta'}{()}{()} &:= (\beta, \beta') \\
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma, j'/i)} &:= (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \\
\inl^{(), ()}_\emptyset(\beta, \beta') &:= [\beta/\beta] \\
\inl^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inl^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\inr^{(), ()}_\emptyset(\beta, \beta') &:= [\beta'/\beta'] \\
\inr^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inr^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\case^{(),()}_\emptyset(\theta, \theta') &:= (\theta / \beta, \theta' / \beta') \\
\case^{(\sigma,j/i),(\sigma', j'/i)}_{(\alpha,i:x[\tau])}(\theta, \theta') &:= \case^{\sigma, \sigma'}_{\alpha}(\theta, \theta')_{j[\inl]=j'[\inr]} \\
\ini_{i_0 \in (\alpha, i : x[\sigma])}(\mu_0) &:= \ini_{i_0 \in \alpha}(\mu_0)\\
\ini_{i_0 \in (\alpha, i_0 : x[\sigma])}(\mu_0) &:= \inr^{\sigma[\mu_0/x_0],\mu_0}_{\alpha_0}(\alpha[\mu_0/x_0], \bar \mu_0) \\
\\
\emptyset[\mu_0/x_0] &:= \emptyset \\
(\beta, i : x[\sigma])[\mu_0/x_0] &:= (\beta[\mu_0/x_0], i : x[\sigma[\mu_0/x_0]]) \\
(\beta, i : x_0[\sigma])[\mu_0/x_0] &:= \Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0} \\
\\
()[\mu_0/x_0] &:= () \\
(\sigma, j/i)[\mu_0/x_0] &:= (\sigma[\mu_0/x_0], j[\mu_0/x_0]/i) && \text{where } (j : x[\tau[\sigma]]) \in \beta, x \neq x_0 \\
(\sigma, j/i)[\mu_0/x_0] &:= \case(\sigma[\mu_0/x_0], \ini_j(\mu_0)) && \text{where } (j : x_0[\tau[\sigma]]) \in \beta \\
\\
\end{align*}

\subsubsection{The Variable Rule}
This isn't built in, but we can define it:
\begin{lemma}
Variable rule:
\begin{mathpar}
\inferrule*[]{~}{\gamma, x : \alpha, \gamma' \yields x : \alpha}
\end{mathpar}
\end{lemma}
\begin{proof}
This term is built as a renaming into $\alpha$. For this use \[\gamma, x : \alpha, \gamma' \mid \alpha, i : x[\alpha/\alpha]\yields (\alpha/\alpha) : \alpha\]
\end{proof}
Note that this is a projection, so whatever term rule we have must allow projections.

\subsubsection{Defining $\TrPlus{s}{-}$ and $\TrCirc{s}{-}$}
Continue to use the convention that $\bar \mu$ denotes the type underlying a term $\mu : \alpha$. As suggested by their names, type 2-cells $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ act in the mode theory as follows:
\begin{lemma}
\begin{mathpar}
\inferrule*
    {\gamma \yields \mu : \beta \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{\mu} : \alpha}

\inferrule*
    {\gamma \yields \mu : \alpha \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrCirc{s}{\mu} : \beta}
\end{mathpar}
\end{lemma}
\begin{proof}
For $s^+$, construct the pushout $\Pushout{\bar \mu}{\beta}{\alpha}{\mu}{s}$. The renaming $\gamma \mid \Pushout{\bar \mu}{\beta}{\alpha}{\mu}{s} \yields \inr : \alpha$ is the desired term. 

For $s^\circ$, we compose the renaming $s$ with $\mu$, so: $\gamma \mid \bar \mu \yields s[\mu] : \beta$.
\end{proof}

And we build the unit and counit:
\begin{lemma}
\begin{mathpar}
\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (x : \beta \in \gamma)
    }
    {\TermTwo{\gamma}{\varepsilon}{\TrCirc{s}{\TrPlus{s}{x}}}{x}}

\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (y : \alpha \in \gamma)
    }
    {\TermTwo{\gamma}{\eta}{y}{\TrPlus{s}{\TrCirc{s}{y}}}}
\end{mathpar}
\end{lemma}
\begin{proof}
The counit is the upper right triangle in the following pushout diagram (written in natural transformation direction):
\[
\begin{tikzcd}[column sep={2cm,between origins},row sep={2cm,between origins}]
\beta \ar[r, "x"] \ar[d, "s" swap]  \ar[dr, "\TrCirc{s}{\TrPlus{s}{x}}" near start] & \bar x \ar[d, "\inl"] \\
\alpha \ar[r, "\TrPlus{s}{x}" swap] & \overline{\TrPlus{s}{x}} \\
\end{tikzcd}
\]

The unit is the triangle on the right:
\[
\begin{tikzcd}
\beta \ar[d, "s" swap] \ar[r, "s"]& \alpha \ar[dd, "\TrPlus{s}{\TrCirc{s}{x}}"] \ar[dddr, bend left = 40, "x"] &  \\
\alpha \ar[d, "x" swap] & & \\
\bar x \ar[r, "\inl" swap]  \ar[drr, "\id" swap, bend right] & \overline{\TrPlus{s}{\TrCirc{s}{x}}} \ar[dr, dashed]& \\
& & \bar x
\end{tikzcd}
\]
\end{proof}

\subsubsection{$\Sigma$ and $\Pi$}

$\Sigma$ ought to be the $F$ type for \[\gamma, x : \alpha, y : (\alpha, i : x[\id_\alpha]) \yields (\alpha, i : x[\id_\alpha], j : y[\id_{(\alpha, x)}] \mid \alpha / \alpha) : \alpha\]

Let's call this $\sigma_x(y)$, or something. As a sanity check, we can test this with a simple case of $F$-left.
\begin{mathpar}
\inferrule*[Left=F-left]{\Gamma, x : A, y : B(x) \yields_{\id_{(\alpha, z)}[\sigma_x(y)/z]} c[\FI{x,y}/z] : C[\FI{x,y}/z]}{\Gamma, z : F_{\sigma_x(y)}(x:A, y : B(x)) \yields_{\id_{(\alpha, z)}} c : C}
\end{mathpar}
And presumably $\id_{(\alpha, z)}[\sigma_x(y)/z] = \id_{(\alpha, x, y)}$, as the pushout would identify $x$ and $y$'s dependence on an $\alpha$ with the existing $\alpha$ in $(\alpha, z)$.

And the $F$-intro rule 
\begin{mathpar}
\inferrule*[Left=F-right$^*$]{~}{\Gamma, x : A, y: B(x) \yields_{\sigma_x(y)} \mathsf{pair}(x,y) : F_{\sigma_x(y)}(x:A, y : B(x))}
\end{mathpar}
could be read as saying that the term $\mathsf{pair}(x,y) := \FI{x,y}$ uses exactly what the type $A$ does, plus one usage of $x$ and one usage of $y$.

$\Pi$ ought to be the $U$ type for \[\gamma, x : \alpha, y : \alpha \yields (\alpha, i : x[\id_\alpha], j : y[\id_{\alpha}] \mid \alpha / \alpha, i / i) : (\alpha, i : x[\id_\alpha])\]
If we call this $\pi_x(y)$, we can try the $U$-right rule in a simple case:
\begin{mathpar}
  \inferrule*[Left = U-right]{\Gamma, x : A \yields_{\pi_x(y)[(\alpha \mid \id_\alpha) / y]} N : B}
  {\Gamma \yields_{(\alpha \mid \id_\alpha)} \UI x N : U_{y.\pi_x(y)}(A \vert B)} \\
\end{mathpar}
And then $\pi_x(y)[(\id_\alpha\vert \alpha)/y] = (\alpha, i : x[\id_\alpha] \mid \id) : (\alpha, i : x[\id_\alpha])$, as the $\alpha$ from the $y$ has been glued to the existing one.

\subsubsection{Structurality}

We can change what structural rules are available by changing which renamings we are permitted to promote to 2-cells.

\begin{enumerate}
\item The term rule controls how the dependencies of a term relate to the dependencies of its type. By construction, the dependencies of a term bound the dependencies of the type, but we could restrict this further: Allowing only `relevant' renamings here would say that terms can't use variables that their types didn't.

We could choose to not consider types `up to ordering', so that the order of dependencies mattes. Then, allowing only identity renamings in the term rule would demand that terms have have the same dependencies as their types, in the same order. (Whatever this means!)

\item The type 2-cells control the structural rules in the types
\item The term 2-cells control the structural rules in the terms
\end{enumerate}

E.g., for full structurality, we would use:

\begin{mathpar}
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\TypeTwo{\gamma}{\sigma}{\beta}{\alpha}}  \and   \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \tau : \beta}
  {
  \TermTwo{\gamma}{s}{(\beta \mid \sigma)}{(\beta' \mid \sigma[\tau])}}
\end{mathpar}

These choices cannot be totally arbitrary: 
\begin{enumerate}
\item The variable rule requires that the term rule at least permits projections. Also, we need a type 2-cell $\TypeTwo{\gamma}{s}{\alpha} {\beta}$ to act on terms via $\TrCirc{s}{-}$ and $\TrPlus{s}{-}$. This means, terms must be closed under composition with and pushout along type 2-cells.
\item We need term 2-cells $\TermTwo{\gamma}{s}{\mu}{\mu'}$ to induce type 2-cells via substitution: $\TypeTwo{\gamma}{s}{\alpha[\mu/x]}{\alpha[\mu'/x]}$. \mvrnote{What exactly is required for this? Enough that term 2-cells are included in type 2-cells?}
\item For each type 2-cell $\TypeTwo{\gamma}{s}{\alpha} {\beta}$, the corresponding unit and counit term 2-cells must exist.
\end{enumerate}

As an example, it appears these choices could allow a type system where the types behave fully structurally and the terms behave linearly, but not vis versa.

\subsection{Modal Type Theories}
\newcommand{\Modes}{\mathcal{M}}

Now let's try to match the idea where we have a small 2-category $\Modes$, and we want a dependent type theory that uses $\Modes$ as the modes. It seems that we want to annotate
\begin{itemize}
\item Types with a mode $p \in \ob \Modes$ so $\gamma \yields \alpha \type_p$
\item Dependencies in a type with a morphism $f : p \to q$, so $\gamma \mid \beta \yields_f \sigma : \alpha$.
\item Variable usages in a renaming with a 2-cell $s : f \Rightarrow g$.
\end{itemize}

A first naive attempt, that doesn't work, is:

\begin{mathpar}
  \inferrule*[]{p \in \ob \Modes}
  {\gamma \yields \emptyset_p \type_p  } \and 
  \inferrule*[]{ \gamma \yields \beta \type_p \and \gamma \yields \alpha \type_q \and f : p \to q \in \Modes \and \gamma \mid \beta \yields_f \sigma : \alpha \and (x : \alpha) \in \gamma }
  {\gamma \yields (\beta, i : x_f[\sigma]) \type_p  } \\

  \inferrule*[]{ \gamma \yields \beta \type_p \and f : p \to q \in \Modes}
  {\gamma \mid \beta \yields_f () : \emptyset_q  } \and
  \inferrule*[]{ \gamma \mid \beta \yields_f \sigma : \alpha \and  \gamma \mid \alpha \yields_g \tau : \delta \and (j : x_h[\tau[\sigma]]) \in \beta \and s : gf \Rightarrow h \in \Modes}
  {\gamma \mid \beta \yields_f (\sigma, j_s/i) : (\alpha, i : x_g[\tau])} \\
\end{mathpar}
But above, saying $x_h[\tau[\sigma]]$ doesn't make sense, as presumably $\tau[\sigma]$ is a renaming that is mapped to $gf$. I think we may need an inductively defined way to extend the $s : f \Rightarrow g$ 2-cells in $\Modes$ to a kind of 2-cell between renamings. 

\subsection{Bunchy Type Theories}

\end{document}

