\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{amssymb,amsthm,bbm}
\usepackage[centertags]{amsmath}
\usepackage{stackengine}
\stackMath
\usepackage[mathscr]{euscript}
\usepackage{tikz-cd}
\usepackage{mathpartir}
\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{ms}{anms}{\color{blue}MS}
\FXRegisterAuthor{todo}{andrl}{\color{red} }
\FXRegisterAuthor{mvr}{anmvr}{\color{olive}MVR}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}

\let\oldemptyset\emptyset
\let\emptyset\varnothing

\newcommand{\yields}{\vdash}
\newcommand{\cbar}{\, | \,}

\newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}
\newcommand{\CTX}{\,\,\mathsf{CTX}}
\newcommand{\ctx}{\,\,\mathsf{ctx}}
\newcommand{\TYPE}{\,\,\mathsf{TYPE}}
\newcommand{\type}{\,\,\mathsf{type}}
\newcommand{\TELE}{\,\,\mathsf{TELE}}
\newcommand{\tele}{\,\,\mathsf{tele}}

\newcommand\F[2]{\ensuremath{\mathsf{F}_{#1}(#2)}}
\newcommand\U[3]{\ensuremath{\mathsf{U}_{#1}(#2 \mid #3)}}
\newcommand\St[2]{\ensuremath{{#1}(#2)}}
\newcommand\StI[2]{\ensuremath{\mathsf{st}(#1,#2)}}
%\newcommand\StE[2]{\ensuremath{\mathsf{unst}(#1,#2)}}
\newcommand\StE[4]{\ensuremath{\mathsf{let} \, \StI{#2}{#3} \, = \, {#1} \, \mathsf{in} \, #4}}
\newcommand\FE[3]{\ensuremath{\mathsf{split} \, #2 \, = \, {#1} \, \mathsf{in} \, #3}}
\newcommand\FI[1]{\ensuremath{\mathsf{F}{(#1)}}}
\newcommand\UE[2]{\ensuremath{#1(#2)}}
\newcommand\UI[2]{\ensuremath{\lambda #1.#2}}
\newcommand\TypeTwo[4]{\ensuremath{#1 \mid #3 \yields_\mathsf{ty} #2 : #4}}
\newcommand\TeleTwo[4]{\ensuremath{#1 \mid #3 \yields_\mathsf{tele} #2 : #4}}
\newcommand\TermTwo[4]{\ensuremath{#1 \mid #3 \yields_\mathsf{tm} #2 : #4}}
\newcommand\SubTwo[4]{\ensuremath{#1 \mid #3 \yields_\mathsf{sub} #2 : #4}}
\newcommand\TrPlus[2]{\ensuremath{#1^+(#2)}}
\newcommand\TrCirc[2]{\ensuremath{#1^\circ(#2)}}

\newcommand\Set[0]{\ensuremath{\textbf{Set}}}
\newcommand\Hom[3]{\ensuremath{\textbf{hom}_{#1}(#2,#3)}}
\newcommand\just[1]{\ensuremath{\textsf{just}_{#1}}}
\newcommand\Dt[2]{\ensuremath{#1.#2}}

\newcommand\Push[3]{\ensuremath{#1 +_{#2} #3}}
\newcommand\Pushout[5]{\ensuremath{#1 +^{#4,#5}_{#2} #3}}
\newcommand{\case}{\mathsf{case}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}
\newcommand{\ini}{\mathsf{in}}

\newcommand{\id}{\mathsf{id}}
\DeclareMathOperator{\ob}{ob}

\title{Adjoint Type Theory}
\author{}
\date{}

\begin{document}
\maketitle

\section{Syntax}

\subsection{Overview of Judgements}

Mode theory judgements:
\begin{itemize}
\item $\gamma \ctx$ (empty, extension)
\item $\gamma \yields \alpha \type$ (generators)
\item $\gamma \yields \delta \tele$ (empty, extension)
\item $\gamma \yields \mu : \alpha$ (variables, generators, ``coercion''
  along $s : \alpha \Rightarrow \beta \type$)
\item $\gamma \yields \theta : \delta$ (tuples)
\item $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ (identity,
  composition, ap of a type constant on a telescope of 2-cells)
\item $\TeleTwo{\gamma}{s}{\delta}{\delta'}$ (tupled up type 2-cells)
\item $\TermTwo{\gamma}{s}{\mu}{\nu}$ (identity,
  composition, horizontal composition, generators)
\item $\SubTwo{\gamma}{s}{\theta}{\theta'}$ (tupled up term 2-cells)
\end{itemize}
Top judgements: 
\begin{itemize}
\item $\yields_\gamma \Gamma \CTX$ over $\yields \gamma \ctx$
\item $\Gamma \yields_\alpha A \TYPE$ over $\gamma \yields \alpha \type$
\item $\Gamma \yields_\mu M : A$ over $\gamma \yields \mu : \alpha$
\item Telescopes $\Gamma \yields_\delta \Delta \TELE$ over $\gamma \yields \delta \tele$
\item Substitutions $\Gamma \yields_\theta \Theta : \Delta$ over $\gamma \yields \theta : \delta$
\end{itemize}

Coercion along 2-cells $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ acts in \emph{both directions} in the mode theory, but $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ and $\TermTwo{\gamma}{s}{\mu}{\nu}$ act \emph{contravariantly} on the subscripts of upstairs terms.

We expect structurality to be admissible for the base, and structurality
over that to be admissible for the top, e.g.:

\begin{mathpar}
\inferrule*[Left = weaken-over]
           {\Gamma,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,\gamma' \vdash \mu : \alpha)}
           {\Gamma,y:B,\Gamma' \yields_\mu M : A \and (\text{where } \gamma,y:\beta,\gamma' \vdash \mu : \alpha)}

\inferrule*[Left = subst-over]
           {\Gamma,x:A,\Gamma' \yields_\nu N : C \and (\text{where } \gamma,x:\alpha,\gamma' \vdash \nu : \gamma) \\\\
            \Gamma \vdash_\mu M : A \and (\text{where } \gamma \vdash \mu : \alpha)
           }
           {\Gamma,\Gamma'[M/x] \yields_{\nu[\mu/x]} N[M/x] : A[M/x] \and (\text{where } \gamma,\gamma'[\mu/x] \vdash \nu[\mu/x] : \alpha[\mu/x])}
\end{mathpar}

\subsection{Mode Theory}

Rules for 2-cells:

\begin{mathpar}
\inferrule*
    {\gamma \yields \mu : \beta \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{\mu} : \alpha}
    
\inferrule*
    {\gamma \yields \mu : \alpha \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrCirc{s}{\mu} : \beta}
\end{mathpar}

Equations for $\TrPlus{s}{\mu}$ and $\TrCirc{s}{\mu}$ are identity, composition. In LSR/renaming direction, these two should end up adjoint as $s^\circ \dashv s^+$. 

\begin{mathpar}
\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (x : \beta \in \gamma)
    }
    {\TermTwo{\gamma}{\varepsilon}{\TrCirc{s}{\TrPlus{s}{x}}}{x}}

\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (y : \alpha \in \gamma)
    }
    {\TermTwo{\gamma}{\eta}{y}{\TrPlus{s}{\TrCirc{s}{y}}}}
\end{mathpar}
Satisfying the triangle identities. \mvrnote{Is there a better way to enforce adjointness?}

We can also tuple up both term 2-cells and type 2-cells:

\begin{mathpar}
\inferrule*
    {\TeleTwo{\gamma}{s}{\delta}{\delta'} \\
     \TypeTwo{\gamma, \delta}{t}{\alpha}{\alpha'[\TrPlus{s}{\delta}/\delta']}}
    {\TeleTwo{\gamma}{(s,t)}{(\delta, \alpha)}{(\delta',\alpha')}} 
    
    \\\\

\inferrule*
    {\SubTwo{\gamma}{s}{\theta}{\theta'} \\
     \TermTwo{\gamma}{t}{\TrCirc{(\alpha[s])}{\mu}}{\mu'}}
    {\SubTwo{\gamma}{(s,t/x)}{(\theta, \mu/x)}{(\theta',\mu'/x)}}

\inferrule*
    {\gamma, \delta \yields \alpha \type \\
     \SubTwo{\gamma}{s}{\theta}{\theta'}}
    {\TypeTwo{\gamma}{\alpha[s]}{\alpha[\theta]}{\alpha[\theta']}}

\inferrule*
    {\TermTwo{\gamma, \delta}{s_1}{\mu}{\mu'} \\
      \SubTwo{\gamma}{s_2}{\theta}{\theta'}}
    {\TermTwo{\gamma}{s_1[s_2]}{\TrCirc{(s_1[\theta];\mu[s_2])}{\mu[\theta]}}{\mu'[\theta']}} 
\end{mathpar}

Both kinds of tupling could equivalently be expressed using the other of $s^+$ or $s^\circ$, by adjointness.

\subsection{Contexts and telescopes (boring lifting to tuples)}

\begin{mathpar}
  \inferrule*[Left = ctx-form]{ }
  {\yields_{\cdot} \cdot \CTX  } \and 

  \inferrule*[Left = ctx-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx) \\\\
    \Gamma \yields_\alpha A \TYPE \and (\text{where }  \gamma \yields \alpha \type)}
  {\yields_{\gamma, x : \alpha} \Gamma, x : A \CTX \and (\text{where } \yields \gamma,x:\alpha \ctx)  } \\

  \inferrule*[Left = tele-form]{ }
             {\Gamma \yields \cdot \TELE_{\cdot}  } \and

  \inferrule*[Left = tele-form]{
    \Gamma \yields_\delta \Delta \TELE \and  (\text{where } \gamma \yields \delta \tele) \\\\
    \Gamma,\Delta \yields_\alpha A \TYPE \and (\text{where } \gamma,\delta \yields \alpha \type)}
  {\Gamma \yields_{\delta, x : \alpha} \Delta, x : A \TELE  \and (\text{where } \gamma \yields \delta,x:\alpha \tele)} \\ \\

  \and

  \inferrule*[Left = sub1]{ }
             {\Gamma \yields_\cdot \cdot : {\cdot}  } \and 
  \inferrule*[Left = sub2]{
    \Gamma \yields_\theta \Theta : \Delta  \and (\text{where } \gamma \yields \theta : \delta) \\\\
    \Gamma \yields_{\mu} M : A[\Theta] \and (\text{where } \gamma,\delta \yields \mu : \alpha[\theta])}
  {\Gamma \yields_{\theta, \mu/x } (\Theta,M/x) : \Delta, x : A  \and (\text{where } \gamma \yields (\theta,\mu/x) : \delta,x:\alpha)} \\ \\
\end{mathpar}


\subsection{Types and Terms}

\begin{mathpar}
  \inferrule*[Left = var]{
    % \yields \Gamma, x : A, \Gamma' \CTX_{\gamma, x : \alpha, \gamma'}
  }
  {\Gamma, x : A, \Gamma' \yields_x x : A \and (\text{where } \gamma,x:\alpha,\gamma' \yields x : \alpha)} \and

 \inferrule*[Left = 2cell]{
   \Gamma \yields_\mu M : A 
   \and \TermTwo{\gamma}{s}{\nu}{\mu}
  }
  {\Gamma \yields_\nu s(M) : A} \\ \\

  \inferrule*[Left = s-form]{
    \Gamma \yields_\alpha A \TYPE \and (\text{where } \gamma \yields \alpha \type)\\\\
    \and \TypeTwo{\gamma}{s}{\beta}{\alpha}
  }{\Gamma \yields_\beta \St{s}{A} \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = S-intro]{
    \Gamma \yields_{\mu} M : X
    \and (\text{where } \gamma \yields {\mu} : \xi)
  }
  {\Gamma \yields_{\TrPlus{s}{\mu}} \StI{s}{M} : \St{s}{X} \and (\text{where } \gamma \yields \TrPlus{s}{\mu} : \beta)} \\

  \inferrule*[Left = S-elim]{
    \Gamma, y : \St{s}{X} \yields_{\alpha} C \TYPE \and (\text{where } \gamma, y : \beta \yields \alpha \type) \and \\\\
    \Gamma \yields_{\nu} M : \St{s}{X} \and (\text{where } \gamma \yields \nu : \beta) \\\\
    \Gamma, x : X \yields_{\nu' [\TrPlus{s}{x} / y]} N : C [\StI{s}{x}/y]
    \and (\text{where } \gamma, x : \xi \yields \nu' [\TrPlus{s}{x} / y] : \alpha [\TrPlus{s}{x} / y] )}
  {\Gamma \yields_{\nu'[\nu/y]} \StE{M}{s}{x}{N} : C[M/y]  \and (\text{where } \gamma, \beta \yields {\nu'[\nu/y]} : \alpha[\nu/y])} \\
  
  \\
  \inferrule*[Left = F-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx)\\\\
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele) \\\\
    \gamma, \delta \yields \mu : \beta 
  }
  {\Gamma \yields_\beta F_\mu(\Delta) \TYPE \and (\text{where } \gamma \yields \beta \type) } \\
  
  \inferrule*[Left = F-intro]{
    \Gamma \yields_{\theta} \Theta : \Delta 
    \and (\text{where } \gamma \yields {\theta} : \delta)
    %% \and \gamma \yields \nu : \beta 
    %% \and \gamma \yields \mu[\theta] : \beta 
    %% \and \gamma \yields (\nu \Rightarrow \mu[\theta]) : \beta
  }
  {\Gamma \yields_{\mu[\theta]} \FI{\Theta} : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \mu[\theta] : \beta)} \\

  \inferrule*[Left = F-elim]{
    \Gamma, x : F_{\mu}(\Delta) \yields_{\alpha} C \TYPE \and (\text{where } \gamma, x : \beta \yields \alpha \type) \\\\
    \Gamma \yields_{\nu} M : F_{\mu}(\Delta) \and (\text{where } \gamma \yields \nu : \beta) \\\\
    \Gamma, \Delta \yields_{\nu' [\mu / x]} N : C [\FI{\Delta/\Delta}/x]
    \and (\text{where } \gamma, \delta \yields \nu' [\mu / x] : \alpha [\mu / x] )}
  {\Gamma \yields_{\nu'[\nu/x]} \FE{M}{\Delta}{N} : C[M/x]  \and (\text{where } \gamma, \beta \yields {\nu'[\nu/x]} : \alpha[\nu/x])} \\
    \\ \\

  \inferrule*[Left = U-form]{
    \Gamma \yields_\delta \Delta \TELE \and (\text{where } \gamma \yields \delta \tele)\\\\
    \Gamma, \Delta \yields_\alpha A \TYPE \and (\text{where } \gamma, \delta \yields \alpha \type)\\\\
    \and \gamma, \delta, c : \beta \yields \mu : \alpha
  }{\Gamma \yields_\beta U_{c.\mu}(\Delta \vert A) \TYPE \and (\text{where } \gamma \yields \beta \type)} \\

  \inferrule*[Left = U-intro]{
    \Gamma, \Delta \yields_{\mu[\nu/c]} N : A \and (\text{where } \gamma,\delta \yields {\mu[\nu/c]} : \alpha)
  }
  {\Gamma \yields_{\nu} \UI \Delta N : U_{c.\mu}(\Delta \vert A)
    \and (\text{where } \gamma \yields \nu : \beta)
  } \\
  
  \inferrule*[Left = U-elim]{
    \Gamma \yields_\nu M : U_{c.\mu}(\Delta \vert A) \and (\text{where } \gamma \yields \nu : \beta)\\\\
    \Gamma \yields_\theta \Theta : \Delta \and (\text{where } \gamma \yields \theta : \delta)\\
  }{
    \Gamma \yields_{\mu[\theta,\nu/c]} \UE{M}{\Theta} : A[\Theta] \and (\text{where } \gamma \yields \mu[\theta,\nu/c] : \alpha[\theta])
  } \\
\end{mathpar}

Note that the intro/elim rules for \St{s}{A} only apply to base types $X$, and they are just the rules for $F$-types specialised to $\TrPlus{s}{-}$. For all other types the $s$ will push in via the following equalities:
\begin{align*}
\St{s}{\F{\mu}{\Delta}} &\equiv \F{\TrPlus{s}{\mu}}{\Delta} \\
\St{s}{\U{c.\mu}{\Delta}{A}} &\equiv \U{c.\mu[\TrCirc{s}{c}/c]}{\Delta}{A} \\
\St{s}{\St{t}{X}} &\equiv \St{t[s]}{X} \\
\St{\id_\xi}{X} &\equiv X \\
~\\
\F{\mu}{s(\Delta)} &\equiv \F{\mu[\TrPlus{s}{\delta}/\delta]}{\Delta} \\
\U{c.\mu}{s(\Delta)}{A} &\equiv \U{c.\mu[\TrPlus{s}{\delta}/\delta]}{\Delta}{A} \\
\U{c.\mu}{\Delta}{\St{s}{A}} &\equiv \U{c.\TrCirc{s}{\mu}}{\Delta}{A}
\end{align*}

Then we should also be able to prove:
\[
\begin{array}{rcl}
\St{\id_\alpha}{A} & \equiv & A \\
\St{s}{\St{t}{A}} &\equiv & \St{t[s]}{A} \\
\St{\alpha[s]}{A[\Theta]} & \equiv & A[\St{s}{\Theta}]
\end{array}
\]

We should also have term definitional equalities over these (like
$\StI{\id_\alpha}{M} \equiv M$, $\StE{M}{\id_\alpha}{x}{x} \equiv M$).
%
%In the final equation, the typing is
%\begin{mathpar}
%\gamma,\delta \yields \alpha \type \and 
%\Gamma,\Delta \yields_\alpha A \type \and 
%\Gamma \yields s : \theta \Rightarrow \theta' : \delta \and
%\Gamma \yields_\theta \Theta : \Delta 
%\end{mathpar}
%This equation uses the operation
%\begin{mathpar}
% \inferrule*[Left = 2cell-subst]{
%   \Gamma \yields_\theta \Theta : \Delta 
%   \and \gamma \yields s : (\theta \Rightarrow \theta') : \delta
%  }
%  {\Gamma \yields_{\theta'} s_*(\Theta) : A} 
%\end{mathpar}
%is admissible. The extension case is given
%\begin{mathpar}
%(s,t/x) : (\theta,\mu/x) \Rightarrow (\theta',\mu'/x) : \delta,x:\alpha
%\and
%\yields_{\theta,\mu/x} (\Theta,M/x) : \Delta,x:A
%\end{mathpar}
%as in the typing rules for these above, and constructs
%\[
%(s_*(\Theta), \StI{\alpha[s]}{t_*(M)})
%\]
%Note that the second component uses the same third equation above (at a
%smaller context) to type check, because the term is supposed to have
%type $A[s_*(\Theta)]$, which we construct via the intro rule for
%$\St{(\alpha[s])}{A[\Theta]}$.

\subsection{Recovering Ordinary TT}

The basic idea is that a type is a list of variable dependencies, with some information attached to each dependency saying how it relates to the previously specified dependencies in the same type.

We use an auxilliary judgement $\gamma \mid \beta \yields \sigma : \alpha$ that places the type $\beta$ in a place we can treat it as a minicontext: we have been calling these `substitutions' but I think I will call them renamings in what follows. These are renamings/variable-for-variables substitutions between the lists that constitute $\alpha$ and $\beta$.

Weakening and exchange in the context and weakening the minicontext should be straightforwardly admissible. Exchange in the minicontext should also be admissible (wherever it makes sense), and to properly match the semantics, we should probably be identifying such rearrangements.

\begin{mathpar}
  \inferrule*[]{~}
  {\gamma \yields \emptyset \type  } \and 
  \inferrule*[]{ \gamma \yields \beta \type \and \gamma \mid \beta \yields \sigma : \alpha \and (x : \alpha) \in \gamma}
  {\gamma \yields (\beta, i : x[\sigma]) \type  } \\

  \inferrule*[]{ \gamma \yields \beta \type}
  {\gamma \mid \beta \yields () : \emptyset  } \and
  \inferrule*[]{ \gamma \mid \beta \yields \sigma : \alpha \and  \gamma \mid \alpha \yields \tau : \delta \and (j : x[\tau[\sigma]]) \in \beta}
  {\gamma \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])} \\
  
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields (\beta \mid \sigma)
   : \alpha} \\
   
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields \sigma : \alpha \Rightarrow \beta}  \and   \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \tau : \beta}
  {\gamma \yields s : (\beta \mid \sigma) \Rightarrow (\beta' \mid \sigma[\tau]) : \alpha} \\
\end{mathpar}

Where $\tau[\sigma]$ is an admissible substitution rule for renamings, defined below.

\subsubsection{Substitution}

It will take a bit of work to show that substitution is admissible. A substitution $\alpha[(\beta \mid \sigma) / x_0]$ (roughly) expands out to calculating the `pushout' of two natural transformations between types in terms of cell gluing. (Although it looks like an operation on two maps \emph{into} $\alpha$ using the substitution notation.) Intuitively is gluing the list $\beta$ into $\alpha$ everywhere that $x_0$ is used, identifying things as specified by $\sigma$.

This is not too hard to do by hand in simple cases, here are some examples. To reduce the clutter we will denote the unique renaming into $\emptyset$ by $\cdot$, and when it is used to attach a dependency, omit entirely.

Working in the context $x : \emptyset, y : \emptyset, z : \emptyset$ we have things like:
\begin{align*}
(i : x)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y) \\
(i : x, m : z)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y, m : z)
\end{align*}
In context $x : \emptyset, y : \emptyset, z : (i : y)$ we can do:
\begin{align*}
(i : y, j : z[i/i])[(i_1 : x, i_2 : x \mid\, \cdot)/ y] = (i_1 : x, i_2 : x, j : z[i_1/i_1, i_2/i_2])
\end{align*}
as the type of $z$ is now $(i_1 : x, i_2 : x)$. And as an example of some actual gluing, take the context $x : \emptyset, y : (i : x), z : (i : x)$, we can do
\begin{align*}
(i : x, j : y[i/i])[(i : x k : z[i/i] \mid i/i ) / y] = (i : x, k : z[i/i])
\end{align*}

To prove substitution is admissible, the main steps would be:
\begin{enumerate}
\item Composition for renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\item An identity renaming: $\gamma \mid \alpha \yields \id : \alpha$.
\item A `pushout' operation: 
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\item The following Lemma, which looks morally like a more complicated version of $\inl$, (to be proven simultaneously with substitution I suppose)
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0 \mid \alpha \yields \tau : \alpha_0 \and (i : x_0[\tau]) \in \alpha \and \gamma \mid \beta \yields \sigma : \alpha_0}{\gamma \mid \alpha[(\beta \mid \sigma) / x_0] \yields \sigma' : \beta}
\end{mathpar}
such that $\sigma[\sigma'] = \tau[(\beta \mid \sigma)/x_0]$
\item Substitution itself, for types, terms, renamings.
\end{enumerate}

So here we go:

\begin{lemma}
Weakening and exchange are admissible for the minicontext in renamings.
\end{lemma}

\begin{lemma}
Renamings actually work: 
\begin{mathpar}
\inferrule*[]{(i : x[\sigma]) \in \alpha \and \gamma \mid \beta \yields \tau : \alpha}{(j : x[\sigma[\tau]]) \in \beta}
\end{mathpar}
\end{lemma}
\begin{proof}
Note that in the judgement $(i : x[\sigma]) \in \alpha$, the $\sigma$ is being implicitly weakened from some prefix of $\alpha$.
\end{proof}

\begin{lemma}
Composition for renamings is admissible, and this composition is associative.
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\alpha$. When $\alpha = \emptyset$, we have the empty renaming $()$. 

If instead $\alpha = (\alpha', i : x[\theta])$, where $\gamma \mid \alpha' \yields \theta : \kappa$, we must have obtained $\gamma \mid \beta \yields \sigma : (\alpha', i : x[\theta])$ via the renaming-extension rule applied to $\gamma \mid \beta \yields \sigma' : \alpha'$ and $(j : x[\theta[\sigma']]) \in \beta$.

Now inductively we have $\gamma \mid \delta \yields \sigma'[\tau] : \alpha'$, and we reapply the renaming-extension rule with $(j : x[\theta [\sigma'][\tau]]) \in \delta$ (using associativity).

\mvrnote{todo associativity}
\end{proof}

\begin{lemma}
For any type there is an identity renaming $\gamma \mid \alpha \yields \id_\alpha : \alpha$, and $\sigma[\id] = \sigma = \id[\sigma]$.
\end{lemma}
\begin{proof}
When $\alpha = \emptyset$, use the empty renaming.

When $\alpha = (\alpha', i : x[\tau])$, inductively form $\id_{\alpha'}$, weaken the minicontext with $i : x[\tau]$, and apply the renaming-extension rule with $(i : x[\tau[\id_{\alpha'}]]) \in (\alpha', i : x[\tau]) $

\mvrnote{todo the properties}
\end{proof}

\begin{lemma}
Given $(i : x[\tau]) \in \alpha$ and $(i' : x[\tau]) \in \alpha$, there is a type $\alpha_{i=i'}$ where the two variables have been identified. This comes with a renaming $\gamma \mid \alpha_{i=i'} \yields \nabla_{i=i'} : \alpha$, and if $\gamma \mid \beta \yields \sigma : \alpha$ identifies $i$ and $i'$, then it factors through $\nabla_{i=i'}$, let us write this factorisation $\sigma = \nabla_{i=i'}[\sigma_{i=i'}]$.
\end{lemma}
\begin{proof}
Without loss of generality $\alpha$ is of the form $\alpha = (\alpha_1, i : x[\tau], \alpha_2, i' : x[\tau], \alpha_3)$. Set 
\begin{align*}
\alpha_{i=i'} &:= (\alpha_1, i : x[\tau], \alpha_2, \alpha_3[i/i']) \\
\nabla_{i=i'} &:= [\alpha_1/\alpha_1, i / i, \alpha_2/\alpha_2, i / i', \alpha_3/\alpha_3]
\end{align*}

\mvrnote{The factorisation thing seems clear to me but annoying to write down}
\end{proof}

\begin{lemma}
We can construct pushouts of renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\end{lemma}
\begin{proof}
Again induction on $\alpha$. If $\alpha = \emptyset$, then we must have $\sigma = \tau = ()$. We define $\Pushout{\beta}{\emptyset}{\beta'}{()}{()}$ to be just $\beta$ and $\beta'$ concatenated. There are evident $\inl$ and $\inr$ renamings that pick out the $\beta$ or $\beta'$ part, and $\sigma[\inl] = \sigma'[\inr]$ is vacuously true as these are renamings into $\emptyset$.

For the inductive case, suppose:
\begin{align*}
\alpha &= (\alpha, i : x[\tau]) \\
\sigma &= (\sigma, j/i) && \text{where } (j : x [\tau[\sigma]]) \in \beta \\
\sigma' &= (\sigma', j'/i) && \text{where } (j' : x [\tau[\sigma']]) \in \beta'
\end{align*}
Inductively we have $\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$ and the corresponding $\inl/\inr$. Pushing $j$ and $j'$ forward along $\inl$ and $\inr$, and using associativity of renamings, we have 
\begin{align*}
(j[\inl] : x[\tau[\sigma[\inl]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \\
(j'[\inr] : x[\tau[\sigma'[\inr]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}
\end{align*}
Because $\sigma[\inl] = \sigma'[\inr]$, these variables are a pair that can be identified, and so we do:
\begin{align*}
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma', j'/i)} := (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}
\end{align*}

Now to define $\inl$, we compose the inductively given $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ with the contraction substitution $\gamma \mid (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \yields \nabla : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. Define $\inr$ similarly.

Checking the equation amounts to verifying $\sigma[\inl[\nabla]] = \sigma'[\inr[\nabla]]$, but this is clear by associativity and the inductive hypothesis.
\end{proof}

\begin{lemma}
Universal property for pushout, i.e.:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha \\\\ 
\gamma \mid \delta \yields \theta : \beta \and \gamma \mid \delta \yields \theta' : \beta' \\\\ 
\sigma[\theta] = \sigma'[\theta']}
{\gamma \mid \delta \yields \case^{\sigma, \sigma'}_\alpha(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}}
\end{mathpar}
\end{lemma}
\begin{proof}
If $\alpha = \emptyset$, then the pushout is $(\beta, \beta')$, and we have the renaming $\gamma \mid \delta \yields (\theta / \beta, \theta' / \beta') : (\beta, \beta')$.

If $\alpha = (\alpha, i : x[\tau])$, we inductively have $\case(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. To get the renaming into $(\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}$, we just have to show that $\case(\theta, \theta')$ identifies $j[\inl]$ and $j'[\inr]$. This follows from the equation $\sigma[\theta] = \sigma'[\theta']$, as $j$ and $j'$ are $i$ pushed forward along $\sigma$ and $\sigma'$. \mvrnote{This is sketchy}. We then have an induced renaming $\case(\theta, \theta')_{j[\inl] = j'[\inr]}$.

Note: it appears we only need existence, not uniqueness.
\end{proof}

The following three lemmas all refer to each other so will be proven by mutual induction. In what follows, if $\gamma \yields \mu : \alpha$ is a term, let $\gamma \mid \bar \mu \yields \mu : \alpha$ be its underlying renaming.

\begin{lemma}\label{inl-sub}
$\inr$ for substitution:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \alpha \yields \tau : \alpha_0 \and (i_0 : x_0[\tau]) \in \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0}
\end{mathpar}
such that $\mu_0[\ini_{i_0}(\mu_0)] = \tau[\mu_0/x_0]$
\end{lemma}
\begin{proof}

Note that because $\tau$ is a substitution for $\alpha_0$, and $x_0$ is not used in $\alpha_0$, $\tau$ can't use any variable in $x_0 : \alpha_0, \gamma'$. This premise could be replaced by something like $\gamma \mid \alpha' \yields \tau : \alpha_0$ where $\alpha'$ the subset of $\alpha$ only containing variables from $\gamma$.

Induction on $\alpha$. We cannot have $\alpha = \emptyset$, as we have assumed $(i_0 : x_0[\tau]) \in \alpha$.

If $\alpha = (\alpha, i : x[\tau])$ with $i \neq i_0$, then $i_0$ must appear earlier in $\alpha$ somewhere and inductively we know $\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0$, and we can just weaken the minicontext to $(\alpha[\mu_0 / x_0], i : x[\tau[\mu_0 / x_0]])$. Inductively the equation holds, and weakening doesn't change this.

If instead $\alpha = (\alpha, i_0 : x[\tau])$, then by definition $(\alpha, i_0 : x[\tau])[\mu_0/x_0] = \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$ and we can use $\inr$. \mvrnote{todo equation}
\end{proof}

\begin{lemma}
Substitution into types:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \yields \beta \type \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\beta$. If $\beta = \emptyset$ there is nothing to do. \mvrnote{except deal with $\gamma'$}

If $\beta = (\beta, i : x[\sigma])$ for $x \neq x_0$, by the inductive step we have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$. We can then find $(x : \alpha[\mu_0/x_0]) \in \gamma, \gamma'[\mu_0/x_0]$ and reapply the rule.

If $\beta = (\beta, i : x_0[\sigma])$, then $\sigma$ here is $\gamma, x_0 : \alpha_0, \gamma'\mid \beta \yields \sigma : \alpha_0$. Again we inductively have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$ and $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha_0[\mu_0/x_0]$. Note here that $\alpha_0[\mu_0/x_0] = \alpha_0$ because $x_0$ does not occur in $\alpha_0$. 

We then form the pushout of this $\sigma[\mu_0/x_0]$ along the renaming underlying $\mu_0$, yielding the type \[\Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0}\] as our answer.
\end{proof}

\begin{lemma}
Substitution into renamings:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields \sigma : \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\sigma$. If $\sigma$ is the empty renaming there is nothing to do.

So suppose we have just applied the renaming-extension rule to get $\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])$, where $(j : x[\tau[\sigma]]) \in \beta$. Inductively we have $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]$. 

Again there are two cases. If $x \neq x_0$, we can reapply the rule with $(j : x[\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]]) \in \beta[\mu_0/x_0]$. (Here we have to use an interchange rule for renamings and substitution: $\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]] = \tau[\sigma][\mu_0/x_0]$)

If $x = x_0$, our goal is a renaming into $(\alpha, i : x_0[\tau])[\mu_0/x_0]$, which is $\Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$. For this we use the universal property of pushouts, applied to the following diagram (where confusingly the arrows go the opposite direction of renamings):
\[
\begin{tikzcd}
\alpha_0 \ar[r, "{\tau[\mu_0/x_0]}"] \ar[d, "\mu_0" swap] & \alpha[\mu_0/x_0] \ar[d] \ar[ddr, bend left, "{\sigma[\mu_0/x_0]}"] & \\
\bar \mu_0 \ar[r] \ar[drr, bend right, "\ini_j(\mu_0)" swap]& \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0} \ar[dr, dashed] & \\
& & \beta[\mu_0/x_0]
\end{tikzcd}
\]
\end{proof}

In summary:
\begin{align*}
\Pushout{\beta}{\emptyset}{\beta'}{()}{()} &:= (\beta, \beta') \\
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma, j'/i)} &:= (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \\
\inl^{(), ()}_\emptyset(\beta, \beta') &:= [\beta/\beta] \\
\inl^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inl^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\inr^{(), ()}_\emptyset(\beta, \beta') &:= [\beta'/\beta'] \\
\inr^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inr^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\case^{(),()}_\emptyset(\theta, \theta') &:= (\theta / \beta, \theta' / \beta') \\
\case^{(\sigma,j/i),(\sigma', j'/i)}_{(\alpha,i:x[\tau])}(\theta, \theta') &:= \case^{\sigma, \sigma'}_{\alpha}(\theta, \theta')_{j[\inl]=j'[\inr]} \\
\ini_{i_0 \in (\alpha, i : x[\sigma])}(\mu_0) &:= \ini_{i_0 \in \alpha}(\mu_0)\\
\ini_{i_0 \in (\alpha, i_0 : x[\sigma])}(\mu_0) &:= \inr^{\sigma[\mu_0/x_0],\mu_0}_{\alpha_0}(\alpha[\mu_0/x_0], \bar \mu_0) \\
\\
\emptyset[\mu_0/x_0] &:= \emptyset \\
(\beta, i : x[\sigma])[\mu_0/x_0] &:= (\beta[\mu_0/x_0], i : x[\sigma[\mu_0/x_0]]) \\
(\beta, i : x_0[\sigma])[\mu_0/x_0] &:= \Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0} \\
\\
()[\mu_0/x_0] &:= () \\
(\sigma, j/i)[\mu_0/x_0] &:= (\sigma[\mu_0/x_0], j[\mu_0/x_0]/i) && \text{where } (j : x[\tau[\sigma]]) \in \beta, x \neq x_0 \\
(\sigma, j/i)[\mu_0/x_0] &:= \case(\sigma[\mu_0/x_0], \ini_j(\mu_0)) && \text{where } (j : x_0[\tau[\sigma]]) \in \beta \\
\\
\end{align*}

\subsubsection{$\Sigma$ and $\Pi$}

$\Sigma$ ought to be the $F$ type for \[\gamma, x : \alpha, y : (\alpha, i : x[\id_\alpha]) \yields (\alpha, i : x[\id_\alpha], j : y[\id_{(\alpha, x)}] \mid \alpha / \alpha) : \alpha\]

Let's call this $\sigma_x(y)$, or something. As a sanity check, we can test this with a simple case of $F$-left.
\begin{mathpar}
\inferrule*[Left=F-left]{\Gamma, x : A, y : B(x) \yields_{\id_{(\alpha, z)}[\sigma_x(y)/z]} c[\FI{x,y}/z] : C[\FI{x,y}/z]}{\Gamma, z : F_{\sigma_x(y)}(x:A, y : B(x)) \yields_{\id_{(\alpha, z)}} c : C}
\end{mathpar}
And presumably $\id_{(\alpha, z)}[\sigma_x(y)/z] = \id_{(\alpha, x, y)}$, as the pushout would identify $x$ and $y$'s dependence on an $\alpha$ with the existing $\alpha$ in $(\alpha, z)$.

And the $F$-intro rule 
\begin{mathpar}
\inferrule*[Left=F-right$^*$]{~}{\Gamma, x : A, y: B(x) \yields_{\sigma_x(y)} \mathsf{pair}(x,y) : F_{\sigma_x(y)}(x:A, y : B(x))}
\end{mathpar}
could be read as saying that the term $\mathsf{pair}(x,y) := \FI{x,y}$ uses exactly what the type $A$ does, plus one usage of $x$ and one usage of $y$.

$\Pi$ ought to be the $U$ type for \[\gamma, x : \alpha, y : \alpha \yields (\alpha, i : x[\id_\alpha], j : y[\id_{\alpha}] \mid \alpha / \alpha, i / i) : (\alpha, i : x[\id_\alpha])\]
If we call this $\pi_x(y)$, we can try the $U$-right rule in a simple case:
\begin{mathpar}
  \inferrule*[Left = U-right]{\Gamma, x : A \yields_{\pi_x(y)[(\alpha \mid \id_\alpha) / y]} N : B}
  {\Gamma \yields_{(\alpha \mid \id_\alpha)} \UI \Delta N : U_{y.\pi_x(y)}(A \vert B)} \\
\end{mathpar}
And then $\pi_x(y)[(\id_\alpha\vert \alpha)/y] = (\alpha, i : x[\id_\alpha] \mid \id) : (\alpha, i : x[\id_\alpha])$, as the $\alpha$ from the $y$ has been glued to the existing one.

\subsubsection{Structurality}
We can change what structural rules are available by fiddling with the final three rules, and only allowing some renamings to be used in each.

\begin{enumerate}
\item The term rule controls how the dependencies of a term relate to the dependencies of its type. By construction, the dependencies of a term bound the dependencies of the type, but we could restrict this further: Allowing only `relevant' renamings here would say that terms can't use variables that their types didn't.

We could choose to not consider types `up to ordering', so that the order of dependencies mattes. Then, allowing only identity renamings in the term rule would demand that terms have have the same dependencies as their types, in the same order. (Whatever this means!)

\item The type 2-cells control the structural rules in the types
\item The term 2-cells control the structural rules in the terms
\end{enumerate}

These choices cannot be totally arbitrary: if we want type 2-cells to act on terms, the renamings used for terms must be closed under composition with those for type 2-cells. Similarly, if we want term 2-cells to induce type 2-cells via substitution, \mvrnote{What exactly was required? Enough that term 2-cells are included in type 2-cells?}

As an example, it appears these choices could allow a type system where the types behave fully structurally and the terms behave linearly, but not vis versa.

\subsection{Modal Type Theories}
\newcommand{\Modes}{\mathcal{M}}

Now let's try to match the idea where we have a small 2-category $\Modes$, and we want a dependent type theory that uses $\Modes$ as the modes. It seems that we want to annotate
\begin{itemize}
\item Types with a mode $p \in \ob \Modes$ so $\gamma \yields \alpha \type_p$
\item Dependencies in a type with a morphism $f : p \to q$, so $\gamma \mid \beta \yields_f \sigma : \alpha$.
\item Variable usages in a renaming with a 2-cell $s : f \Rightarrow g$.
\end{itemize}

A first naive attempt, that doesn't work, is:

\begin{mathpar}
  \inferrule*[]{p \in \ob \Modes}
  {\gamma \yields \emptyset_p \type_p  } \and 
  \inferrule*[]{ \gamma \yields \beta \type_p \and \gamma \yields \alpha \type_q \and f : p \to q \in \Modes \and \gamma \mid \beta \yields_f \sigma : \alpha \and (x : \alpha) \in \gamma }
  {\gamma \yields (\beta, i : x_f[\sigma]) \type_p  } \\

  \inferrule*[]{ \gamma \yields \beta \type_p \and f : p \to q \in \Modes}
  {\gamma \mid \beta \yields_f () : \emptyset_q  } \and
  \inferrule*[]{ \gamma \mid \beta \yields_f \sigma : \alpha \and  \gamma \mid \alpha \yields_g \tau : \delta \and (j : x_h[\tau[\sigma]]) \in \beta \and s : gf \Rightarrow h \in \Modes}
  {\gamma \mid \beta \yields_f (\sigma, j_s/i) : (\alpha, i : x_g[\tau])} \\
\end{mathpar}
But above, saying $x_h[\tau[\sigma]]$ doesn't make sense, as presumably $\tau[\sigma]$ is a renaming that is mapped to $gf$. I think we may need an inductively defined way to extend the $s : f \Rightarrow g$ 2-cells in $\Modes$ to a kind of 2-cell between renamings. 

\subsection{Bunchy Type Theories}

\end{document}

