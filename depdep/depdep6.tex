\documentclass[10pt]{article}

\usepackage{fullpage}
\usepackage{amssymb,amsthm,bbm}
\usepackage[centertags]{amsmath}
\usepackage{stackengine}
\stackMath
\usepackage[mathscr]{euscript}
\usepackage{tikz-cd}
\usepackage{mathpartir}
\usepackage[status=draft,inline,nomargin]{fixme}
\FXRegisterAuthor{ms}{anms}{\color{blue}MS}
\FXRegisterAuthor{mvr}{anmvr}{\color{olive}MVR}
\FXRegisterAuthor{drl}{andrl}{\color{purple}DRL}

\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}

\let\oldemptyset\emptyset%
\let\emptyset\varnothing

\newcommand\dsd[1]{\ensuremath{\mathsf{#1}}}

\newcommand{\yields}{\vdash}
\newcommand{\Yields}{\vDash}
\newcommand{\cbar}{\, | \,}

\newcommand{\Id}[3]{\mathsf{Id}_{{#1}}(#2,#3)}
\newcommand{\CTX}{\,\,\mathsf{Ctx}}
\newcommand{\ctx}{\,\,\mathsf{mctx}}
\newcommand{\TYPE}{\,\,\mathsf{Type}}
\newcommand{\type}{\,\,\mathsf{mode}}
\newcommand{\TELE}{\,\,\mathsf{Tele}}
\newcommand{\tele}{\,\,\mathsf{mtele}}

\newcommand{\rewrite}[2]{\overleftarrow{#1}(#2)}
\newcommand\F[2]{\ensuremath{\mathsf{F}_{#1}(#2)}}
\newcommand\U[3]{\ensuremath{\mathsf{U}_{#1}(#2 \mid #3)}}
\newcommand\UE[2]{\ensuremath{#1(#2)}}
\newcommand\UI[2]{\ensuremath{\lambda #1.#2}}
\newcommand\St[2]{\ensuremath{{#1}^*(#2)}}
\newcommand\StI[2]{\ensuremath{\mathsf{st}_{#1}(#2)}}
\newcommand\UStI[2]{\ensuremath{\mathsf{ust}_{#1}(#2)}}
\newcommand\UnSt[2]{\ensuremath{\mathsf{unst}_{#1}(#2)}}
%\newcommand\StE[2]{\ensuremath{\mathsf{unst}(#1,#2)}}
\newcommand\StE[3]{\ensuremath{\mathsf{let} \, \StI{~}{#2} \, = \, {#1} \, \mathsf{in} \, #3}}
\newcommand\FE[3]{\ensuremath{\mathsf{let} \, \mathsf{F}(#2) \, = \, {#1} \, \mathsf{in} \, #3}}
\newcommand\FI[1]{\ensuremath{\mathsf{F}{(#1)}}}
\newcommand\TypeTwo[4]{\ensuremath{#1 \mid #3 \vDash #2 : #4}}
\newcommand\TeleTwo[4]{\ensuremath{#1 \mid #3 \vDash #2 : #4}}
\newcommand\TermTwo[4]{\ensuremath{#1 \mid #3 \vDash #2 : #4}}
\newcommand\TermTwoT[5]{\ensuremath{#1 \mid #3 \vDash_{#5} #2 : #4}}
%% \newcommand\TermTwoDisp[5]{\ensuremath{#1 \mid #3 \vDash_{\mathsf{disp}} #2 :_{#5} #4}}
\newcommand\SubTwo[4]{\ensuremath{#1 \mid #3 \vDash #2 : #4}}
\newcommand\TrPlus[2]{\ensuremath{{#1}^+(#2)}}
\newcommand\TrCirc[2]{\ensuremath{{#1}^\circ(#2)}}

\newcommand\Set[0]{\ensuremath{\textbf{Set}}}
\newcommand\Hom[3]{\ensuremath{\textbf{hom}_{#1}(#2,#3)}}
\newcommand\just[1]{\ensuremath{\textsf{just}_{#1}}}
\newcommand\Dt[2]{\ensuremath{#1.#2}}
\newcommand\proj[1]{\ensuremath{\mathsf{proj}_{#1}}}
\newcommand\var[1]{\ensuremath{\mathsf{var}_{#1}}}

\newcommand\Push[3]{\ensuremath{#1 +_{#2} #3}}
\newcommand\Pushout[5]{\ensuremath{#1 +^{#4,#5}_{#2} #3}}
\newcommand{\case}{\mathsf{case}}
\newcommand{\inl}{\mathsf{inl}}
\newcommand{\inr}{\mathsf{inr}}
\newcommand{\ini}{\mathsf{in}}

\newcommand{\id}{\mathsf{id}}
\DeclareMathOperator{\ob}{ob}

\newcommand\El[2]{\mathcal{T}_{#1}(#2)}
\newcommand\ApEl[2]{\mathcal{T}_{#1}\langle#2\rangle}

\newcommand\ap[2]{\ensuremath{#1 \langle #2 \rangle }}

\newcommand{\app}[2]{\ensuremath{#1 \: #2}}
\newcommand{\sigmacl}[3]{\ensuremath{\textnormal{$\Sigma$}\,#1{:}#2.\,#3}}
\newcommand{\fst}[1]{\app{\dsd{fst}}{#1}}
\newcommand{\snd}[1]{\app{\dsd{snd}}{#1}}
\newcommand{\picl}[3]{\ensuremath{\textnormal{$\Pi$}\,#1{:}#2.\,#3}}

\newcommand{\telety}[3]{\ensuremath{(#1{:}#2,#3)}}
\newcommand{\mt}[0]{\ensuremath{()}}

%% FIXME: notation?
\newcommand\extend[2]{\ensuremath{(#1,\id_{#2})}}

\newcommand\bdot[0]{\mathbin{.}}
\newcommand\bang[0]{\mathord{!}}

\newcommand\PP[1]{\mathcal{P}(#1)}
\newcommand\ApP[1]{\mathcal{P}\langle#1\rangle}
\newcommand\ii[0]{\dsd{i}}


\title{A Fibrational Framework for Modal Dependent Type Theories}
\author{Daniel R. Licata, Mitchell Riley, Michael Shulman}
\date{}

\begin{document}
\maketitle

\section{Syntax}

\subsection{Overview of Judgements}

Mode theory judgements:
\begin{enumerate}
\item $\gamma \ctx$ (empty, extension)
\item $\gamma \yields p \type$ 
\item $\TypeTwo{\gamma}{s}{p}{q}$ (horizontal and vertical composition, identities)
\item $\gamma \yields \mu : p$ (variables, action of mode type morphisms)
\item $\TermTwoT{\gamma}{s}{\mu}{\nu}{p}$ (horizontal and vertical
    composition, identities)
\end{enumerate}

Top judgements: 
\begin{itemize}
\item $\yields_\gamma \Gamma \CTX$ over $\yields \gamma \ctx$
\item $\Gamma \yields_p A \TYPE$ over $\gamma \yields p \type$
\item $\Gamma \yields_\mu M : A$ over $\gamma \yields \mu : p$
\end{itemize}

Mode type morphisms $\TypeTwo{\gamma}{s}{p}{q}$ induce 1-cells
in \emph{both directions} in the mode theory, but
$\TypeTwo{\gamma}{s}{p}{q}$ and $\TermTwo{\gamma}{s}{\mu}{\nu}$
act \emph{contravariantly} on the subscripts of upstairs terms.

We expect structurality to be admissible for the base, and structurality
over that to be admissible for the top, e.g.:
\begin{mathpar}
\inferrule*[Left = weaken-over]
           {\Gamma,\Gamma' \yields_\mu M : A \\ (\text{where } \gamma,\gamma' \vdash \mu : p)}
           {\Gamma,y:B,\Gamma' \yields_\mu M : A \\ (\text{where } \gamma,y:q,\gamma' \vdash \mu : p)}

\inferrule*[Left = subst-over]
           {\Gamma,x:A,\Gamma' \yields_\nu N : C \\ (\text{where } \gamma,x:p,\gamma' \vdash \nu : \gamma) \\\\
            \Gamma \vdash_\mu M : A \\ (\text{where } \gamma \vdash \mu : p)
           }
           {\Gamma,\Gamma'[M/x] \yields_{\nu[\mu/x]} N[M/x] : A[M/x] \\ (\text{where } \gamma,\gamma'[\mu/x] \vdash \nu[\mu/x] : p[\mu/x])}
\end{mathpar}


\subsection{Mode Theory}

\begin{enumerate}

\item Contexts are as usual:

\begin{mathpar}
  \inferrule*{ }
             {\cdot \ctx}
             
  \inferrule*
    {\gamma \ctx \\
     \gamma \yields p \type}
    {\gamma,x:p \ctx}
\end{mathpar}

\item We assume $1/\Sigma$ modes:
\begin{mathpar}
  \inferrule*{ } { \gamma \yields 1 \type }
  
  \inferrule*{ \gamma \yields p \type \\ 
               \gamma,x:p \yields q \type }
             {\gamma \yields \sigmacl{x}{p}{q} \type}

\end{mathpar}
  

\item In all mode theories, terms must have: 

\begin{mathpar}
\inferrule*{ }
             {\gamma,x : p, \gamma' \yields x : p}
             
\inferrule*
    {\gamma \yields \mu : q \\
     \TypeTwo{\gamma}{s}{p}{q}
    }
    {\gamma \yields \TrPlus{s}{\mu} : p}
    
\inferrule*
    {\gamma \yields \mu : p \\
     \TypeTwo{\gamma}{s}{p}{q}
    }
    {\gamma \yields \TrCirc{s}{\mu} : q}
\\
\TrCirc{\id}{\mu} \equiv \mu \qquad
\TrCirc{s'}{\TrCirc{s}{\mu}} \equiv \TrCirc{(s;s')}{\mu} \qquad
\TrPlus{\id}{\mu} \equiv \mu \qquad
\TrPlus{s'}{\TrPlus{s}{\mu}} \equiv \TrPlus{(s';s)}{\mu} 
\end{mathpar}

These are adjoint as $s^\circ \dashv s^+$; this is the direction that identifies $F_{s^+}$ and $U_{s^\circ}$.  

We also have the usual rules for $1/\Sigma$ modes:
\begin{mathpar}
  \inferrule*{ }
             {\gamma \yields \mt : 1}
  \and 
  \mu \equiv \mt
\\
\inferrule*{
  \gamma \yields \mu : p \and
  \gamma \yields \nu : q[\mu/x]
    }
   {\gamma \yields (\mu,\nu) : \sigmacl{x}{p}{q}}
\and
\inferrule*
    {\gamma \yields \mu : \sigmacl{x}{p}{q}}
    {\gamma \yields \fst \mu : p}
\and
\inferrule*
    {\gamma \yields \mu : \sigmacl{x}{p}{q}}
    {\gamma \yields \snd \mu : q[\fst \mu / x]}
    \\
    \fst{(p,q)} \equiv p \and
    \snd{(p,q)} \equiv q \and
    p \equiv (\fst p, \snd p)
\end{mathpar}

Equations for ``transport'' in $\Sigma$:
\begin{mathpar}
\TrPlus{(\sigmacl{x}{s}{t})}{\mu} \equiv (\TrPlus{s}{\fst \mu},\TrPlus{(t[\fst \mu/x])}{\snd \mu})\\
\TrCirc{(\sigmacl{x}{s}{t})}{\mu} \equiv (\TrCirc{s}{\fst \mu},\TrCirc{(\ap{q}{\eta_{{\fst \mu}}/x};t[\TrCirc{s}{\fst \mu}/x])}{\snd \mu})
\end{mathpar}

\item Mode type morphisms:
\begin{mathpar}
    \inferrule*{ }
          {\TypeTwo{\gamma}{\id_p}{p}{p}}
    \qquad
    \inferrule*{{\TypeTwo{\gamma}{s_1}{p_1}{p_2}} \\
                {\TypeTwo{\gamma}{s_2}{p_2}{p_3}}
          }
          {\TypeTwo{\gamma}{s_1;s_2}{p_1}{p_3}}

\inferrule*{{\gamma,x:p} \vdash {q} \type \\
            \TermTwoT{\gamma}{t}{\mu}{\mu'}{p}\\
           } 
           {\TypeTwo{\gamma}{\ap {q} {t/x}}{q[\mu/x]}{q[\mu'/x]}}

\\
\id;s \equiv s \equiv s;\id \and
(s;s');s'' \equiv s;(s';s'') \\ 
\ap q {\id_{\mu}/x} \equiv \id_{q[\mu/x]} \and
\ap q {(s;t)/x} \equiv \ap q {s/x}; \ap q {t/x} \\ 
\ap q {s/\_} \equiv \id_q \\ 
\ap {(q[\mu/x])} {s/y} \equiv \ap q {\ap \mu {s/y}/x} \quad (\text{where } \gamma,y:p' \vdash \mu : p \text{ and } \gamma,x:p \vdash q \type)\\
s[\nu/x];\ap{q'}{t/x} \equiv \ap{q}{t/x};s[\nu'/x] \quad 
(\text{where } \TypeTwo{\gamma,x:p}{s}{q}{q'} \text{ and } \TermTwoT{\gamma}{t}{\nu}{\nu'}{p})

%% subst: \id_\mu[\nu/x] = \id_{\mu[\nu/x]}
%% subst: s[x/x] = s
%% subst: (s;t)[\mu/x] = s[\mu/x];t[\mu/x]
%% subst: s[\mu[\nu/x]/x] = s[\mu/x][\nu/x]
%% subst: ap q (s [\mu/x]) = (ap q s)[\mu/x] and generalization
\end{mathpar}

We write $\ap q {t/x}$ for whiskering (\dsd{ap} in book HoTT).

We need congruence for $\Sigma$ to be a rule (because we don't have ap
on a type variable/universes):
\begin{mathpar}
  \inferrule*
  {\TypeTwo{\gamma}{s}{p}{p'} \\
    \TypeTwo{\gamma,x':p'}{t}{q[\TrPlus{s}{x'}/x]}{q'}}
  {\TypeTwo{\gamma}{\sigmacl{x'}{t}{s}}{\sigmacl{x}{p}{q}}{\sigmacl{x'}{p'}{q'}}} \\

  \sigmacl{x'}{\id_p}{\id_q} \equiv \id_{\sigmacl{x'}{p}{q}} \and
  (\sigmacl{x'}{s}{t});(\sigmacl{x''}{s'}{t'}) \equiv \sigmacl{x''}{(s;s')}{(t[\TrPlus{s'}{x''}/x'];t')} \\

  \ap{(\sigmacl{x'}{p}{q})}{s/y:r} \equiv
  \sigmacl{x'}{\ap{p}{s/y}}{\ap{({q[\fst z/x,\snd z/y]})}{\extend{s}{x'}/z:(\sigmacl{y}{r}{p})}}
\end{mathpar}

\item 2-cells between terms.  First, we have
  identity/composition/whiskering and associated equations (whiskering
  on the other side is given by substitution):
\begin{mathpar}
    \inferrule*{ }
          {\TermTwoT{\gamma}{\id_\mu}{\mu}{\mu}{p}}
    \qquad
    \inferrule*{{\TermTwoT{\gamma}{s_1}{\mu_1}{\mu_2}{p}} \\
                {\TermTwoT{\gamma}{s_2}{\mu_2}{\mu_3}{p}}
          }
   {\TermTwoT{\gamma}{s_1;s_2}{\mu_1}{\mu_3}{p}}

\inferrule*{{\gamma,x:p} \yields {\nu} : {q} \\
            \TermTwoT{\gamma}{s}{\mu}{\mu'}{p}\\
           } 
           {\TermTwoT{\gamma}{\ap \nu {s/x}}{\nu[\mu/x]}{\TrPlus{\ap{q}{s/x}}{\nu[\mu'/x]}}{q[\mu/x]}}

\\           
\id;s \equiv s \equiv s;\id \and
(s;s');s'' \equiv s;(s';s'') \\ 
\ap \nu {\id_{\mu}/x} \equiv \id_{\nu[\mu/x]} \and
\ap \nu {(s;t)/x} \equiv \ap \nu {s/x} ; (\ap {(\TrPlus{\ap{q}{s/x}}{y})} {\ap \nu {t/x}/y}) \\ 
\ap x {s/x} \equiv s  \and
\ap \nu {s/\_} \equiv \id_\nu \and
\ap {(\nu[\mu/x])} {s/y} \equiv \ap \nu {\ap \mu {s/y}/x} \quad
(\text{where } \gamma,y:p' \vdash \mu : p \text{ and } \gamma,x:p \vdash \nu : q \type)\\
t[\mu/x];\ap{\nu'}{s/x} \equiv \ap{\nu}{s/x};\ap{(\TrPlus{\ap{q}{s/x}}{y})}{t[\mu'/x]/y} \quad
 (\text{where } \TermTwoT{\gamma,x:p}{t}{\nu}{\nu'}{q} \text{ and } \TermTwoT{\gamma}{s}{\mu}{\mu'}{p})
\end{mathpar}

\mvrnote{Should we write $t[s/x]$ as shorthand for either side of the last equation?}

Next, we have the adjunction for $s^\circ$ and $s^+$:
\begin{mathpar}
\inferrule*
    {\TypeTwo{\gamma}{s}{p}{q} \\
     \gamma \yields \nu : q
    }
    {\TermTwoT{\gamma}{\varepsilon^s_\nu}{\TrCirc{s}{\TrPlus{s}{\nu}}}{\nu}{q}}

\inferrule*
    {\TypeTwo{\gamma}{s}{p}{q} \\
      \gamma \yields \mu : p
    }
    {\TermTwoT{\gamma}{\eta^s_\mu}{\mu}{\TrPlus{s}{\TrCirc{s}{\mu}}}{p}}
\\ 
\eta_{\TrPlus{s}{\nu}};\ap{(\TrPlus{s}{z})}{\varepsilon_\nu/z} \equiv \id_{\TrPlus{s}{\nu}} \and
\ap{(\TrCirc{s}{z})}{\eta_\mu/z};\varepsilon_{\TrCirc{s}{\mu}} \equiv \id_{\TrCirc{s}{\mu}}
\\
\varepsilon_\nu;t \equiv \ap{\TrCirc{s}{\TrPlus{s}{z}}}{t/z} ; \varepsilon_{\nu'} \and t;\eta_\mu \equiv \eta_{\mu'} ; \ap{\TrPlus{s}{\TrCirc{s}{z}}}{t/z} \\
\varepsilon^{\id_p}_\nu \equiv \id_{\nu} \and \eta^{\id_p}_\mu \equiv \id_{\mu} \\
\varepsilon^{s;t}_\nu \equiv (\ap{t^\circ}{\varepsilon^s_{t^+(\nu)}}) ; \varepsilon^t_\nu \and 
\eta^{s;t}_\mu \equiv \eta^s_\mu ; (\ap{s^+}{\eta^t_{s^\circ(\mu)}})
\end{mathpar}
\mvrnote{similar functoriality for horizontal composition?}

\drlnote{equations for when $s$ is $\sigmacl{x}{t}{t'}$}.  

Finally, we have the 2-cells for $\Sigma$-modes:
\begin{mathpar}
\inferrule*
    {\TermTwoT{\gamma}{s}{\mu}{\mu'}{p} \and
      \gamma \vdash \nu' : q[\mu'/x]
    }
      {\TermTwoT{\gamma}{\extend{s}{\nu'}}{(\mu,\TrPlus{\ap{q}{s/x}}{\nu'})}{(\mu',\nu')}{\sigmacl{x}{p}{q}}}\\
\ap {\fst(z)} {\extend{s}{\nu'}/z} \equiv s \and
\ap {\snd(z)} {\extend{s}{\nu'}/z} \equiv \id_{\TrPlus{\ap{q}{s/x}}{\nu'}}  \\
s \equiv \ap{(\fst{\mu},y)}{\ap{(\snd z)}{s/z}/y};\extend{\ap{(\fst{z})}{s/z}}{\snd{\mu'}} \quad (\text{where } \TermTwoT{\gamma}{s}{\mu}{\mu'}{\sigmacl{x}{p}{q}})
\\      
{\extend{\id_\mu}{\nu'}} \equiv \id_{(\mu,\nu')} \and
{\extend{(s;s')}{\nu''}} \equiv  \extend{s}{\TrPlus{\ap{q}{s'/x}}{\nu''}};\extend{s'}{\nu''}   \\
\extend{s}{\nu'} ; (\ap{(\mu',y)}{t/y}) \equiv
(\ap{(\mu,\TrPlus{(\ap{q}{s})}{y})}{t/y}); \extend{s}{\nu''} \qquad (\text{where }\TermTwoT{\gamma}{t}{\nu'}{\nu''}{q[\mu'/x]})
\end{mathpar}

\item
  All judgements have a substituton principle
\begin{mathpar}
  \inferrule*{\gamma,x:p,\gamma' \yields J \\
              \gamma \yields \mu : p
              }
             {\gamma,\gamma'[\mu/x] \yields J[\mu/x]}

J[\mu/x][\nu/y] \equiv J[\nu/y][\mu[\nu/y]/x]
\end{mathpar}

\drlnote{write out the usual rules defining this}
             
\end{enumerate}

We sometimes write \ap{\mu}{s} for \ap{\mu(x)}{s/x}, eliding the
variable name when it is clear how to view $\mu$ as a term with a
distinguished variable; e.g. $\ap{s^+}{t}$ for
$\ap{\TrPlus{s}{x}}{t/x}$.

\subsubsection{Lemmas}

Pairing and projection 2-cells are definable:
\begin{mathpar}
  \inferrule*[Left=Derivable]
      {\TermTwoT{\gamma}{s}{\mu}{\mu'}{p} \\
    \TermTwoT{\gamma}{t}{\nu}{\TrPlus{\ap{q}{s}}{\nu'}}{q[\mu/x]}}
             {\TermTwoT{\gamma}{(s,t) :\equiv \ap{(\mu,y)}{t/y};\extend{s}{\nu'}}{(\mu,\nu)}{(\mu',\nu')}{\sigmacl{x}{p}{q}}}

   \inferrule*[Left=Deriv]
              { {\TermTwoT{\gamma}{s}{\mu}{\mu'}{\sigmacl{x}{p}{q}}} }
              { {\TermTwoT{\gamma}{\ap{\fst(y)}{s/y}}{\fst{\mu}}{\fst{\mu'}}{p}} }
   \and
   \inferrule*[Left=Deriv]
              { {\TermTwoT{\gamma}{s}{\mu}{\mu'}{\sigmacl{x}{p}{q}}} }
              { {\TermTwoT{\gamma}{\ap{\snd(y)}{s/y}}{\snd{\mu}}{\TrPlus{\ap{(q(\fst y/x))}{s/y}}{\snd{\mu'}}}{q[\fst{\mu}/x]}} }
\end{mathpar}

\drlnote{Check usual composition rule for pairing}


\subsection{Contexts}

\begin{mathpar}
  \inferrule*[Left = ctx-form]{ }
  {\yields_{\cdot} \cdot \CTX  } \and 

  \inferrule*[Left = ctx-form]{
    \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx) \\\\
    \Gamma \yields_p A \TYPE \and (\text{where }  \gamma \yields p \type)}
  {\yields_{\gamma, x : p} \Gamma, x : A \CTX \and (\text{where } \yields \gamma,x:p \ctx)  } \\
\end{mathpar}

\subsection{Types and Terms}

\subsubsection{Structural Rules}

\begin{mathpar}
  \inferrule*[Left = var]{
    % \yields \Gamma, x : A, \Gamma' \CTX_{\gamma, x : p, \gamma'}
  }
  {\Gamma, x : A, \Gamma' \yields_x x : A \and (\text{where } \gamma,x:p,\gamma' \yields x : p)} \and

 \inferrule*[Left = 2cell]{
   \Gamma \yields_\mu M : A 
   \and \TermTwoT{\gamma}{s}{\nu}{\mu}{p}
  }
  {\Gamma \yields_\nu \rewrite{s}{M} : A} \\ \\
  
  \rewrite{\id_\mu}{M} \equiv M \and
  \rewrite{(s;t)}{M} \equiv \rewrite{s}{\rewrite{t}{M}} \and
  \rewrite{s}{M}[\rewrite{t}{N}/x] \equiv \rewrite{s[t/x]}{M[N/x]}
\end{mathpar}

\mvrnote{show that the above equations imply that the 2-cell rule pushes into terms}


\subsubsection{Telescope Types}

\begin{mathpar}

  \inferrule*{ \Gamma \yields_p A \TYPE \\
               \Gamma,x:A \yields_q B \TYPE}
             { \Gamma \yields_{\sigmacl{x}{p}{q}} \telety{x}{A}{B} \TYPE}
  \and 
  \inferrule*{ \Gamma \yields_\mu M : A \\
               \Gamma \yields_\nu N : B[M/x]
             }
             { \Gamma \yields_{(\mu,\nu)} (M,N) : \telety{x}{A}{B}}
  \and
  \inferrule*{ \Gamma \yields_{\mu} M : \telety{x}{A}{B}}
             { \Gamma \yields_{\fst \mu} \fst{M} : A} 
  \and
  \inferrule*{ \Gamma \yields_{\mu} M : \telety{x}{A}{B}}
             { \Gamma \yields_{\snd \mu} \snd{M} : B[\fst M/x]} 

    \fst{(p,q)} \equiv p \and
    \snd{(p,q)} \equiv q \and
    p \equiv (\fst p, \snd p)
\end{mathpar}

\subsubsection{Modalities}

\begin{mathpar}
  \inferrule*[Left = F-form]{
    %% \yields_\gamma \Gamma \CTX \and (\text{where } \yields \gamma \ctx)\\\\
    \Gamma \yields_p A \TYPE \and (\text{where } \gamma \yields p \type) \\\\
    \gamma, x:p \yields \mu : q 
  }
  {\Gamma \yields_q \F{x.\mu}{A} \TYPE \and (\text{where } \gamma \yields q \type) } \\
  
  \inferrule*[Left = F-intro]{
    \Gamma \yields_{\nu} M : A
    \and (\text{where } \gamma \yields {\nu} : p)
    %% \and \gamma \yields \nu : q 
    %% \and \gamma \yields \mu[\theta] : q 
    %% \and \gamma \yields (\nu \Rightarrow \mu[\theta]) : q
  }
  {\Gamma \yields_{\mu[\nu/x]} \FI{M} : \F{x.\mu}{A} \and (\text{where } \gamma \yields \mu[\nu/x] : q)} \\

  \inferrule*[Left = F-elim]{
    \Gamma, y : \F{x.\mu}{A} \yields_{r} C \TYPE \and (\text{where } \gamma, y : q \yields r \type) \\\\
    \Gamma \yields_{\nu} M : \F{x.\mu}{A} \and (\text{where } \gamma \yields \nu : q) \\\\
    \Gamma, x:A \yields_{\nu' [\mu / y]} N : C [\FI{x}/y]
    \and (\text{where } \gamma, x:p \yields \nu' [\mu / y] : r [\mu / y] )}
  {\Gamma \yields_{\nu'[\nu/y]} \FE{M}{x}{N} : C[M/y]  \and (\text{where }  \gamma \yields {\nu'[\nu/y]} : r[\nu/y])} \\
  \FE{\FI{M}}{x}{N} \equiv M[N/x]

  \\ \\

  \inferrule*[Left = F-Elim]{
    \gamma,y:q \yields r \type \\\\
    \Gamma \yields_{\nu} M : \F{x.\mu}{A} \and (\text{where } \gamma \yields \nu : q) \\\\
    \Gamma, x:A \yields_{r [\mu / y]} C \TYPE
    \and (\text{where } \gamma, x:p \yields r [\mu / y] \type )}
  {\Gamma \yields_{r[\nu/y]} \FE{M}{x}{C} \TYPE \and (\text{where }  \gamma \yields {r[\nu/y]} \type)} \\
  \FE{\FI{M}}{x}{C} \equiv C[N/x]

  \\ \\

  \inferrule*[Left = U-form]{
    \Gamma \yields_p A \TYPE \and (\text{where } \gamma \yields p \type)\\\\
    \and \Gamma,x:A \yields_q B \TYPE \and (\text{where } \gamma,x:p \yields q \type)\\\\
    \and \gamma, x:p, c:r \yields \mu : q
  }{\Gamma \yields_r \U{c.\mu}{A}{B} \TYPE \and (\text{where } \gamma \yields r \type)} \\

  \inferrule*[Left = U-intro]{
    \Gamma,x:A \yields_{\mu[\nu/c]} M : B \and (\text{where } \gamma,x:p \yields {\mu[\nu/c]} : q)
  }
  {\Gamma \yields_{\nu} \UI {x}{M} : \U{c.\mu}{x:A}{B}
    \and (\text{where } \gamma \yields \nu : r)
  } \\
  
  \inferrule*[Left = U-elim]{
    \Gamma \yields_{\nu_1} N_1 : \U{c.\mu}{x:A}{B} \and (\text{where } \gamma \yields \nu_1 : r) \\\\
    \Gamma \yields_{\nu_2} N_2 : A \and (\text{where } \gamma \yields \nu_2 : p)
  }{
    \Gamma \yields_{\mu[\nu_2/x,\nu_1/c]} \UE{N_1}{N_2} : B \and (\text{where } \gamma \yields \mu[\nu_2/x,\nu_1/c] : q)
  } \\

  \UE{\UI{x}{M}}{N} \equiv M[N/x] \and 
  \UI{x}{\UE{N}{x}} \equiv N
\end{mathpar}

\subsubsection{Surprisingly Strict Modalities}

\begin{mathpar}
  \inferrule*[Left = s-form]{
    \Gamma \yields_p A \TYPE \and (\text{where } \gamma \yields p \type)\\\\
    \and \TypeTwo{\gamma}{s}{q}{p}
  }{\Gamma \yields_q \St{s}{A} \TYPE \and (\text{where } \gamma \yields q \type)} \\

  \inferrule*[Left = S-intro]{
    \Gamma \yields_{\mu} M : A
    \and (\text{where } \gamma \yields {\mu} : p)
  }
  {\Gamma \yields_{\TrPlus{s}{\mu}} \StI{s}{M} : \St{s}{A} \and (\text{where } \gamma \yields \TrPlus{s}{\mu} : q)} \\

  \inferrule*[Left = S-elim]{
    \Gamma, y : \St{s}{A} \yields_{r} C \TYPE \and (\text{where } \gamma, y : q \yields r \type) \and \\\\
    \Gamma \yields_{\nu} M : \St{s}{A} \and (\text{where } \gamma \yields \nu : q) \\\\
    \Gamma, x : A \yields_{\nu' [\TrPlus{s}{x} / y]} N : C [\StI{s}{x}/y]
    \and (\text{where } \gamma, x : p \yields \nu' [\TrPlus{s}{x} / y] : p [\TrPlus{s}{x} / y] )}
  {\Gamma \yields_{\nu'[\nu/y]} \StE{M}{x}{N} : C[M/y]  \and (\text{where } \gamma \yields {\nu'[\nu/y]} : p[\nu/y])} \\
  \StE{\StI{s}{M}}{x}{N} \equiv M[N/x]
  \\
  
  \inferrule*[Left = S-Elim]{
    \gamma,y:q \yields r \type \\\\
    \Gamma \yields_{\nu} M : \St{s}{A} \and (\text{where } \gamma \yields \nu : q) \\\\
    \Gamma, x:A \yields_{r [\TrPlus{s}{x} / y]} C \TYPE
    \and (\text{where } \gamma, x:p \yields r [\TrPlus{s}{x} / y] \type )}
  {\Gamma \yields_{r[\nu/y]} \StE{M}{x}{C} \TYPE \and (\text{where }  \gamma \yields {r[\nu/y]} \type)} \\
  \StE{\StI{s}{M}}{x}{C} \equiv C[N/x]

  \\ \\
\end{mathpar}

Type equalities:
\begin{align*}
\St{s}{\F{x.\mu}{A}} &\equiv \F{x.\TrPlus{s}{\mu}}{A} \\
\F{x.\mu}{\St{s}{A}} &\equiv \F{x.\mu[\TrPlus{s}{x}/x]}{A} \\
\St{s}{\U{c.\mu}{x:A}{B}} &\equiv \U{c.\mu[\TrCirc{s}{c}/c]}{x:A}{B} \\
\U{c.\mu}{x:A}{\St{s}{B}} &\equiv \U{c.\TrCirc{s}{\mu}}{x:A}{B} \\
\U{c.\mu}{x:\St{s}{A}}{B} &\equiv \U{c.\mu[\TrPlus{s}{x}/x]}{x:A}{B[\StI{s}{x}/x]} \\
\St{(\telety{x'}{s}{t})}{\telety{x'}{A'}{B'}} & \equiv \telety{x}{\St{s}{A'}}{\StE{x}{x'}{\St{t}{B'}}} \\
\St{s}{\St{t}{A}} &\equiv \St{(s;t)}{A} \\
\St{\id_p}{A} &\equiv A\\
\St{(\ap{q}{t/x})}{B[M/x]} & \equiv B[\St{t}{M}/x] \quad (\text{where }
\Gamma,x:A \vdash_q B \TYPE \text{ and } \Gamma \vdash_{\mu'} M : A \text{ and }
\TermTwo{\gamma}{s}{\mu}{\mu'})
%% other whiskering is a substitution rule:
%% \St{(s[\mu/x])}{B[M/x]} & \equiv (\St{s}{B})[M/x] 
\end{align*}
\drlnote{We should also have term definitional equalities over these.}
%% (like
%% $\StI{\id_p}{M} \equiv M$, $\StE{M}{\id_p}{x}{x} \equiv M$).

\subsection{Lemmas}

%\begin{lemma}[Substitution over substitution]
%\begin{mathpar}
%  \inferrule*{\Gamma, x : A, \Gamma' \yields_\nu \judge \\
%              \Gamma \yields_\mu M : A
%              }
%             {\Gamma,\Gamma'[M/x] \yields_{\nu[\mu/x]} \judge[M/x]} \\
% \judge[\mu/x][\nu/y] \equiv \judge[\nu/y][\mu[\nu/y]/x]
%\end{mathpar}
%\end{lemma}
%\begin{proof}
%
%\end{proof}

\begin{lemma}
The $\mathsf{U}$-style rules for $s$-types are derivable:
\begin{mathpar}
\inferrule*[Left = s-intro-2]{
    \Gamma \yields_{\TrCirc{s}{\mu}} M : B
  }
  {\Gamma \yields_{\mu} \UStI{s}{M} : \St{s}{B}
  } \and
  
  \inferrule*[Left = s-elim-2]{
    \Gamma \yields_{\mu} N : \St{s}{B}
  }{
    \Gamma \yields_{\TrCirc{s}{\mu}} \UnSt{s}{N} : B
  } 
\end{mathpar}
\end{lemma}
\begin{proof}
For the first:
\begin{mathpar}
\inferrule*[Left = 2cell]{
\inferrule*[Left = s-intro]{
    \Gamma \yields_{\TrCirc{s}{\mu}} M : A
  }
  {\Gamma \yields_{\TrPlus{s}{\TrCirc{s}{\mu}}} \StI{s}{M} : \St{s}{A}}}
  {
    {\Gamma \yields_{\mu} \UStI{s}{M} :\equiv \rewrite{\eta^s_\mu}{\StI{s}{M}} : \St{s}{A}}}
\end{mathpar}
And the second:
\begin{mathpar}
\inferrule*[Left = s-elim]{
\Gamma \yields_{\mu} N : \St{s}{B} 
\and
\inferrule*[left = 2cell]{
     \Gamma, x : B \yields_x x : B
  }{
    \Gamma, x : B \yields_{\TrCirc{s}{\TrPlus{s}{x}}} \rewrite{\varepsilon^s_x}{x} : B
  }
  }
  {
    \Gamma \yields_{\TrCirc{s}{\mu}} \UnSt{s}{N} :\equiv \StE{N}{x}{\rewrite{\varepsilon^s_x}{x}} : B
  }
\end{mathpar}
\end{proof}

\subsection{Examples}

\begin{itemize}
\item 
The previous two-argument \F{\mu}{x:A,y:B} (for $x :p, y:q \vdash \mu :
r$) is now \F{z.\mu[\fst z/x,\snd z/y]}{\telety{x}{A}{B}}, using the
upstairs $\Sigma$-type ${\telety{x}{A}{B}}$, which has mode
$\sigmacl{x}{p}{q}$.  Iterating $\telety{x}{A}{B}$ plays the role of a
longer telescope.  
\end{itemize}

\section{Mode Theories}

\subsection{First-order Logic}

The mode theory for first-order logic consists of:
\begin{itemize}
\item a mode $(\ii,\times,\top)$ with a cartesian product; write
  $\pi^\alpha_x : \alpha \times x \Yields \alpha$.  $\pi$ should be
  natural in the sense that for $s : \beta \Yields \alpha$,
  $\pi^\beta_x;s \equiv (s \times \id_x);\pi^\alpha_x$.  
\item a dependent mode $\alpha : \ii \yields \PP{\alpha} \type$
\item whatever structure you want in each fiber, e.g. for each $\alpha$
  a cartesian product
  \begin{mathpar}
   \alpha : \ii \vdash \top^1 : \PP{\alpha} \and 
   \alpha : \ii, x : \PP{\alpha}, y : \PP{\alpha} \vdash x \times^1 y : \PP{\alpha}
  \end{mathpar}
\item then the idea is that $\TrCirc{\ApP{\pi^\alpha_x}}{-} \dashv
  \TrPlus{\ApP{\pi^\alpha_x}}{-}$ gives an adjunction in the mode
  theory, which we know gives a triple adjunction upstairs, which will be
  $\exists \dashv \pi \dashv \forall$.  So 
  $\exists$ is the $F$-type for 
  \begin{mathpar}
    \alpha : \ii, x : \ii, y : \PP{\alpha \times x} \vdash \TrCirc{\ApP{\pi^\alpha_x}}{y} : \PP{\alpha}
  \end{mathpar}
  and $\forall$ is the $U$ type for 
  \begin{mathpar}
    \alpha : \ii, x : \ii, y : \PP{\alpha} \vdash \TrPlus{\ApP{\pi^\alpha_x}}{y} : \PP{\alpha \times x}
  \end{mathpar}

  Momentarily write $\exists^\alpha_x(y)$ for
  $\TrCirc{\ApP{\pi^\alpha_x}}{y}$
  and $y[\pi^\alpha_x]$ for $\TrPlus{\ApP{\pi^\alpha_x}}{y}$, and more
  generally, for $s : \beta \yields \alpha$, write $\exists_s y$ for
  $\TrCirc{\ApP{s}}{y}$
  and $y[s]$ for
  $\TrPlus{\ApP{s}}{y}$.  This is probably a bad pun in general but it
  helps to see these in a more familiar notation: the unit and counit
  are
  \begin{mathpar}
    y \Yields_{(\alpha \times x)} (\exists^\alpha_x y)[\pi^\alpha_x]
    \and
    (\exists^\alpha_x (y[\pi^\alpha_x])) \Yields_{(\alpha)} y 
  \end{mathpar}

\item Suppose we have $\alpha,\beta : \ii, x : \ii$, $s : \beta \Yields
  \alpha$.  There are four possible ``interactions'' that we could have
  equations for.  
  \begin{mathpar}
    y : \PP{\alpha \times x} \vdash (\exists^\alpha_x y)[s] \equiv \exists^\beta_x (y[s \times \id])\\
    y : \PP{\beta \times x} \vdash \exists_s (\exists^\beta_x y) \equiv \exists^\alpha_x (\exists_{s \times \id}(y))\\
    y : \PP{\alpha} \vdash y[\pi^\alpha_x][s \times \id] \equiv y[s][\pi^\beta_x]\\
    y : \PP{\beta} \vdash \exists_{s \times \id}(y[\pi^\alpha_x]) \equiv (\exists_s {y})[\pi^\alpha_x]
  \end{mathpar}
  The second and third follow from naturality of $\pi$ and the fusion
  laws for $\TrCirc{s}{\TrCirc{t}{\mu}}$ and
  $\TrPlus{s}{\TrPlus{t}{\mu}}$.
  The first and fourth are what we need to assert for the upstairs
  $\exists$ and $\forall$ to be ``stable under structural rules''.

\item Given the above equations, for the unit and counit of
  $\pi^\alpha_x$, it type checks to equate
  \begin{mathpar}
   y : \PP{\alpha \times x} \vdash \eta_y[s \times \id] \equiv \eta_{y[s \times \id]}: y[s \times \id] \Yields_{(\beta \times x)} (\exists^\alpha_x y)[\pi^\alpha_x][s \times \id]
  \equiv (\exists^\beta_x (y[s \times \id]))[\pi^\beta_x]\\
  
  y : \PP{\alpha} \vdash \epsilon_y[s] \equiv \epsilon_{y[s]} : (\exists^\alpha_x (y[\pi^\alpha_x]))[s]
  \equiv \exists^\beta_x (y[\pi^\alpha_x][s \times \id]) \equiv \exists^\beta_x (y[s][\pi^\beta_x])  \Yields_{(\beta)} y[s]

  y : \PP{\beta \times x} \vdash \exists_{[s \times \id]}{\eta_y} \equiv
  \eta_{\exists_{s \times \id} y}
  :
  \exists_{s \times \id}(y) \Yields_{(\alpha \times x)} \exists_{s \times \id} (\exists^\alpha_x y)[\pi^\alpha_x]
  \equiv
  (\exists_{s} (\exists^\alpha_x y))[\pi^\beta_x]
  \equiv
  (\exists^\beta_x(\exists_{s \times \id}(y)))[\pi^\beta_x]\\
  
  y : \PP{\beta} \vdash \exists_s{\epsilon_y} \equiv \epsilon_{\exists_s(y)} : 
  \exists_{s}{(\exists^\beta_x (y[\pi^\beta_x]))} \equiv \exists^\alpha_x{\exists_{s \times \id} (y[\pi^\beta_x])} \equiv \exists^\alpha_x((\exists_{s}(y))[\pi^\alpha_x]) \Yields_{(\alpha)} \exists_{s}{y} 
  \end{mathpar}
  
  %% \and
  %%   (\exists^\alpha_x (y[\pi^\alpha_x])) \vdash_{(\alpha)} y 
\item \msnote{Presumably if $\delta_x : x \Yields x\times x $ is the cartesian diagonal, then the $F$-type for $\TrCirc{\ApP{\delta_x}}{-}$ is Lawvere equality?}
\end{itemize}

\subsection{Linear Logic with Cartesian First-order Quantifiers}

As above, except have a symmetric monoidal product $(\otimes^1,1^1)$ in
each fiber instead of a cartesian product.  

\subsection{Morphisms of Bifibrations}

Any dependent type $x : p \vdash S(x) \type$ is a bifibration in the
sense that for $s : \beta \Yields_p \alpha$ we have both $\ap{S}{s/x}^+
: S[\alpha/x] \to S[\beta/x]$ and $\ap{S}{s/x}^\circ : S[\beta/x] \to
S[\alpha/x]$.

\begin{definition}
Suppose (in any context $\gamma$) a type, with two dependent types
over it:
\begin{mathpar}
p \type \and x : p \vdash S(x) \type \and x : p \vdash T(x) \type 
\end{mathpar}
A \emph{morphism of bifibrations} from $S$ to $T$ consists of a term
\begin{mathpar}
x : p, z:S(x) \vdash f_1(x,z) : T(x)
\end{mathpar}
satisfying the following equations for any $\alpha : p$, $s
: \beta \Yields_p \alpha$, $\mu : S[\alpha/x]$, $\nu : S[\beta/x]$:
\begin{align}
\label{mor-fib-subst}
f_1(\beta,\TrPlus{\ap{S}{s/x}}{\mu}) \equiv_{T(\beta)} \TrPlus{\ap{T}{s/x}}{f_1(\alpha,\mu)}\\
\label{mor-opfib-subst}
f_1(\alpha,\TrCirc{\ap{S}{s/x}}{\nu}) \equiv_{T(\alpha)} \TrCirc{\ap{T}{s/x}}{f_1(\beta,\nu)}
\end{align}
A morphism of bifibrations is \emph{strict} \mvrnote{(??)} if additionally:
\begin{align}
\label{mor-fib-unit}
\ap{f_1(\beta,z)}{\eta^{\ap{S}{s/x}}_\nu/z} \equiv \eta^{{\ap{T}{s/x}}}_{f_1(\beta,\nu)} \\
\label{mor-fib-counit}
\ap{f_1(\alpha,z)}{\varepsilon^{\ap{S}{s/x}}_\mu/z} \equiv
\varepsilon^{{\ap{T}{s/x}}}_{f_1(\alpha,\mu)}
\end{align}
\end{definition}

The first equation says that $f_1$ is a ``morphism of fibrations'', in
the sense that it commutes with ``substitution'', in the sense of the
contravariant action of a mode type morphism.  The second says that it
is a ``morphism of opfibrations''.  The third and fourth say that $f_1$
preserves the unit and counit of the $s^\circ \dashv s^+$ adjunctions.
\drlnote{This is part of morphism of bifibrations because...}
To type check \eqref{mor-fib-unit}, we have
\begin{mathpar}
\eta^{\ap{S}{s/x}}_\nu : \nu \Yields_{S[\beta/x]} \TrPlus{\ap{S}{s/x}}{\TrCirc{\ap{S}{s/x}}{\nu}}\\
\ap{f_1(\beta,z)}{\eta^{\ap{S}{s/x}}_\nu/z} : f_1(\beta,\nu) \Yields_{S[\beta/x]} f_1(\beta,\TrPlus{\ap{S}{s/x}}{\TrCirc{\ap{S}{s/x}}{\nu}})
\end{mathpar}
But
\begin{align*}
  f_1(\beta,\TrPlus{\ap{S}{s/x}}{\TrCirc{\ap{S}{s/x}}{\nu}})
  & \equiv
\TrPlus{\ap{T}{s/x}}{f_1(\alpha,{\TrCirc{\ap{S}{s/x}}{\nu}})} \\
& \equiv
\TrPlus{\ap{T}{s/x}}{\TrCirc{\ap{T}{s/x}}{f_1(\beta,\nu)}}
\end{align*}

To type check \eqref{mor-fib-counit}, we have
\begin{mathpar}
\varepsilon^{\ap{S}{s/x}}_\mu : \TrCirc{\ap{S}{s/x}}{\TrPlus{\ap{S}{s/x}}{\mu}} \Yields_{S[\alpha/x]} \mu\\
\ap{f_1(\alpha,z)}{\varepsilon^{\ap{S}{s/x}}_\mu/z} : f_1(\alpha,\TrCirc{\ap{S}{s/x}}{\TrPlus{\ap{S}{s/x}}{\mu}}) \Yields_{S[\alpha/x]} f_1(\alpha,\mu)\\
f_1(\alpha,\TrCirc{\ap{S}{s/x}}{\TrPlus{\ap{S}{s/x}}{\mu}})
\equiv
\TrCirc{\ap{T}{s/x}}{\TrPlus{\ap{T}{s/x}}{f_1(\alpha,\mu)}}
\end{mathpar}

%% Often, it will be the case that $f_1(x,z) := \TrCirc{t}{z}$ for some mode
%% type morphism $\TypeTwo{x : p}{t}{S}{T[f_0(x)/y]}$.  In this case, equation
%% \eqref{mor-opfib-subst} is automatic by fusion and naturality:
%% \begin{mathpar}
%% \TrCirc{t[\alpha/x]}{\TrCirc{\ap{S}{s/x}}{\nu}} \equiv \TrCirc{\ap{T[f_0(x)/y]}{s/x}}{\TrCirc{t[\beta/x]}{\nu}}\\
%% \end{mathpar}
%% In such circumstances, asserting that $(f_0,f_1)$ is a morphism of
%% bifibrations from $(p,S)$ to $(q,T)$ means asserting equations
%% \eqref{mor-fib-subst} \eqref{mor-fib-unit} \eqref{mor-fib-counit}.

\subsection{Terminal Objects}

\begin{definition}
For a mode $x : p$, a terminal object is specified by
\begin{mathpar}
\vdash \emptyset : p \and
\TermTwoT{x : p}{!_x}{x}{\emptyset}{p}
\end{mathpar}
such that $t \equiv \bang_x$ for all $\TermTwoT{\gamma}{t}{\mu}{\emptyset}{p}$.
\end{definition}

\begin{definition}
For a dependent mode $x : p \vdash S(x) \type$, a \emph{fibred terminal object} term is specified by:
\begin{mathpar}
x : p \vdash 1_x : S(x) \and
\TermTwoT{x : p, \mu : S(x)}{!_\mu}{\mu}{1_x}{S(x)}
\end{mathpar}
such that
\begin{align}
\label{bang-unique}
t & \equiv \bang_\mu && \text{where } \TermTwoT{\gamma}{t}{\mu}{1_\alpha}{S(\alpha)}\\
\label{s-plus-one-strict}
\TrPlus{\ap{S}{s}}{1_\alpha} &\equiv 1_\beta && \text{where } \TermTwoT{\gamma}{s}{\beta}{\alpha}{p}
\end{align}
\end{definition}

\subsection{Comprehension Object (from a mode type morphism)}

\begin{definition}[Comprehension Object]
  A \emph{comprehension object} is specified by the following
  constants:
  \begin{mathpar}
    p \type 
%    \emptyset : p %\and
%    \TermTwoT{\alpha : p}{\bang_p}{\alpha}{\emptyset}{p}
    \\
    \alpha : p \yields \El{p}{\alpha} \type \and
    \TypeTwo{\cdot}{\chi}{p}{\sigmacl{\alpha}{p}{\El{p}{\alpha}}}
    \\
    \TermTwoT{\alpha : p, \mu : \El{p}{\alpha}}{!_\mu}{\mu}{1_\alpha}{\El{p}{\alpha}}
  \end{mathpar}
  such that (where $\gamma \yields \alpha : p$ and $\gamma \yields \beta : p$ and  $\TermTwoT{\gamma}{s}{\beta}{\alpha}{p}$ and $\gamma \yields \mu : \alpha$ and $\gamma \yields \nu : \beta$)
\begin{align}
\label{empty-terminal} 
p &\text{ has a terminal object} \\
\label{chi-section}
\fst{\TrCirc{\chi}{\alpha}} &\equiv \alpha \\
\label{one-terminal} 
(1_\alpha, !_\mu) &\text{ is a fibred terminal object of } \El{p}{\alpha} 
\end{align}
  
\noindent We use the following derived forms:
  \begin{itemize}
  \item Comprehension is given by $\chi^+$:
  \begin{mathpar}
  \alpha : p, x : \El{p}{\alpha} \yields \alpha.x : p \and \alpha.x :\equiv \TrPlus{\chi}{(\alpha, x)}
  \end{mathpar}
%  \item Pairing for the comprehension object is given by ap of
%  $.$ on the pairing for $\Sigma$-modes:
%  \begin{mathpar}
%  \inferrule{\TermTwoT{\gamma}{s}{\alpha}{\beta}{p} \and
%             %% \and \gamma \yields \mu : \alpha \and \gamma \yields \nu : \beta \and
%             \TermTwoT{\gamma}{m}{\mu}{\ApEl{p}{s}^+(\nu)}{\El{p}{\alpha}}}
%            {\TermTwoT{\gamma}{s \bdot m}{\alpha.\mu}{\beta.\nu}{p}} \and
%  s \bdot m :\equiv \ap{(\fst z \bdot \snd z)}{(s,t)/ (z:\sigmacl{\alpha}{p}{\El{p}{\alpha}})}
%  \end{mathpar}
  \item The terminal object of $\El{p}{\alpha}$ is given by 
  \begin{mathpar}
  \alpha : p \yields 1_\alpha : \El{p}{\alpha} \and 1_\alpha :\equiv \snd{\TrCirc{\chi}{\alpha}}
  \end{mathpar}
  This is well typed, as $\El{p}{\fst{\TrCirc{\chi}{\alpha}}} \equiv \El{p}{\alpha}$ by equation \eqref{chi-section}.
  \item $\pi^\alpha_\mu$ and $\var{\mu}$ are defined via the counit of the adjunction $\chi^\circ \dashv \chi^+$.
  \begin{mathpar}
  {\TermTwoT{\alpha:p,x:\El{p}{\alpha}}{\pi^\alpha_x}{\alpha.x}{\alpha}{p}}
  \and
  \pi^\alpha_x :\equiv \ap \fst {\varepsilon^\chi_{(\alpha, x)}} \\
  {\TermTwoT{\alpha:p,x:\El{p}{\alpha}}{\var{x}}{1_{\alpha.x}}{\ApEl{p}{\pi^\alpha_x}^+(x)}{\El{p}{\alpha.x}}} 
    \and
    \mathsf{var}_x :\equiv \ap \snd {\varepsilon^\chi_{(\alpha, x)}}
  \end{mathpar}
  \item Pairing for the comprehension object is given by ap of
  $.$ on the pairing for $\Sigma$-modes:
  \begin{mathpar}
  \inferrule{\TermTwoT{\gamma}{s}{\alpha}{\beta}{p} \and
             %% \and \gamma \yields \mu : \alpha \and \gamma \yields \nu : \beta \and
             \TermTwoT{\gamma}{m}{\mu}{\ApEl{p}{s}^+(\nu)}{\El{p}{\alpha}}}
            {\TermTwoT{\gamma}{s \bdot m}{\alpha.\mu}{\beta.\nu}{p}} \and
  s \bdot m :\equiv \ap{\chi^+}{(s, m)}
  \end{mathpar}
  \end{itemize}
\end{definition}

\noindent The triangle equalities for $\chi^\circ \dashv \chi^+$ take the following form:
\begin{align*}
%\eta_{\TrPlus{\chi}{(\alpha, x)}};\ap{(\TrPlus{\chi}{z})}{\varepsilon_{(\alpha, x)}/z} \equiv \id_{\TrPlus{\chi}{(\alpha, x)}} 
\eta_{\alpha.x};(\pi_x^\alpha \bdot \var{x}) &\equiv \id_{\alpha.x} \\
%\ap{(\TrCirc{\chi}{z})}{\eta_\alpha/z};\varepsilon_{\TrCirc{\chi}{\alpha}} \equiv \id_{\TrCirc{\chi}{\alpha}}
(\eta_\alpha ; \pi^\alpha_{1_\alpha}, \ap{1_z}{\eta_\alpha/z} ; \ap{\ApEl{p}{\eta_\alpha}^+}{\var{1_\alpha}}) &\equiv \id_{(\alpha, 1_\alpha)}
\end{align*}
because $1_\alpha$ is terminal, only the first component of the latter equation has content, it says that $\eta_\alpha ; \pi^\alpha_{1_\alpha} = \id_\alpha$.

%The second triangle equation is
%\begin{mathpar}
%\ap{(\TrCirc{\chi}{z})}{\eta_\alpha/z};\varepsilon_{\TrCirc{\chi}{\alpha}} \equiv \id_{\TrCirc{\chi}{\alpha}}
%\end{mathpar}
%On the left this is:
%\begin{align*}
%\ap{(\TrCirc{\chi}{z})}{\eta_\alpha/z};\varepsilon_{\TrCirc{\chi}{\alpha}}
%&\equiv \ap{(z, 1_z)}{\eta_\alpha/z};\varepsilon_{(\alpha, 1_\alpha)} \\
%&\equiv (\eta_\alpha, \ap{1_z}{\eta_\alpha/z});(\pi^\alpha_{1_\alpha}, \var{1_\alpha}) \\
%&\equiv (\eta_\alpha ; \pi^\alpha_{1_\alpha}, \ap{1_z}{\eta_\alpha/z} ; \ap{\ApEl{p}{\eta_\alpha}^+}{\var{1_\alpha}})
%\end{align*}
%So componentwise the triangle equation says
%\begin{align*}
%\eta_\alpha ; \pi_{1_\alpha}^\alpha &\equiv \id_\alpha \\
%\ap{1_z}{\eta_\alpha/z} ; \ap{\ApEl{p}{\eta_\alpha}^+}{\var{1_\alpha}} &\equiv \id_{1_\alpha}
%\end{align*}

Some other derivable equations:
\begin{itemize}
\item Fusion for $.$
\begin{align}
\label{dot-fusion}
    (s \bdot m);(s' \bdot m') \equiv ((s;s') \bdot (m;\ap {\ApEl{p}{s}^+} {m'}))
\end{align}
follows by fusing the ap's and the corresponding fusion rule for morphisms in $\Sigma$ modes:
\begin{align*}
(s \bdot m);(s' \bdot m') &\equiv \ap{\chi^+}{(s, m)} ; \ap{\chi^+}{(s', m')} \\
&\equiv \ap{\chi^+}{(s, m);(s', m')} \\
&\equiv ((s;s') \bdot (m;\ap {\ApEl{p}{s}^+} {m'}))
\end{align*}

\item $\pi^\alpha_\mu$ is natural in $\mu$:
  \begin{align}
  \label{pi-naturality}
  (s \bdot m); \pi^\alpha_\mu &\equiv \pi^\beta_\nu;s && \text{where } \TermTwoT{\gamma}{m}{\mu}{\ApEl{p}{s}^+(\nu)}{\El{p}{\alpha}}
  \end{align}
  by
  \begin{align*}
  (s \bdot m); \pi^\alpha_\mu 
  &\equiv \ap{\chi^+}{(s, m)} ; \ap \fst {\varepsilon^\chi_{(\alpha, \mu)}} \\  
  &\equiv \ap{\fst}{\ap{\chi^\circ(\chi^+(z))}{(s, m)/z}} ; \ap \fst {\varepsilon^\chi_{(\alpha, \mu)}} \\
  &\equiv \ap{\fst}{\ap{\chi^\circ(\chi^+(z))}{(s, m)/z} ; \varepsilon^\chi_{(\alpha, \mu)}} \\
  &\equiv \ap{\fst}{\varepsilon^\chi_{(\beta, \nu)}; (s, m) } \\
  &\equiv \ap{\fst}{\varepsilon^\chi_{(\beta, \nu)}} ; s\\
  &\equiv \pi^\beta_\nu ; s
  \end{align*}
\item Beta reduction for first projection:
  \begin{align}
\label{beta-pi}
\eta_\beta;(s \bdot m);\pi^\alpha_\mu &\equiv s && \text{where } \TermTwoT{\gamma}{m}{1_\alpha}{\ApEl{p}{s}^+(\mu)}{\alpha}
  \end{align}
follows from naturality and the second triangle equation by:
\begin{align*}
\eta_\beta;(s \bdot m);\pi^\alpha_\mu
&\equiv \eta_\beta;\pi^\beta_{1_\beta};s \\
&\equiv s
\end{align*}

\item Beta reduction for var:
\begin{align}
\label{beta-var}
\ap{\ApEl{p}{(s \bdot m)}^+}{\var{\mu}} &\equiv \ap{\ApEl{p}{\pi^\beta_{1_\beta}}^+}{m}  && \text{where } \TermTwoT{\gamma}{m}{1}{\ApEl{p}{s}^+(\mu)}{\El{p}{\beta}}
\end{align}
is derivable by:
\begin{align*}
\ap{\ApEl{p}{(s \bdot m)}^+}{\var{\mu}} 
&\equiv \ap{\ApEl{p}{\ap{\chi^+}{(s, m)}}^+}{\ap \snd {\varepsilon^\chi_{(\alpha, \mu)}}} \\
&\equiv \ap{1_z}{(s, m)/z};\ap{\ApEl{p}{\ap{\chi^+}{(s, m)}}^+}{\ap \snd {\varepsilon^\chi_{(\alpha, \mu)}}} \\
&\equiv \ap \snd {((s \bdot m), \ap{1_z}{(s, m)/z});\varepsilon^\chi_{(\alpha, \mu)}} \\
&\equiv \ap \snd {\ap{\TrCirc{\chi}{\TrPlus{\chi}{z}}}{(s, m)/z};\varepsilon^\chi_{(\alpha, \mu)}} \\
&\equiv \ap \snd {\varepsilon^\chi_{(\beta, 1_\beta)};(s, m)} \\
&\equiv \var{1_\beta}; \ap{\ApEl{p}{\pi^\beta_{1_\beta}}^+}{m} \\
&\equiv \ap{\ApEl{p}{\pi^\beta_{1_\beta}}^+}{m} \\
\end{align*}

\item The eta principle for pairing:
\begin{align}
\label{eta-pi-var}
t &\equiv \eta_\beta;((t;\pi^\alpha_\mu) \bdot \ap{\ApEl{p}{t}^+}{\var{\mu}}) && \text{where } \TermTwoT{\gamma}{t}{\beta}{\alpha.\mu}{p}
\end{align}
is derived by the first triangle equation followed by naturality of $\eta$:
\begin{align*}
t &\equiv t;\eta_{\alpha.\mu};(\pi_\mu^\alpha \bdot \var{\mu}) \\
&\equiv \eta_\beta;\ap{\TrPlus{\chi}{\TrCirc{\chi}{z}}}{t/z};(\pi_\mu^\alpha \bdot \var{\mu}) \\
&\equiv \eta_\beta;\ap{(z \bdot 1_z)}{t/z};(\pi_\mu^\alpha \bdot \var{\mu}) \\
&\equiv \eta_\beta;(t \bdot \ap{1_z}{t/z});(\pi_\mu^\alpha \bdot \var{\mu}) \\
&\equiv \eta_\beta;((t;\pi_\mu^\alpha) \bdot (\ap{1_z}{t/z}; \ap{\ApEl{p}{t}^+}{\var{\mu}})) \\
&\equiv \eta_\beta;((t;\pi_\mu^\alpha) \bdot \ap{\ApEl{p}{t}^+}{\var{\mu}})
\end{align*}
(We know that $\ap{1_z}{t/z} \equiv \id_{1_\beta}$ because $1_\beta$ is terminal.)
\end{itemize}

We think of a term of mode $p$ as a ``context'', a mode term morphism of
mode $p$ as a ``substitution'', a term of mode $\El{p}{\alpha}$ as a
``dependent type'', and a mode term morphism $1_\alpha
\Yields_{\El{p}{\alpha}} \mu$ as a ``term'' of ``type'' $\mu$.  For the
equations: $\TrPlus{\ApEl{p}{s}}{-}$ is supposed to act like
substitution; equation \eqref{s-plus-one-strict} says that substitution
into the unit type gives the unit type in a different ``context''.

Equation \eqref{beta-var} says that ``substituting'' into a ``variable'' is second projection on the ``substitution''.  Equation \eqref{eta-pi-var} is the usual $\eta$ principle for subsitutions.

\begin{remark}
This axiomatization was inspired by the definition of comprehension
category with unit in \cite{ahman+16fibered}:
\begin{itemize}
\item A fibration $p : \mathcal{E} \to \mathcal{B}$
\item A functor $1 : \mathcal{B} \to \mathcal{E}$ that picks out the terminal object of each fiber,
\item A right adjoint $\{-\} : \mathcal{E} \to \mathcal{B}$ to the functor $1$.
\end{itemize}
In our notation:
\begin{itemize}
\item $\mathcal{B}$ corresponds to the mode $p$ and $\mathcal{E}$ to $\sigmacl{\alpha}{p}{\El{p}{\alpha}}$, with the morphisms in both categories given by the mode-term-2-cells in each.

\item The projection $p : \mathcal{E} \to \mathcal{B}$ is the function $\fst : \sigmacl{\alpha}{p}{\El{p}{\alpha}} \to p$. 

\item The functor $1$ is given by $\chi^\circ$ and $\{-\}$ is given by $\chi^+$, which are automatically adjoint.
\end{itemize}
\end{remark}

For each $\alpha : p$, there is a (metatheoretic) adjunction with $F : p/\alpha \to T(\alpha)$ and $U : \El{p}{\alpha} \to p/\alpha$ given on objects by
\begin{align*}
F(s : \beta \vDash \alpha) &:= \TrCirc{\ApEl{p}{s}}{1_\beta} &&: \El{p}{\alpha} \\
U(x) &:= \pi^\alpha_x &&: \alpha.x \vDash_p \alpha
\end{align*}
with unit and counit
\begin{align*}
H(s) &= \eta^\chi_\beta ; (s \bdot \eta^{\ApEl{p}{s}}_{1_\beta}) &: \beta \vDash_p \alpha.\TrCirc{\ApEl{p}{s}}{1_\beta} && \text{(as a map $s \to \pi^\alpha_{\TrCirc{\ApEl{p}{s}}{1_\beta}}$ of 2-cells over $\alpha$)} \\
E(x) &= \ap{\ApEl{p}{\pi^\alpha_x}^\circ}{\var{x}} ; \varepsilon^{\ApEl{p}{\pi^\alpha_x}}_x &: \TrCirc{\ApEl{p}{\pi^\alpha_x}}{1_{\alpha.x}} \vDash_{\El{p}{\alpha}} x
\end{align*}
The latter map is the transpose of $\var{x}$ across the $\ApEl{p}{\pi^\alpha_x}^\circ \dashv \ApEl{p}{\pi^\alpha_x}^+$ adjunction.
%Checking the triangle equations:
%\begin{align*}
%todo
%\end{align*}
If the adjunction is an equivalence for every $\alpha$ \mvrnote{Do we need any extra compatibility?}, then the $T(\alpha)$ bifibration is equivalent to the codomain bifibration and $(p,\El{p}{-},\chi_p)$ is describing a category with finite limits. 

\begin{definition}
  A comprehension object is an \emph{object with finite limits} if the unit and counit described above are isomorphisms, so there exist inverses:
  \begin{align*}
  H^{-1}(s) : \alpha.\TrCirc{\ApEl{p}{s}}{1_\beta} \vDash_p \beta && \text{(as a map $\pi^\alpha_{\TrCirc{\ApEl{p}{s}}{1_\beta}} \to s$ of 2-cells over $\alpha$)} \\
  E^{-1}(x) : x \vDash_{\El{p}{\alpha}} \TrCirc{\ApEl{p}{\pi^\alpha_x}}{1_{\alpha.x}}
  \end{align*}
  For completeness, being inverses means that:
  \begin{align*}
  \eta^\chi_\beta ; (s \bdot \eta^{\ApEl{p}{s}}_{1_\beta}) ; H^{-1}(s) &\equiv \id_\beta \\
   H^{-1}(s) ; \eta^\chi_\beta ; (s \bdot \eta^{\ApEl{p}{s}}_{1_\beta}) &\equiv \id_{\alpha.\TrCirc{\ApEl{p}{s}}{1_\beta}} \\
   H^{-1}(s) ; s &\equiv \pi^\alpha_{\TrCirc{\ApEl{p}{s}}{1_\beta}} \\
   \ap{\ApEl{p}{\pi^\alpha_x}^\circ}{\var{x}} ; \varepsilon^{\ApEl{p}{\pi^\alpha_x}}_x ; E^{-1}(x) &\equiv \id_{\TrCirc{\ApEl{p}{\pi^\alpha_x}}{1_{\alpha.x}}} \\
   E^{-1}(x) ; \ap{\ApEl{p}{\pi^\alpha_x}^\circ}{\var{x}} ; \varepsilon^{\ApEl{p}{\pi^\alpha_x}}_x &\equiv \id_x  
  \end{align*}
\end{definition}

Naturality of these inverses ought to follow from naturality of $H$ and $E$.

It may be more convenient to demand the unit and counit are identities, not just isomorphisms:

\begin{definition}
  A comprehension object is an \emph{very strict object with finite limits} if the following equations hold:
  \begin{align}
\label{circ-one}
\ApEl{p}{\pi^\alpha_\mu}^\circ(1_{\alpha.\mu}) &\equiv \mu \\
\label{counit-identity}
\ap{\ApEl{p}{\pi^\alpha_x}^\circ}{\var{x}} ; \varepsilon^{\ApEl{p}{\pi^\alpha_x}}_x &\equiv \id_x \\
\label{dot-circ-one}
\alpha.(\ApEl{p}{s}^\circ(1_\beta)) &\equiv \beta \\
\label{pi-dot-circ-one}
\pi^\alpha_{\ApEl{p}{s}^\circ(1_\beta)} &\equiv s \\
\label{unit-identity}
\eta^\chi_\beta ; (s \bdot \eta^{\ApEl{p}{s}}_{1_\beta}) &\equiv \id_\beta
  \end{align}
\end{definition}
Equations \eqref{circ-one} and \eqref{counit-identity} express that the counit of the adjunction between $p/\alpha$ and $T(\alpha)$ is the identity, and equations \eqref{dot-circ-one}, \eqref{pi-dot-circ-one} and \eqref{unit-identity} express that the unit is the identity.

Consequences of this:
\begin{itemize}
\item More general version of equation  \eqref{dot-circ-one}:
\begin{align}
\tag{\ref{dot-circ-one}'} \label{dot-circ}
\alpha. (\ApEl{p}{s}^\circ(\nu)) &\equiv \beta.\nu
\end{align}
By:
\begin{align*}
\alpha.(\ApEl{p}{s}^\circ(\nu))
&\equiv\alpha.(\ApEl{p}{s}^\circ \ApEl{p}{\pi^\beta_\nu}^\circ(1_{\beta.\nu})) \\
&\equiv\alpha.(\ApEl{p}{\pi^\beta_\nu;s}^\circ(1_{\beta.\nu})) \\
&\equiv \beta.\nu
\end{align*}
\item Corresponding more general version of equation \eqref{pi-dot-circ-one}:
\begin{align}
\tag{\ref{pi-dot-circ-one}'} \label{pi-dot-circ}
\pi^\alpha_{\ApEl{p}{s}^\circ(\nu)} &\equiv \pi^\beta_\nu;s
\end{align}
By:
\begin{align*}
\pi^\alpha_{\ApEl{p}{s}^\circ(\nu)}
&\equiv \pi^\alpha_{\ApEl{p}{s}^\circ(\ApEl{p}{\pi^\beta_\nu}^\circ(1_{\beta.\nu}))} \\
&\equiv \pi^\alpha_{\ApEl{p}{\pi^\beta_\nu;s}^\circ(1_{\beta.\nu})} \\
&\equiv \pi^\beta_\nu;s 
\end{align*}
\item Two terms $\mu, \nu : \El{p}{\alpha}$ are equal iff their comprehensions and projections are equal:
\begin{align}
\inferrule{\alpha.\mu \equiv \alpha.\nu \and \pi^\alpha_\mu \equiv \pi^\alpha_\nu}{\mu \equiv \nu}
\end{align}
Follows by:
\begin{align*}
\mu 
&\equiv \TrCirc{\ApEl{p}{\pi^\alpha_\mu}}{1_{\alpha.\mu}} \\
&\equiv \TrCirc{\ApEl{p}{\pi^\alpha_\nu}}{1_{\alpha.\nu}} \\
&\equiv \nu
\end{align*}
\item The old definition of $\var{x}$ is equal to the new one obtained directly from $\chi$.
\begin{align}
\var{x} \equiv \eta^{\ApEl{p}{\pi^\alpha_x}}_{1_{\alpha.x}}
\end{align}
Specialising equation \eqref{unit-identity} to $s \equiv \pi^\alpha_x$, we have
\begin{align*}
\eta^\chi_{\alpha.x} ; (\pi^\alpha_x \bdot \eta^{\ApEl{p}{\pi^\alpha_x}}_{1_{\alpha.x}}) \equiv \id_{\alpha.x}
\end{align*}
but the first triangle equation for $\chi$ claims that already
\begin{align*}
\eta^\chi_{\alpha.x};(\pi_x^\alpha \bdot \var{x}) &\equiv \id_{\alpha.x}
\end{align*}
so $(\pi_x^\alpha \bdot \var{x}) \equiv (\pi^\alpha_x \bdot \eta^{\ApEl{p}{\pi^\alpha_x}}_{1_{\alpha.x}})$ and the result follows.
\end{itemize}
Equation \eqref{circ-one} is an $\eta$ principle that a term of mode
$\El{p}{\alpha}$ (i.e. a ``dependent type'') is determined by its
comprehension and projection. Equation \eqref{dot-circ} says
that the comprehension of $s^\circ(\mu)$ is the same as the
comprehension of $\mu$, while equation \eqref{pi-dot-circ} says that the
projection is determined by $s$ and the projection from $\beta$ (which
type checks using \eqref{dot-circ}).

An automatic consequence of $1_\alpha$ being terminal is that $\eta_\alpha$ is an isomorphism. We might prefer it to be an identity:

\begin{definition}
  A comprehension object is \mvrnote{super cool} if:
\begin{align}
\label{dot-one-strict}
\alpha.1_{\alpha} &\equiv \alpha\\
\label{chi-unit-identity}
\eta^\chi_\alpha &\equiv \id_\alpha
\end{align}
\end{definition}
Consequences of being \mvrnote{super cool}:
\begin{itemize}
\item Projecting away $1_\alpha$ is the identity:
\begin{align}
\label{pi-one-strict}
\pi^\alpha_{1_\alpha} \equiv \id_\alpha 
\end{align}
\item Pairing with $\id_{1_\alpha}$ is the identity:
\begin{align}
\label{pair-s-bang}
(s \bdot \id_{1_\alpha}) \equiv s
\end{align}
By
\begin{align*}
(s \bdot \id_{1_\alpha}) 
&\equiv (s \bdot \id_{1_\alpha}); \pi^\alpha_{1_\alpha} \\
&\equiv \pi^\alpha_{1_\alpha};s \\
&\equiv s
\end{align*}
\end{itemize}

\begin{definition}
  A comprehension object \emph{supports stable $\Sigma$s} if
\[
  z:\sigmacl{\alpha}{p}{\El{p}{\alpha}}, y : \El{p}{\fst z \bdot \snd z}
  \vdash \TrCirc{(\pi^{\fst z}_{\snd{z}})}{y} : \El{p}{\fst z} 
\]
is a morphism of bifibrations from $\El{p}{\fst z \bdot \snd z}$ to $\El{p}{\fst z}$ over $z : \sigmacl{\alpha}{p}{\El{p}{\alpha}}$.
\end{definition}
Expanding the definition, this is asking that for any 
\begin{align*}
\alpha, \beta &: p \\
x &: \El{p}{\beta} \\
y &: \El{p}{\alpha} \\
s &: \beta\Yields_p \alpha \\
m &: x \Yields_{\El{p}{\beta}} \TrPlus{s}{y} \\
z &: \El{p}{\alpha.y} \\
z' &: \El{p}{\beta.x}
\end{align*}
we have
\begin{align*}
\TrCirc{\pi^{\beta}_x}{\TrPlus{(s . m)}{z}} &\equiv_\beta \TrPlus{s}{\TrCirc{\pi^{\alpha}_{y}}{z}} \\
\TrCirc{\pi^{\alpha}_y}{\TrCirc{(s . m)}{z'}} &\equiv_\beta \TrCirc{s}{\TrCirc{\pi^{\beta}_{x}}{z'}}
\end{align*}

\begin{definition}
  A comprehension object \emph{supports stable $\Pi$s} if
\[
  z:\sigmacl{\alpha}{p}{\El{p}{\alpha}}, y : \El{p}{\fst z}
  \vdash \TrPlus{(\pi^{\fst z}_{\snd{z}})}{y} : \El{p}{\fst z \bdot \snd z} 
\]
is a morphism of bifibrations from $\El{p}{\fst z}$ to $\El{p}{\fst z \bdot \snd z}$ over $z : \sigmacl{\alpha}{p}{\El{p}{\alpha}}$.
\end{definition}
This is asking that for any $\alpha, \beta, x, y, s, m$ as above, and
\begin{align*}
w &: \El{p}{\alpha} \\
w' &: \El{p}{\beta}
\end{align*}
we have
\begin{align*}
\TrPlus{\pi^{\beta}_x}{\TrPlus{s}{w}} &\equiv_{\beta.x} \TrPlus{(s . m)}{\TrPlus{\pi^{\alpha}_{y}}{w}} \\
\TrPlus{\pi^{\alpha}_y}{\TrCirc{s}{w'}} &\equiv_{\beta.x} \TrCirc{(s . m)}{\TrPlus{\pi^{\beta}_{x}}{w'}}
\end{align*}

%We are also hoping that $\TrCirc{\ApEl{p}{\pi^\alpha_\mu}}{1_{\alpha.\mu}}$ is isomorphic to $\mu$. We have a map $\TrCirc{\ApEl{p}{\pi^\alpha_\mu}}{1_{\alpha.\mu}} \vDash \mu$ as the transpose of $\var{\mu}$. Is there a map in the other direction?

\subsection{Morphism of Comprehension Objects}

Let $(p,\El{p}{-},\chi_p)$ and $(q,\El{q}{-},\chi_q)$ be two comprehension objects.

\begin{definition}[Lifting to dependent types]
  For a mode term ${\alpha : p \yields f_0(\alpha) : q}$,
  its \emph{lifting to dependent types} is
\begin{mathpar}
  {\alpha : p, x : \El{p}{\alpha} \yields f_1(\alpha,x) : \El{p}{f_0(\alpha)}}
  \and
  f_1(\alpha,x) :\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\alpha_x}}{1_{f_0(\alpha.x)}}
\end{mathpar}
\end{definition}
\noindent We use the convention that, for a mode term $f_0$, $f_1$ is
its lifting to dependent types.

The most basic form of modality is specified in the mode theory by a
morphism of comprehension objects between $p$ and $q$.  
\begin{definition}[\drlnote{Fiberwise?} morphism of comprehension objects]
  A morphism of comprehension objects between $p$ and $q$ is specified by
  a mode term
  \begin{mathpar}
    {\alpha : p \yields f_0(\alpha) : q}
  \end{mathpar}
  such that
  \begin{align}
  f_0(\emptyset_p) &\equiv \emptyset_q 
  \end{align}
\begin{center}
  $f_1$ is a morphism of bifibrations from $\El{p}{-}$ to $\El{q}{f_0(-)}$ over $z : p$, so equations \eqref{mor-fib-subst}, \eqref{mor-fib-unit} and \eqref{mor-fib-counit} are satisfied.
\end{center}
\end{definition}

Observe that equation \eqref{mor-opfib-subst} of being a morphism of
bifibrations is always true for the lifting of an $f_0$:
\begin{mathpar}
  \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\alpha_{\TrCirc{\ApEl{p}{s}}{\nu}}}}{1_{f_0(\alpha.\TrCirc{\ApEl{p}{s}}{\nu})}}
  \equiv
  \TrCirc{\ap{\El{p}{f_0(-)}}{s}}{\TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\beta_\nu}}{1_{f_0(\beta.\nu)}}}
\end{mathpar}
using equations \eqref{dot-circ} \eqref{pi-dot-circ} and fusion.

We often treat $\alpha$ as an implicit argument to $f_1$.  \mvrnote{Out of date, need to re-check these work:} We can show
that $f$ preserves the rest of the structure of a comprehension object:
\begin{align}
\label{mor-one}
f_1(1_\alpha) &\equiv 1_{f_0(\alpha)} \\
\label{mor-dot}
f_0(\alpha.\mu) &\equiv f_0(\alpha).f_1(\mu) \\
\label{mor-pi}
\ap{f_0}{\pi^\alpha_\mu} &\equiv \pi^{f_0(\alpha)}_{f_1(\mu)} \\
\label{mor-var}
\ap{f_1(\alpha,-)}{\mathsf{var}_\mu} &\equiv \mathsf{var}_{f_1(\mu)}
\end{align}
  
\subsection{MLTT via Explicit Substitutions}
\newcommand{\qyields}{\Vdash}
\newcommand{\varsof}[1]{{#1}^\dagger}
\newcommand{\upstairs}[1]{\overline{#1}}
\newcommand{\downstairs}[1]{\underline{#1}}
\newcommand{\asdep}[1]{{#1}_p}

In this section we interpret all the rules and equations of the presentation of type theory given in \cite{altenkirchkaposi16qit} via QITs. 

For consistency we switch from the Agda-style syntax used in the paper to ordinary inference rules. To distinguish judgements in this type theory from the ones in the framework I will use $\qyields$ as the turnstile. \mvrnote{Or some other symbol...} We have the following judgements:
\begin{mathpar}
\qyields \Gamma \CTX \and \Gamma \qyields A \TYPE \and \Gamma \qyields a : A \and \Gamma \qyields \Theta : \Delta 
\end{mathpar}
with the inference rules given in Figure~\ref{fig:qit-rules}. Note that some equations require earlier equations to hold in order to typecheck.

\begin{figure}
\begin{mathpar}
\inferrule*[left=ctx-empty]{~}{\cdot \CTX} \and
\inferrule*[left=ctx-ext]{\qyields \Gamma \CTX \and \Gamma \qyields A \TYPE}{\qyields \Gamma, A \CTX} \\
\inferrule*[left=type-sub]{\Delta \qyields A \TYPE \and \Gamma \qyields \Theta : \Delta}{\Gamma \qyields A[\Theta] \TYPE} \and
\inferrule*[left=term-sub]{\Delta \qyields a : A  \and \Gamma \qyields \Theta : \Delta}{\Gamma \qyields a[\Theta] : A[\Theta]} 
\\
\inferrule*[left=sub-empty]{~}{\Gamma \qyields \epsilon : \cdot} \and
\inferrule*[left=sub-ext]{\Gamma \qyields \Theta : \Delta \and \Gamma \qyields a : A[\Theta]}{\Gamma \qyields (\Theta, a) : \Delta, A} \\
\inferrule*[left=sub-id]{~}{\Gamma \qyields \id_\Gamma : \Gamma} \and
\inferrule*[left=sub-comp]{\Gamma \qyields \Theta : \Delta \and \Delta \qyields \kappa : \Lambda}{\Gamma \qyields \Theta ; \kappa : \Lambda} \\
\inferrule*[left=sub-proj]{~}{\Gamma, A \qyields \proj{\Gamma,A} : \Gamma} \and 
\inferrule*[left=sub-var]{~}{\Gamma, A \qyields \var{\Gamma,A} : A[\proj{\Gamma,A}]} 
\end{mathpar}

\begin{align}
A[\id] &\equiv A \\
A[\Theta ; \kappa] &\equiv A[\kappa][\Theta] \\
\nonumber\\
a[\id] &\equiv a \\
a[\Theta ; \kappa] &\equiv a[\kappa][\Theta] \\
\nonumber\\
\id ; \Theta &\equiv \Theta \\
\Theta ; \id &\equiv \Theta \\
(\Theta; \kappa) ; \rho &\equiv \Theta ; (\kappa ; \rho) \\
\nonumber\\
\Theta ; (\kappa , a) &\equiv (\Theta ; \kappa) , a[\Theta] \\ 
(\Theta, a);\proj{\Gamma,A} &\equiv \Theta \\
\var{\Gamma,A}[\Theta, a] &\equiv a \\
(\proj{\Gamma,A}, \var{\Gamma,A}) &\equiv \id_{\Gamma, A} \\
\Theta &\equiv \epsilon && \text{for } \Gamma \qyields \Theta : \cdot
\end{align}
\caption{Rules of MLTT via Explicit Substitutions}\label{fig:qit-rules}
\end{figure}

We can derive some useful operations:
\begin{mathpar}
\inferrule*[left=derivable]{\Gamma \qyields \Theta : \Delta \and \Delta \qyields A \TYPE}{\Gamma, A[\Theta] \qyields \Theta \uparrow A : \Delta, A} \and
\inferrule*[left=derivable]{\Gamma \qyields a : A}{\Gamma \qyields \hat{a} : \Gamma, A}
\end{mathpar}
defined by:
\begin{align*}
\Theta \uparrow A &:\equiv (\proj{\Gamma, A[\Theta]}; \Theta) , \var{\Gamma, A[\Theta]} \\
\hat{a} &:\equiv \id_{\Gamma} , a
\end{align*}

Using these we give the rules for $\Pi$ and $\Sigma$ types, which we show in Figures~\ref{fig:qit-pi-rules} and~\ref{fig:qit-sigma-rules}.

\begin{figure}
\begin{mathpar}
\inferrule*[left=$\Pi$-form]{\Gamma \qyields A \TYPE \and \Gamma, A \qyields B \TYPE}{\Gamma \qyields \Pi_A B \TYPE} \\
\inferrule*[left=$\Pi$-app]{\Gamma \qyields f : \Pi_A B}{\Gamma, A \qyields \mathsf{app}(f) : B} \and 
\inferrule*[left=$\Pi$-lam]{\Gamma, A \qyields b : B}{\Gamma \qyields \mathsf{lam}(b) : \Pi_A B}
\end{mathpar}
\begin{align}
(\Pi_A B)[\Theta] &\equiv \Pi_{A[\Theta]} B[\Theta \uparrow A] \\
\nonumber\\
\mathsf{app}(\mathsf{lam}(b)) &\equiv b \\
\mathsf{lam}(\mathsf{app}(f)) &\equiv f \\
\mathsf{lam}(b)[\Theta] &\equiv \mathsf{lam}(b[\Theta \uparrow A])
\end{align}
\caption{Rules for $\Pi$-types in  MLTT via Explicit Substitutions}\label{fig:qit-pi-rules}
\end{figure}

\begin{figure}
\begin{mathpar}
\inferrule*[left=$\Sigma$-form]{\Gamma \qyields A \TYPE \and \Gamma, A \qyields B \TYPE}{\Gamma \qyields \Sigma_A B \TYPE} \\
\inferrule*[left=$\Sigma$-pair]{\Gamma \qyields a : A \and \Gamma \qyields b : B[\hat{a}]}{\Gamma \qyields (a, b) : \Sigma_A B} \and
\inferrule*[left=$\Sigma$-$\pi_1$]{\Gamma \qyields p : \Sigma_A B}{\Gamma \qyields \pi_1(p) : A} \and
\inferrule*[left=$\Sigma$-$\pi_2$]{\Gamma \qyields p : \Sigma_A B}{\Gamma \qyields \pi_2(p) : B[\overline{\pi_1(p)}]} \and
\end{mathpar}
\begin{align}
(\Sigma_A B)[\Theta] &\equiv \Sigma_{A[\Theta]} B[\Theta \uparrow A] \\
\nonumber\\
\pi_1(a, b) &\equiv a \\
\pi_2(a, b) &\equiv b \\
(\pi_1(p), \pi_2(p)) &\equiv p \\
(a, b)[\Theta] &\equiv (a[\Theta], b[\Theta])
\end{align}
\caption{Rules for $\Pi$-types in MLTT via Explicit Substitutions}\label{fig:qit-sigma-rules}
\end{figure}

Our goal is to interpret these rules in the framework. The mode theory consists of a comprehension object $p$. The basic idea for representing the judgements of MLTT is as follows:
\begin{itemize}
\item For each object-language context $\Gamma$, there is a corresponding upstairs framework context $\upstairs{\Gamma}$ living over the downstairs framework context $\downstairs{\Gamma}$. There is also an mode term $\downstairs{\Gamma} \yields \asdep{\Gamma} : p$, meant to represent a dependency descriptor for using every variable in $\Gamma$ exactly once.

\item A type $\Gamma \qyields A \TYPE$ is represented by $\upstairs{\Gamma} \yields_{\asdep{\Gamma}} \upstairs{A} \TYPE$.
  
\item A term $\Gamma \qyields a : A$ is represented by $\upstairs{\Gamma} \yields_{1_{\asdep{\Gamma}}} \upstairs{a} : \upstairs{A}$.

\item A substitution $\Gamma \qyields \Theta : \Delta$ has a corresponding framework substitution $\upstairs{\Gamma} \yields \upstairs{\Theta} : \upstairs{\Delta}$ living over $\downstairs{\Gamma} \yields \downstairs{\Theta} : \downstairs{\Delta}$, together with a mode morphism $\downstairs{\Gamma} \yields s_\Theta : \asdep{\Gamma} \vDash_p \asdep{\Delta}[\downstairs{\Theta}]$ that we use to correct the mismatch between object-level and framework substitution.
\end{itemize}

These will be defined inductively, and the general idea is that for $\Gamma$ of the form $x_1 : A_1, \ldots , x_n : A_n$, the framework context $\upstairs{\Gamma}$ will live over the mode context $\downstairs{\Gamma}$ that looks like:
  \[x_1 : \El{p}{\emptyset}, x_2 : \El{p}{\emptyset.x_1}, \ldots, x_{i+1} : \El{p}{\emptyset.x_1.x_2.\ldots.x_i},\ldots
  \]
  The mode term $\asdep{\Gamma} : p$ will be $\emptyset.x_1.x_2.\ldots.x_n$ when $\Gamma$ is $x_1 : A_1, \ldots , x_n : A_n$.

\subsubsection{Structural Rules}

We now give the translations of all the rules in Figure~\ref{fig:qit-rules}.
\begin{enumerate}
\item[\textsc{ctx-empty}] The empty context $\cdot$ is interpreted of course as the empty context in the framework, and we define $\asdep{(\cdot)} :\equiv \emptyset : p$.

\item[\textsc{ctx-ext}] We are provided with an upstairs context $\upstairs{\Gamma}$ over $\downstairs{\Gamma}$, and a type $\upstairs{\Gamma} \yields_{\asdep{\Gamma}} \upstairs{A} \TYPE$.
We can then define
\begin{align*}
\upstairs{\Gamma, x : A} &:\equiv \upstairs{\Gamma}, x : \upstairs{A} \\
\downstairs{\Gamma, x : A} &:\equiv \downstairs{\Gamma}, x : \El{p}{\asdep{\Gamma}} \\
\asdep{(\Gamma, x : A)} &:\equiv (\asdep{\Gamma}).x
\end{align*}

\item[\textsc{type-sub}] We are provided with
\begin{align*}
\upstairs{\Delta} &\yields_{\asdep{\Delta}} \upstairs{A} \TYPE \\
\upstairs{\Gamma} &\yields_{\downstairs{\Theta}} \upstairs{\Theta} : \upstairs{\Delta} \\
\downstairs{\Gamma} &\yields s_\Theta : \asdep{\Gamma} \vDash \asdep{\Delta}[\downstairs{\Theta}]
\end{align*}
So use the derivation
\begin{mathpar}
  \inferrule*[Left=s-form] {
\inferrule*[Left=Sub]{
  \upstairs{\Delta} \yields_{\asdep{\Delta}} \upstairs{A} \TYPE \and 
  \upstairs{\Gamma}\yields_{\downstairs{\Theta}} \upstairs{\Theta} : \upstairs{\Delta}
  }{
  \upstairs{\Gamma} \yields_{\asdep{\Delta}[\downstairs{\Theta}]} \upstairs{A}[\upstairs{\Theta}] \TYPE
  } \and   
  \downstairs{\Gamma} \yields s_\Theta : \asdep{\Gamma} \vDash \asdep{\Delta}[\downstairs{\Theta}]
  }{
    \upstairs{\Gamma} \yields_{\asdep{\Gamma}} \St{s_{\Theta}}{\upstairs{A}[\upstairs{\Theta}]} \TYPE
  }
\end{mathpar}

\item[\textsc{term-sub}] We are provided with
\begin{align*}
\upstairs{\Delta} &\yields_{1_{\asdep{\Delta}}} \upstairs{a} : \upstairs{A} \TYPE \\
\upstairs{\Gamma} &\yields_{\downstairs{\Theta}} \upstairs{\Theta} : \upstairs{\Delta} \\
\downstairs{\Gamma} &\yields s_\Theta : \asdep{\Gamma} \vDash \asdep{\Delta}[\downstairs{\Theta}]
\end{align*}
So use the derivation
\begin{mathpar}
  \inferrule*[Left=s-intro] {
\inferrule*[Left=Sub]{
 \upstairs{\Delta} \yields_{1_{\asdep{\Delta}}} \upstairs{a} : \upstairs{A} \and 
  \upstairs{\Gamma}\yields_{\downstairs{\Theta}} \upstairs{\Theta} : \upstairs{\Delta}
  }{
  \upstairs{\Gamma} \yields_{1_{\asdep{\Delta}[\downstairs{\Theta}]}} \upstairs{a}[\upstairs{\Theta}] : \upstairs{A}[\upstairs{\Theta}] 
  } \and   
  \downstairs{\Gamma} \yields s_\Theta : \asdep{\Gamma} \vDash \asdep{\Delta}[\downstairs{\Theta}]
  }{
    \upstairs{\Gamma} \yields_{\TrPlus{s_{\Theta}}{1_{\asdep{\Delta}[\downstairs{\Theta}]}}} \StI{s_{\Theta}}{\upstairs{a}[\upstairs{\Theta}]} : \St{s_{\Theta}}{\upstairs{A}[\upstairs{\Theta}]}
  }
\end{mathpar}
And by Equation~\eqref{s-plus-one-strict}, we know that $\TrPlus{s_{\Theta}}{1_{\asdep{\Delta}[\downstairs{\Theta}]}} \equiv 1_{\asdep{\Gamma}}$.

\item[\textsc{sub-empty}] This is interpreted as the empty framework substitution. We also define $\downstairs{\Gamma} \yields s_\epsilon : \asdep{\Gamma} \vDash \asdep{(\cdot)}[]$ to be the unique mode-morphism $! : \asdep{\Gamma} \vDash \emptyset$.

\item[\textsc{sub-ext}] We are given
\begin{align*}
\upstairs{\Gamma} &\yields_{\downstairs{\Theta}} \upstairs{\Theta} : \upstairs{\Delta} \\
\downstairs{\Gamma} &\yields s_\Theta : \asdep{\Gamma} \vDash \asdep{\Delta}[\downstairs{\Theta}] \\
\upstairs{\Gamma} &\yields_{1_{\asdep{\Gamma}}} \upstairs{a} : s_{\Theta}^*(\upstairs{A}[\upstairs{\Theta}])
\end{align*}
From the term, we get another term $\upstairs{\Gamma}\yields_{\TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}} \UnSt{s_\Theta}{\upstairs{a}} : \upstairs{A}[\upstairs{\Theta}]$, using \textsc{s-elim-2}. We can now pair this with $\upstairs{\Theta}$ to get a framework substitution \[\upstairs{\Gamma} \yields_{\downstairs{\Theta}, \TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}} (\upstairs{\Theta}, \UnSt{s_\Theta}{\upstairs{a}}) : \upstairs{\Delta}, \upstairs{A}\]
so we define
\begin{align*}
\upstairs{\Theta, a/x} &:\equiv \upstairs{\Theta}, \UnSt{s_\Theta}{\upstairs{a}}/x \\
\downstairs{\Theta, a/x} &:\equiv \downstairs{\Theta}, \TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}/x
\end{align*}
We still need to specify a 2-cell 
\[
\downstairs{\Gamma} \yields s_{\Theta, a/x} : \asdep{\Gamma} \vDash \asdep{(\Delta, x : A)}[\downstairs{\Theta, a/x}]
\]
The codomain here is
\begin{align*}
(\asdep{\Delta}.x)[\downstairs{\Theta}, \TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}/x] 
&\equiv \asdep{\Delta}[\downstairs{\Theta}, \TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}/x].x[\downstairs{\Theta}, \TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}/x] \\
&\equiv \asdep{\Delta}[\downstairs{\Theta}].\TrCirc{s_{\Theta}}{1_{\asdep{\Gamma}}}
\end{align*}
because $x$ does not occur in $\asdep{\Delta}$. Define:
\begin{align*}
s_{\Theta, a} &\equiv \eta^\chi_{\asdep{\Gamma}}; (s_\Theta \bdot \eta_{1_{\asdep{\Gamma}}}^{s_\Theta})
\end{align*}
This is exactly the unit morphism $H(s_\Theta)$ given earlier for the $p/\alpha \to \El{p}{\alpha}$ adjunction.

\item[\textsc{sub-id}] This is translated to be the identity framework substitution on $\upstairs{\Gamma}$, with $s_{\id_\Gamma} :\equiv \id_{\asdep{\Gamma}}$.

\item[\textsc{sub-comp}] This is composition of framework substitutions, with $s_{(\Theta;\kappa)} :\equiv s_\Theta; (s_\kappa[\downstairs{\Theta}])$.

\item[\textsc{sub-proj}] This is translated to the framework substitution with the last term forgotten, i.e. $\mathsf{proj}$ in the framework. Define 
\begin{align*}
\downstairs{\Gamma, A} \yields s_{\proj{\Gamma, A}} : \asdep{(\Gamma, A)} \vDash_p \asdep{\Gamma}[\downstairs{\proj{\Gamma, A}}]
\end{align*}
to be $s_{\proj{\Gamma, A}} :\equiv \pi^{\asdep{\Gamma}}_x$.This makes sense, as substituting $\upstairs{\proj{\Gamma, A}}$ into a framework term or type corresponds to a framework weakening.

\item[\textsc{sub-var}] Our goal is to produce a framework term 
\begin{align*}
\upstairs{\Gamma}, x : \upstairs{A} \yields_{1_{\asdep{(\Gamma, A)}}} \var{\Gamma, A} : \St{s_{\proj{\Gamma, A}}}{\upstairs{A}[\upstairs{\proj{\Gamma, A}}]}
\end{align*}
For this use the derivation:
\begin{mathpar}
\inferrule*[Left=2cell] {
\inferrule*[Left=s-intro] {
 \upstairs{\Gamma}, x : \upstairs{A} \yields_x x : \upstairs{A}[\upstairs{\proj{\Gamma, A}}]
 }{
 \upstairs{\Gamma}, x : \upstairs{A} \yields_{\TrPlus{\pi^{\asdep{\Gamma}}_x}{x}} \StI{\pi^{\asdep{\Gamma}}_x}{x} :\St{\pi^{\asdep{\Gamma}}_x}{\upstairs{A}}
}}{
 \upstairs{\Gamma}, x : \upstairs{A} \yields_{1_{\asdep{\Gamma}.x}} \rewrite{\var{x}}{\StI{\pi^{\asdep{\Gamma}}_x}{x}} :\St{\pi^{\asdep{\Gamma}}_x}{\upstairs{A}}
}
\end{mathpar}
Or equivalently:
\begin{mathpar}
\inferrule*[Left=s-intro-2] {
\inferrule*[Left=2cell] {
 \upstairs{\Gamma}, x : \upstairs{A} \yields_x x : \upstairs{A}[\upstairs{\proj{\Gamma, A}}] \and E(x) : \TrCirc{\pi^{\asdep{\Gamma}}_x}{1_{\asdep{\Gamma}.x}} \vDash_{\El{p}{\asdep{\Gamma}}} x
 }{
 \upstairs{\Gamma}, x : \upstairs{A} \yields_{\TrCirc{\pi^{\asdep{\Gamma}}_x}{1_{\asdep{\Gamma}.x}}} \rewrite{E(x)}{x} : \upstairs{A}
}}{
\upstairs{\Gamma}, x : \upstairs{A} \yields_{1_{\asdep{\Gamma}.x}} \UStI{\pi^{\asdep{\Gamma}}_x}{\rewrite{E(x)}{x}} : \St{\pi^{\asdep{\Gamma}}_x}{\upstairs{A}}
}
\end{mathpar}
Where $E(x) :\equiv \ap{\ApEl{p}{\pi^\alpha_x}^\circ}{\var{x}} ; \varepsilon^{\ApEl{p}{\pi^\alpha_x}}_x$ is the counit of the $p/\alpha \to \El{p}{\alpha}$ adjunction.

\item[{$A[\id] \equiv A$}] Follows because $\St{\id}{A} \equiv A$ surprisingly strictly.
\end{enumerate}
\mvrnote{todo all the other equations}

\subsection{Upstairs Types}
\mvrnote{Oldish stuff:}

The mode terms for upstairs $\Sigma$ and $\Pi$ types are
\begin{align*}
\alpha : p, x : \El{p}{\alpha}, y : \El{p}{\alpha.x} \yields \Sigma_1(\alpha,x,y) :\equiv \TrCirc{\ApEl{p}{\pi^\alpha_x}}{y}  : \El{p}{\alpha}\\
\alpha : p, x : \El{p}{\alpha}, y : \El{p}{\alpha} \yields \Pi_1(\alpha,x,y) :\equiv \TrPlus{\ApEl{p}{\pi^\alpha_x}}{y} : \El{p}{\alpha.x}
\end{align*}
The equations that $z.\TrCirc{(\pi^{\fst z}_{\snd{z}})}{y}$ is part of a
morphism of fibrations says that $\Sigma$-types are stable under
substitution (and preserve the adjunctions).

Using equation \eqref{circ-one}, these terms are:
\begin{align*}
\ApEl{p}{\pi}^\circ(y) \equiv \ApEl{p}{\pi^\alpha_x}^\circ(\ApEl{p}{\pi^{\alpha.x}_y}^\circ(1_{\alpha.x.y})) \equiv \ApEl{p}{\pi;\pi}^\circ(1_{\alpha.x.y}) \\
\ApEl{p}{\pi^\alpha_x}^+(y) \equiv \ApEl{p}{\pi^{\alpha.x}_{\ApEl{p}{\pi^\alpha_x}^+(y)}}^\circ(1_{\alpha.x.\ApEl{p}{\pi}^+(y)})
\end{align*}
which is like what we were writing in the profunctor mode theory.  

This could be made more formal by giving an inductive encoding, but the
basic idea for representing a standard dependent type theory (which we
will refer to as the ``object language'') is as follows:
\begin{itemize}
\item An object-language context $x_1 : A_1, \ldots , x_n : A_n$
  determines a mode context
  \[x_1 : \El{p}{\emptyset}, x_2 : \El{p}{\emptyset.x_1}, \ldots, x_{i+1} : \El{p}{\emptyset.x_1.x_2.\ldots.x_i},\ldots
  \]
  and an upstairs context
  \[x_1 : A_1, x_2 : A_2, \ldots, x_{i+1}:A_{i+1},\ldots
  \]
  over it.  We write $\underline{\Gamma}$ for
  $\emptyset.x_1.x_2.\ldots.x_n$ when $\Gamma$ is
  $x_1 : A_1, \ldots , x_n : A_n$.

\item A judgement $\Gamma \yields A \TYPE$ is represented by
  $\Gamma \yields_{\underline{\Gamma}} A \TYPE$.

\item A judgement $\Gamma \yields a : A$ is represented by
  $\Gamma \yields_{1_{\underline{\Gamma}}} a : A$.

\item $\Sigma$ types are represented by
  \begin{mathpar}
    \inferrule{ \inferrule{\Gamma \yields_{\El{p}{\underline{\Gamma}}} A \TYPE \and
                            \Gamma,x:A \yields_{\El{p}{\underline{\Gamma,x:A}}} B \TYPE}
                          {\Gamma \yields_{\sigmacl{x}{\El{p}{\underline{\Gamma}}}{\El{p}{\underline{\Gamma}.x}}} {\telety{x}{A}{B}} \TYPE }}
            { \Gamma \yields_{\El{p}{\underline{\Gamma}}} \sigmacl{x}{A}{B} := \F{p.\Sigma_1(\underline{\Gamma},\fst p,\snd p)}{\telety{x}{A}{B}} \TYPE }
  \end{mathpar}
\drlnote{Write out what happens when you weaken/substitute.}
  
Pairing is derived as follows:
\begin{mathpar}  
    \inferrule{
    \inferrule{
      \inferrule{\Gamma \yields_{1_{\El{p}{\underline{\Gamma}}}} a : A \and
                 \inferrule{\Gamma \yields_{1_{\El{p}{\underline{\Gamma}.1_{\underline{\Gamma}}}}} B[a/x] \TYPE}
                           {\Gamma \yields_{1_{\El{p}{\underline{\Gamma}}}} b : B[a/x]}
                }
                {\Gamma \yields_{(1_{\underline{\Gamma}},1_{\underline{\Gamma}})} (a,b) : \telety{x}{A}{B}}
    }
    {\Gamma \yields_{\Sigma_1({\El{p}{\underline{\Gamma}}},{1_{\El{p}{\underline{\Gamma}}}},{1_{\El{p}{\underline{\Gamma}}}})} \FI{a,b} : \sigmacl{x}{A}{B}}}
    {\Gamma \yields_{1_{\Gamma}} : \FI{a,b} : \sigmacl{x}{A}{B}}
\end{mathpar}
This uses the equation
$\underline{\Gamma}.1_{\underline{\Gamma}} \equiv \underline{\Gamma}$
(which is a form of contraction) in various places: it's why $B[a/x]$ lives over $1_{\underline{\Gamma}}$
and why $(1_{\underline{\Gamma}},1_{\underline{\Gamma}})$ makes sense
as an element of $\sigmacl{x}{\El{p}{\underline{\Gamma}}}{\El{p}{\underline{\Gamma}.x}}$.
For the final step, we use \eqref{pi-one-strict}:
\begin{mathpar}
{\Sigma_1({\El{p}{\underline{\Gamma}}},{1_{\El{p}{\underline{\Gamma}}}},{1_{\El{p}{\underline{\Gamma}}}})}  
\equiv
\TrCirc{\ApEl{p}{\pi^{\underline{\Gamma}}_{1_{\El{p}{\underline{\Gamma}}}}}}{{1_{\El{p}{\underline{\Gamma}}}}}
\equiv
\TrCirc{\ApEl{p}{\id}}{{1_{\El{p}{\underline{\Gamma}}}}}
\equiv
{{1_{\El{p}{\underline{\Gamma}}}}}
\end{mathpar}

\drlnote{Do split}

\item \drlnote{$\Pi$ types}

\item \drlnote{Variable rule}
  
\end{itemize}


Observe that this lands in a fragment of the framework where each piece
of the judgement depends once on all previous variables, and where the
term $a$ depends on exactly the same variables as the type $A$.



\subsection{Morphism of Comprehension Objects}

Let $(p,\El{p}{-},\chi_p)$ and $(q,\El{q}{-},\chi_q)$ be two comprehension objects.

\mvrnote{FIXME: below is out of date}

\begin{definition}[Lifting to dependent types]
  For a mode term ${\alpha : p \yields f_0(\alpha) : q}$,
  its \emph{lifting to dependent types} is
\begin{mathpar}
  {\alpha : p, x : \El{p}{\alpha} \yields f_1(\alpha,x) : \El{p}{f_0(\alpha)}}
  \and
  f_1(\alpha,x) :\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\alpha_x}}{1_{f_0(\alpha.x)}}
\end{mathpar}
\end{definition}
\noindent We use the convention that, for a mode term $f_0$, $f_1$ is
its lifting to dependent types.

Observe that equation \eqref{mor-opfib-subst} of being a morphism of
bifibrations is always true for the lifting of an $f_0$:
\begin{mathpar}
  \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\alpha_{\TrCirc{\ApEl{p}{s}}{\nu}}}}{1_{f_0(\alpha.\TrCirc{\ApEl{p}{s}}{\nu})}}
  \equiv
  \TrCirc{\ap{\El{p}{f_0(-)}}{s}}{\TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\beta_\nu}}{1_{f_0(\beta.\nu)}}}
\end{mathpar}
using equations \eqref{dot-circ} \eqref{pi-dot-circ} and fusion.

The most basic form of modality is specified in the mode theory by a
morphism of comprehension objects between $p$ and $q$.  
\begin{definition}[\drlnote{Fiberwise?} morphism of comprehension objects]
  A morphism of comprehension objects between $p$ and $q$ is specified by
  a mode term
  \begin{mathpar}
    {\alpha : p \yields f_0(\alpha) : q}
  \end{mathpar}
  such that
  \begin{align}
  f_0(\emptyset_p) &\equiv \emptyset_q 
  \end{align}
\begin{center}
  $(f_0, f_1)$ is a morphism of bifibrations from $(p,\El{p}{-})$ to $(q,\El{q}{-})$
equations  \eqref{mor-fib-subst} \eqref{mor-fib-unit} \eqref{mor-fib-counit}.
\end{center}
\end{definition}

We often treat $\alpha$ as an implicit argument to $f_1$.  We can show
that $f$ preserves the rest of the structure of a comprehension object:
\begin{align}
\label{mor-one}
f_1(1_\alpha) &\equiv 1_{f_0(\alpha)} \\
\label{mor-dot}
f_0(\alpha.\mu) &\equiv f_0(\alpha).f_1(\mu) \\
\label{mor-pi}
\ap{f_0}{\pi^\alpha_\mu} &\equiv \pi^{f_0(\alpha)}_{f_1(\mu)} \\
\label{mor-var}
\ap{f_1(\alpha,-)}{\mathsf{var}_\mu} &\equiv \mathsf{var}_{f_1(\mu)}
\end{align}

\drlnote{Upstairs, a morphism of comprehension objects gives rise to an
  adjoint pair of functors on contexts, which interact with dependent
  types as follows\ldots}

\subsection{Spatial Type Theory}
\newcommand\flatE[3]{\ensuremath{\mathsf{let} \, #2^\flat \, := \, {#1} \, \mathsf{in} \, #3}}

Let
\begin{mathpar}
    {\alpha : p \yields f_0(\alpha) : p}
\end{mathpar}
be a morphism of comprehension objects, together with a mode term 2-cell 
\begin{mathpar}
    {\alpha : p \mid f_0(\alpha) \vDash_p c_\alpha : \alpha}
\end{mathpar}
and equations
\begin{align*}
f_0(f_0(\alpha)) &\equiv f_0(\alpha) \\
\ap{f_0}{c_\alpha} &\equiv \id_{f_0(\alpha)} \\
c_{f_0(\alpha)} &\equiv \id_{f_0(\alpha)}
\end{align*}
making $f_0$ into an idempotent comonad on $p$.

An operation
\begin{mathpar}
  {\alpha : p, x : \El{p}{f_0(\alpha)} \yields \flat_1(\alpha,x) : \El{p}{f_0(\alpha)}}
\end{mathpar}
can be defined in two equivalent ways: either \[\flat_1(\alpha,x) :\equiv f_1(f_0(\alpha),x)\] which typechecks due to idempotence, or \[ \flat_1(\alpha,x) :\equiv  f_1(\alpha,\ApEl{p}{c}^\circ(x)) \]
which is equivalent via:
\begin{align*}
f_1(\alpha,\ApEl{p}{c}^\circ(x)) 
&\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^\alpha_{\ApEl{p}{c}^\circ(x)}}}{1_{f_0(\alpha.\ApEl{p}{c}^\circ(x))}} && \text{(Def of $f_1$)} \\
&\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^{f_0(\alpha)}_x;c}}{1_{f_0(f_0(\alpha).x)}} && \text{(By equations \eqref{dot-circ} and \eqref{pi-dot-circ})} \\
&\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{c}}{\TrCirc{\ap{\El{p}{f_0(-)}}{\pi^{f_0(\alpha)}_x}}{1_{f_0(f_0(\alpha).x)}}} && \text{(Fusion)} \\
&\equiv \TrCirc{\ap{\El{p}{f_0(-)}}{\pi^{f_0(\alpha)}_x}}{1_{f_0(f_0(\alpha).x)}} && \text{($\ap{f_0}{c_\alpha} \equiv \id_{f_0(\alpha)}$)} \\
&\equiv f_1(f_0(\alpha),x)
\end{align*}

A general useful principle is that any $\alpha$ ending with a $\flat_1$ is equal to $f_0$ of itself:
\begin{align*}
f_0(\alpha).\flat_1(x)
&\equiv f_0(\alpha.x) && \text{equation \eqref{mor-dot}} \\
&\equiv f_0(f_0(\alpha.x)) && \text{idempotence of $f_0$} \\
&\equiv f_0(f_0(\alpha).\flat_1(x)) && \text{equation \eqref{mor-dot} again} \\
\end{align*} 
This shows that $\flat_1$ is idempotent:
\begin{align*}
f_0(\alpha).\flat_1(\flat_1(x)) 
&\equiv f_0(f_0(\alpha)).\flat_1(\flat_1(x)) && \text{idempotence of $f_0$} \\
&\equiv f_0(f_0(\alpha).\flat_1(x)) && \text{equation \eqref{mor-dot}}  \\
&\equiv f_0(\alpha).\flat_1(x) && \text{equation above} 
\end{align*}

This time, an object-language context $\Delta; \Gamma \equiv x_1 : A_1, \ldots , x_n : A_n \mid y_1 : B_1, \ldots , y_m : B_m$
  determines a mode context $(\Delta; \Gamma)^\dagger$ where all the $x$'s are marked with $\flat_1$:
  \begin{align*}
  x_1 &: \El{p}{\emptyset}, \\ 
  x_2 &: \El{p}{\emptyset.\flat_1(x_1)}, \\ 
  &\ldots, \\
  x_{n} &: \El{p}{\emptyset.\flat_1(x_1).\ldots.\flat_1(x_{n-1})}, \\
  y_1 &: \El{p}{\emptyset.\flat_1(x_1).\ldots.\flat_1(x_{n-1}).\flat_1(x_{n})}, \\
  y_2 &: \El{p}{\emptyset.\flat_1(x_1).\ldots.\flat_1(x_{n-1}).\flat_1(x_{n}).y_1}, \\
   y_3 &: \El{p}{\emptyset.\flat_1(x_1).\ldots.\flat_1(x_{n-1}).\flat_1(x_{n}).y_1.y_2}, \\
  &\ldots
\end{align*}
  and an upstairs context
  \[x_1 : A_1, \ldots , x_n : A_n, y_1 : B_1, \ldots , y_m : B_m
  \]
  over it.  We write $\underline{(\Delta ; \Gamma)}$ for
  $\emptyset.\flat_1(x_1).\flat_1(x_2).\ldots.\flat_1(x_n).y_1.\dots.y_m$. This is equal to $f_0(\dots  f_0(f_0(\emptyset.x_1).x_2) \dots).y_1.\dots.y_m$, but \emph{not} the same as $f_0(x_1.\dots.x_n).y_1.\dots.y_m$.

These are defined inductively by
\begin{align*}
(\cdot; \cdot)^\dagger &\equiv \cdot \\
(\Delta, x :: A; \cdot)^\dagger &\equiv (\Delta, \cdot)^\dagger, x : \El{p}{\underline{\Delta, \cdot}} \\
(\Delta ; \Gamma, x : A)^\dagger &\equiv (\Delta, \Gamma)^\dagger, x : \El{p}{\underline{\Delta, \Gamma}} \\
\underline{\cdot ; \cdot} &\equiv \emptyset : p \\
\underline{\Delta, x :: A; \cdot} &\equiv (\underline{\Delta, \cdot}).\flat_1(x) : p\\
\underline{\Delta; \Gamma, x : A} &\equiv (\underline{\Delta, \Gamma}).x : p
\end{align*}

Note that \[f_0(\underline{\Delta ; \Gamma}) \equiv (\underline{\Delta, \Gamma ; \cdot})\]

If we have a context $\Delta; \Gamma, \Gamma'$, we can use $\Sigma_1$ to tuple the suffix $\Gamma'$ into a single element of $\El{p}{\underline{\Delta; \Gamma}}$:
\begin{align*}
\underline{\Delta ; \Gamma}. \underline{\cdot} &:\equiv \underline{\Delta ; \Gamma}.1_{\underline{\Delta ; \Gamma}}  \\
\underline{\Delta ; \Gamma}. \underline{\Gamma', x : A} &:\equiv \underline{\Delta ; \Gamma}.\Sigma_1(\underline{\Delta ; \Gamma}, \underline{\Gamma'}, x)
\end{align*}
The equations \eqref{dot-circ} and \eqref{pi-dot-circ} used repeatedly show that $(\underline{\Delta ; \Gamma}).\underline{\Gamma'} \equiv \underline{\Delta ; \Gamma, \Gamma'}$. Let $\pi_{\Gamma'}$ denote the term 2-cell
\begin{align*}
 \TermTwo{(\Delta ; \Gamma, \Gamma')^\dagger}{\pi_{\Gamma'}}{\underline{(\Delta ; \Gamma)}.\underline{\Gamma'}}{\underline{(\Delta ; \Gamma)}}
\end{align*}
The same equations can be used to show this is equal to a composite of $\pi$s.

Object-level judgements live over the mode theory as in MLTT:
\begin{align*}
&\yields \Delta;\Gamma & (\Delta, \Gamma)^\dagger &\yields \underline{(\Delta;\Gamma)} : p \\
\Delta ;\Gamma &\yields A \TYPE & (\Delta, \Gamma)^\dagger &\yields \El{p}{\underline{\Delta;\Gamma}} \type \\
\Delta;\Gamma &\yields M : A & (\Delta, \Gamma)^\dagger &\yields 1_{(\underline{\Delta;\Gamma})} : \El{p}{\underline{\Delta;\Gamma}}
\end{align*}

We can now reconstruct (approximations of) the spacial type theory rules as instances of the framework rules. The key is that in the framework whenever a $f_0(\alpha)$ is required, this can only arise in the object language as $(\underline{\Delta ; \cdot})$.

\begin{itemize}

\item \begin{mathpar}
\inferrule*[vcenter, Right = weaken]{\Delta ; \Gamma\yields M : A} 
{\Delta ; \Gamma, \Gamma' \yields M : A} 
\end{mathpar}
We use framework weakening combined with a structural rule:
\begin{mathpar}
\inferrule*[Right=s-intro]{
\inferrule*[Right = weaken]
{(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \Gamma)}}} M : A}
{(\Delta ; \Gamma, \Gamma')^\dagger \yields_{1_{\underline{(\Delta ; \Gamma)}}} M : A}}
{(\Delta ; \Gamma, \Gamma')^\dagger \yields_{1_{\underline{(\Delta ; \Gamma, \Gamma')}}} \StI{\pi}{M} : \pi^*_{\Gamma'}(A)}
\end{mathpar}

\item \begin{mathpar}
\inferrule*[vcenter, Right = crisp-weaken-suffix]{\Delta ; \cdot \yields M : A} 
{\Delta, \Delta' ; \cdot \yields M : A} 
\end{mathpar}
This is derived the same way.
The cases of weakening in the middle of the context will be trickier.

\item \begin{mathpar}
\inferrule*[vcenter, Right = var]{~}
{\Delta ; \Gamma, x : A \yields x : A} 
\end{mathpar}
The framework \textsc{var} rule lives over $x$, not $1_{\underline{(\Delta ; \Gamma, x : A)}}$, so we use structural rules to correct it:
\begin{mathpar}
\inferrule*[Right = 2cell]{
\inferrule*[Right = S-intro]{
\inferrule*[Right = var]{~}
  {(\Delta ; \Gamma, x : A)^\dagger \yields_{x} x : A}}
  {(\Delta ; \Gamma, x : A)^\dagger \yields_{\pi^+(x)} \StI{\pi}{x} : \pi^*(A)} \and ~ \and
    \TermTwo{(\Delta ; \Gamma, x : A)^\dagger }{\mathsf{var}_x}{1_{\underline{(\Delta ; \Gamma)}.x}}{\pi^+(x)}}
  {(\Delta ; \Gamma, x : A)^\dagger \yields_{1_{\underline{(\Delta ; \Gamma)}.x}} \mathsf{var}_x(\StI{\pi}{x}) : \pi^*(A)} \\
\end{mathpar}
And $1_{\underline{(\Delta ; \Gamma)}.x} \equiv 1_{\underline{(\Delta ; \Gamma, x : A)}}$ by definition.

\item \begin{mathpar}
\inferrule*[vcenter, Right = crisp-var]{~}
{\Delta, x :: A  ; \cdot \yields x : A} 
\end{mathpar}
Using the same derivation as in the cohesive \textsc{var} rule, we have 
\[(\Delta, x : A ; \cdot )^\dagger \yields_{1_{\underline{(\Delta ; \cdot)}.x}} \mathsf{var}_x(\StI{\pi}{x}) : \pi^*(A)\]
but we want a term over $1_{\underline{(\Delta ; \cdot)}.\flat_1(x)}$. So pull back along the 2-cell
\begin{mathpar}
    {\alpha : p \mid f_0(f_0(\underline{\Delta ; \cdot}).x) \vDash_p c_{f_0(\underline{\Delta ; \cdot}).x} : f_0(\underline{\Delta ; \cdot}).x}
\end{mathpar}
Where the domain is 
\begin{align*}
f_0(f_0(\underline{\Delta ; \cdot}).x)
\equiv f_0(f_0(\underline{\Delta ; \cdot})).\flat_1(x)
\equiv f_0(\underline{\Delta ; \cdot}).\flat_1(x)
\equiv (\underline{\Delta ; \cdot}).\flat_1(x)
\end{align*}
and the codomain is 
\begin{align*}
f_0(\underline{\Delta ; \cdot}).x \equiv (\underline{\Delta ; \cdot}).x
\end{align*}
as required.

\item \begin{mathpar}
\inferrule*[Right = subst]{\Gamma \yields M : A \and \Delta ; \Gamma, x : A \yields N : B}
{\Delta ; \Gamma \yields N[M/x] : B[M/x]} 
\end{mathpar}
Use framework substitution:
\begin{mathpar}
\inferrule*[Right= subst]{(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta, \Gamma )}}} M : A \and (\Delta ; \Gamma, x : A)^\dagger \yields_{1_{\underline{(\Delta, \Gamma)}.x}} N : B}
{(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta, \Gamma)}.1_{\underline{(\Delta, \Gamma )}}}} N[M/x] : B[M/x]}
\end{mathpar}
Then $1_{\underline{(\Delta, \Gamma)}.1_{\underline{(\Delta, \Gamma )}}} \equiv 1_{\underline{(\Delta, \Gamma)}}$ by equation \eqref{dot-one-strict}.

\item \begin{mathpar}
\inferrule*[Right = crisp-subst]{\Delta ; \cdot \yields M : A \and \Delta, x :: A ; \Gamma \yields N : B}
{\Delta ; \Gamma \yields N[M/x] : B[M/x]} 
\end{mathpar}
The structure of the rule means that none of the types in $\Gamma$ can depend on $x$, so \mvrnote{somehow} we can consider $N : B$ as lying over $1_{\underline{(\Delta, \cdot )}.\flat_1(x).\pi^+\underline{\Gamma}}$. \mvrnote{There is some lying about how $\dagger$ works, for this to make sense.} Then apply substitution as before:
\begin{mathpar}
\inferrule*[Right= subst]{(\Delta ; \cdot)^\dagger\yields_{1_{\underline{(\Delta, \cdot )}}} M : A \and (\Delta, x : A ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta, \cdot)}.\flat_1(x).\pi^+\underline{\Gamma}}} N : B}
{(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta, \cdot)}.\flat_1(1_{\underline{(\Delta, \cdot )}}).\pi^+\underline{\Gamma}}} N[M/x] : B[M/x]}
\end{mathpar}
That subscript is what we want:
\begin{align*}
1_{\underline{(\Delta, \cdot)}.\flat_1(1_{\underline{(\Delta, \cdot )}}).\pi^+\underline{\Gamma}}
&\equiv 1_{\underline{(\Delta, \cdot)}.1_{\underline{(\Delta, \cdot )}}.\pi^+\underline{\Gamma}} && \text{equation \eqref{mor-one}} \\
&\equiv 1_{\underline{(\Delta, \cdot)}.\underline{\Gamma}} && \text{equations \eqref{dot-one-strict} and \eqref{pi-one-strict}} \\
&\equiv 1_{\underline{(\Delta, \Gamma)}} && \text{definition of $\underline{\Gamma}$}
\end{align*}

\item \begin{mathpar}
\inferrule*[Right = $\flat$-form]{\Delta ; \cdot \yields A \TYPE}
{\Delta ; \Gamma \yields \flat A \TYPE} 
\end{mathpar}
Apply the framework F-form rule for $\flat_1$:
\begin{mathpar}
\inferrule*[Right = F-form]{
    \Delta^\dagger \yields_{\El{p}{f_0(\underline{\Delta, \cdot})}} A \TYPE\\\\
    \gamma, x : {\El{p}{f_0(\underline{\Delta, \cdot})}} \yields \flat_1(\underline{\Delta, \cdot},x) : \El{p}{f_0(\underline{\Delta, \cdot})}
  }
  {\Delta^\dagger \yields_{\underline{(\Delta, \cdot)}} \F{x.\flat_1(\underline{\Delta, \cdot},x)}{A} \TYPE}
\end{mathpar}
The key is that $\underline{(\Delta, \cdot)}$ ends with a $\flat_1$, so $\underline{(\Delta, \cdot)} \equiv f_0(\underline{\Delta, \cdot})$. If $\Gamma$ is nonempty, there is no way to re-write $\underline{(\Delta, \Gamma)}$ into the form $f_0(-)$, explaining the restriction on the formation rule.

We can then weaken the result with $\Gamma$ to get the spatial type theory rule.

\item \begin{mathpar}
\inferrule*[Right = $\flat$-intro]{\Delta ; \cdot \yields M : A}
{\Delta ; \Gamma \yields M^\flat : \flat A}
\end{mathpar}
Again use that $(\underline{\Delta, \cdot}) \equiv f_0(\underline{\Delta, \cdot})$ and apply F-intro:
\begin{mathpar}
\inferrule*[vcenter, Right = F-intro]{
    \Delta^\dagger \yields_{1_{f_0(\underline{\Delta, \cdot})}} M : A
  }
  {\Delta^\dagger \yields_{\flat_1(\underline{\Delta, \cdot},x)[1/x]} \FI{M} : \F{x.\flat_1(\underline{\Delta, \cdot},x)}{A}}
\end{mathpar}
Equations \eqref{mor-one} means that $\flat_1(\underline{\Delta, \cdot},x)[1/x] \equiv 1_{\underline{\Delta, \cdot}}$. Finally, weaken with $\Gamma$.

\item \begin{mathpar}
\inferrule*[Right=crisp-$\flat$-elim]{
    \Delta, x :: \flat A ; \cdot \yields C \TYPE \\\\
    \Delta ; \cdot \yields M : \flat A \\\\
    \Delta, u :: A ; \Gamma \yields N : C[u^\flat / x]}
  {\Delta ; \Gamma \yields (\flatE{M}{u}{N}) : C[M / x]}
\end{mathpar}
As in crisp substitution, no types in $\Gamma$ may depend on $u$, so $N$ lives over 
\[ 1_{\underline{(\Delta ; \cdot)}.\flat_1(u).\pi^+(\underline{\Gamma})}\]
And we can use idempotence of $\flat_1$ to rewrite this into the form
\[ 1_{\underline{(\Delta ; \cdot)}.\flat_1(x).\pi^+(\underline{\Gamma})}[\flat_1(u) / x] \]
needed to apply F-elim:
\begin{mathpar}
 \inferrule*[Right = F-elim]{
    \Delta^\dagger , x : \F{c.\flat_1(\alpha,c)}{A} \yields_{\underline{(\Delta ; \cdot )}.\flat_1(x)} C \TYPE \\\\
     \Delta^\dagger \yields_{1_{\underline{(\Delta ; \cdot )}}} M : \F{c.\flat_1(\alpha,c)}{A} \\\\
    (\Delta, u :: A ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \cdot)}.\flat_1(x).\pi^+(\underline{\Gamma})}[\flat_1(u) / x]} N : C [\FI{u}/x]}
  {(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \cdot)}.\flat_1(x).\pi^+(\underline{\Gamma})}[1_{\underline{(\Delta ; \cdot )}} / x]} (\FE{M}{u}{N}) : C[M/x]} \\
\end{mathpar}
This subscript is equal to $1_{\underline{(\Delta ; \Gamma )}}$ using equation \eqref{mor-one}, followed by \eqref{dot-one-strict} and \eqref{pi-one-strict}.

\item \begin{mathpar}
\inferrule*[Right=$\flat$-elim]{
    \Delta ; \Gamma, x : \flat A \yields C \TYPE \\\\
    \Delta ; \Gamma \yields M : \flat A \\\\
    \Delta, u :: A ; \Gamma \yields N : C[u^\flat / x]}
  {\Delta ; \Gamma \yields (\flatE{M}{u}{N}) : C[M / x]}
\end{mathpar}
In this rule, for $\flat A$ to be well typed it can only depend on $\Delta$. The type of $x$ in the framework is then
\[ \pi_\Gamma^\star(\F{c.\flat_1(\alpha,c)}{A}) \equiv \F{c.\pi_\Gamma^+(\flat_1(\alpha,c))}{A}\]
by. 

Like in crisp-$\flat$-elim, $\Gamma$ does not depend on $u$. The term $N$ lives over $1_{\underline{(\Delta, u :: A; \Gamma)}}$, which we rewrite into 
\[ 1_{\underline{(\Delta ; \Gamma )}.x}[\pi_\Gamma^+(\flat_1(\alpha,u)) / x] \]
\mvrnote{In $1_{\underline{(\Delta, u :: A; \Gamma)}}$ we have implicitly weakened all the types underlying $\Gamma$ with $u$. And we need something to do with $\pi$'s commuting with each other in some situations?}
Apply F-elim:
\begin{mathpar}
\inferrule*[Right = F-elim]{
    (\Delta ; \Gamma)^\dagger, x : \F{c.\pi_\Gamma^+(\flat_1(\alpha,c))}{A} \yields_{\underline{(\Delta ; \Gamma, x : \flat A)}} C \TYPE \\\\
    (\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \Gamma )}}} M : \F{c.\pi_\Gamma^+(\flat_1(\alpha,c))}{A} \\\\
    (\Delta, u :: A ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \Gamma )}.x}[\pi_\Gamma^+(\flat_1(\alpha,u)) / x]} N : C [\FI{x}/y]}
  {(\Delta ; \Gamma)^\dagger \yields_{1_{\underline{(\Delta ; \Gamma )}.x}[1_{\underline{(\Delta ; \Gamma )}}/x]} \FE{M}{u}{N} : C[M/x]}
\end{mathpar}
and $1_{\underline{(\Delta ; \Gamma )}.x}[1_{\underline{(\Delta ; \Gamma )}}/x] \equiv 1_{\underline{(\Delta ; \Gamma)}}$.

\item \begin{mathpar}
\inferrule*[Right = $\sharp$-form]{\Delta, \Gamma ; \cdot \yields A \TYPE}
{\Delta ; \Gamma \yields \sharp A \TYPE} 
\end{mathpar}
We use that $f_0(\underline{\Delta ; \Gamma}) \equiv (\underline{\Delta, \Gamma ; \cdot})$
\begin{mathpar}
\inferrule*[vcenter, Right = U-form]{
    (\Delta , \Gamma ; \cdot)^\dagger \yields_{\El{p}{f_0(\underline{\Delta ; \Gamma})}} A \TYPE \\\\
    \and \gamma, c : {\El{p}{\underline{\Delta ; \Gamma}}} \yields f_1(\underline{\Delta ; \Gamma},c) : \El{p}{f_0(\underline{\Delta ; \Gamma})}
  }{(\Delta ; \Gamma)^\dagger \yields_{\underline{(\Delta ; \Gamma)}} \U{c.f_1(\underline{\Delta ; \Gamma},c)}{\cdot}{A} \TYPE}
\end{mathpar}
\mvrnote{Wait, something screwy is happening here. We can't just replace $(\Delta , \Gamma ; \cdot)^\dagger$ by $(\Delta ; \Gamma)^\dagger$, we need to correct all the variables from $\Delta$ that appear in $\Gamma$ somehow.}

\item \begin{mathpar}
\inferrule*[Right = $\sharp$-intro]{\Delta, \Gamma ; \cdot \yields M : A}
{\Delta ; \Gamma \yields M^\sharp : \sharp A} 
\end{mathpar}
Again, $(\underline{\Delta , \Gamma ; \cdot}) \equiv f_0(\underline{\Delta ; \Gamma})$  so rewrite $1_{f_0(\underline{\Delta ; \Gamma})}$ into $f_1(\underline{\Delta ; \Gamma},c)[1_{(\underline{\Delta ; \Gamma})}/c]$ by equation \eqref{mor-one} and apply U-intro:
\begin{mathpar}
\inferrule*[vcenter, Right = U-intro]{
    (\Delta , \Gamma; \cdot )^\dagger \yields_{f_1(\underline{\Delta ; \Gamma},c)[1_{(\underline{\Delta ; \Gamma})}/c]}  M : A
  }
  {(\Delta ; \Gamma)^\dagger \yields_{1_{(\underline{\Delta ; \Gamma})}} \lambda{M} : \U{c.f_1(\underline{\Delta ; \Gamma},c)}{\cdot}{A}
  } 
\end{mathpar}

\item \begin{mathpar}
\inferrule*[Right = $\sharp$-elim]{\Delta ; \cdot \yields M : \sharp A}
{\Delta ; \Gamma \yields M_\sharp : A} 
\end{mathpar}
First apply U-elim:
\begin{mathpar}
\inferrule*[Right = U-elim]{
    \Delta^\dagger \yields_{1_{(\underline{\Delta ; \cdot})}} N : \U{c.f_1(\alpha,c)}{\cdot}{A}
  }{
    \Delta^\dagger \yields_{f_1(\alpha,c)[1_{(\underline{\Delta ; \cdot})}/c]} \UE{N}{\cdot} : A
  }
\end{mathpar}
Where $f_1(\alpha,c)[1_{(\underline{\Delta ; \cdot})}/c] \equiv 1_{f_0(\underline{\Delta ; \cdot})} \equiv 1_{(\underline{\Delta ; \cdot})}$. Then weaken with $\Gamma$.
\end{itemize}

\mvrnote{So what does the F-type for plain $f_0$ look like?}

\bibliographystyle{abbrv}
\bibliography{../drl-common/cs}

\end{document}


\subsection{Modalities}

Start with a functor $f : p \to q$. Add:
\begin{mathpar}
  \inferrule{\gamma \yields \alpha : p}
            {\gamma \yields f_0(\alpha) : q}
\end{mathpar}
Now we can \emph{define}:
\begin{mathpar}
  \inferrule{\gamma \yields \mu : \El{p}{\alpha}}
            {\gamma \yields f_1(\mu) : \El{p}{f_0(\alpha)}}
\end{mathpar}
by:
\begin{align*}
f_1(\mu) :\equiv \El{p}{\mathsf{ap}(f_0)(\pi^\alpha_\mu)}^\circ(1_{f_0(\alpha.\mu)})
\end{align*}
Together with equations:
\begin{align}
f_0(\emptyset_p) &\equiv \emptyset_q \\
\El{p}{\mathsf{ap}(f_0)(s)}^+(f_1(\mu)) &\equiv f_1(\ApEl{p}{s}^+(\mu)) \\
\mathsf{ap}(f_1)(\eta_s(\mu)) &\equiv \eta_{\mathsf{ap}(f_0)(s)}(f_1(\mu)) \\
\mathsf{ap}(f_1)(\varepsilon_s(\mu)) &\equiv \varepsilon_{\mathsf{ap}(f_0)(s)}(f_1(\mu)) 
\end{align}
where $\eta_s$ and $\varepsilon_s$ are the unit and counit for the adjunction $\ApEl{p}{s}^\circ \dashv \ApEl{p}{s}^+$. 

The following desirable equations are already true, unwinding the definitions:
\begin{align*}
f_1(1_\alpha) &\equiv 1_{f_0(\alpha)} \\
f_0(\alpha.\mu) &\equiv f_0(\alpha).f_1(\mu) \\
\mathsf{ap}(f_0)(\pi^\alpha_\mu) &\equiv \pi^{f_0(\alpha)}_{f_1(\mu)} \\
\mathsf{ap}(f_1)(\mathsf{var}_\mu) &\equiv \mathsf{var}_{f_1(\mu)}
\end{align*}


\subsection{Profunctory Internal-Comprehension-Category Mode Theory}

The basic idea is that a type is a list of variable dependencies, with some information attached to each dependency saying how it relates to the previously specified dependencies in the same type.

We use an auxilliary judgement $\gamma \mid \beta \yields \sigma : \alpha$ that places the type $\beta$ in a place we can treat it as a minicontext: we have been calling these `substitutions' but I think I will call them renamings in what follows. These are renamings/variable-for-variables substitutions between the lists that constitute $\alpha$ and $\beta$.

Weakening and exchange in the context and weakening the minicontext should be straightforwardly admissible. Exchange in the minicontext should also be admissible (wherever it makes sense), and to properly match the semantics, we should probably be identifying such rearrangements.

\begin{mathpar}
  \inferrule*[]{~}
  {\gamma \yields \emptyset \type  } \and 
  \inferrule*[]{ \gamma \yields \beta \type \and \gamma \mid \beta \yields \sigma : \alpha \and (x : \alpha) \in \gamma}
  {\gamma \yields (\beta, i : x[\sigma]) \type  } \\

  \inferrule*[]{ \gamma \yields \beta \type}
  {\gamma \mid \beta \yields () : \emptyset  } \and
  \inferrule*[]{ \gamma \mid \beta \yields \sigma : \alpha \and  \gamma \mid \alpha \yields \tau : \delta \and (j : x[\tau[\sigma]]) \in \beta}
  {\gamma \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])} \\
  
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\gamma \yields (\beta \mid \sigma)
   : \alpha} \\
\end{mathpar}

Where $\tau[\sigma]$ is an admissible substitution rule for renamings, defined below.

\subsubsection{Substitution}

It will take a bit of work to show that substitution is admissible. A substitution $\alpha[(\beta \mid \sigma) / x_0]$ (roughly) expands out to calculating the `pushout' of two natural transformations between types in terms of cell gluing. (Although it looks like an operation on two maps \emph{into} $\alpha$ using the substitution notation.) Intuitively is gluing the list $\beta$ into $\alpha$ everywhere that $x_0$ is used, identifying things as specified by $\sigma$.

This is not too hard to do by hand in simple cases, here are some examples. To reduce the clutter we will denote the unique renaming into $\emptyset$ by $\cdot$, and when it is used to attach a dependency, omit entirely.

Working in the context $x : \emptyset, y : \emptyset, z : \emptyset$ we have things like:
\begin{align*}
(i : x)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y) \\
(i : x, m : z)[(j : y, k : y \mid\, \cdot)/x] &= (j : y, k : y, m : z)
\end{align*}
In context $x : \emptyset, y : \emptyset, z : (i : y)$ we can do:
\begin{align*}
(i : y, j : z[i/i])[(i_1 : x, i_2 : x \mid\, \cdot)/ y] = (i_1 : x, i_2 : x, j : z[i_1/i_1, i_2/i_2])
\end{align*}
as the type of $z$ is now $(i_1 : x, i_2 : x)$. And as an example of some actual gluing, take the context $x : \emptyset, y : (i : x), z : (i : x)$, we can do
\begin{align*}
(i : x, j : y[i/i])[(i : x k : z[i/i] \mid i/i ) / y] = (i : x, k : z[i/i])
\end{align*}

To prove substitution is admissible, the main steps would be:
\begin{enumerate}
\item Composition for renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\item An identity renaming: $\gamma \mid \alpha \yields \id : \alpha$.
\item A `pushout' operation: 
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\item The following Lemma, which looks morally like a more complicated version of $\inl$, (to be proven simultaneously with substitution I suppose)
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0 \mid \alpha \yields \tau : \alpha_0 \and (i : x_0[\tau]) \in \alpha \and \gamma \mid \beta \yields \sigma : \alpha_0}{\gamma \mid \alpha[(\beta \mid \sigma) / x_0] \yields \sigma' : \beta}
\end{mathpar}
such that $\sigma[\sigma'] = \tau[(\beta \mid \sigma)/x_0]$
\item Substitution itself, for types, terms, renamings.
\end{enumerate}

So here we go:

\begin{lemma}
Weakening and exchange are admissible for the minicontext in renamings.
\end{lemma}

\begin{lemma}
Renamings actually work: 
\begin{mathpar}
\inferrule*[]{(i : x[\sigma]) \in \alpha \and \gamma \mid \beta \yields \tau : \alpha}{(j : x[\sigma[\tau]]) \in \beta}
\end{mathpar}
\end{lemma}
\begin{proof}
Note that in the judgement $(i : x[\sigma]) \in \alpha$, the $\sigma$ is being implicitly weakened from some prefix of $\alpha$.
\end{proof}

\begin{lemma}
Composition for renamings is admissible, and this composition is associative.
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \delta \yields \tau : \beta}{\gamma \mid \delta \yields \sigma[\tau] : \alpha}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\alpha$. When $\alpha = \emptyset$, we have the empty renaming $()$. 

If instead $\alpha = (\alpha', i : x[\theta])$, where $\gamma \mid \alpha' \yields \theta : \kappa$, we must have obtained $\gamma \mid \beta \yields \sigma : (\alpha', i : x[\theta])$ via the renaming-extension rule applied to $\gamma \mid \beta \yields \sigma' : \alpha'$ and $(j : x[\theta[\sigma']]) \in \beta$.

Now inductively we have $\gamma \mid \delta \yields \sigma'[\tau] : \alpha'$, and we reapply the renaming-extension rule with $(j : x[\theta [\sigma'][\tau]]) \in \delta$ (using associativity).

\mvrnote{todo associativity}
\end{proof}

\begin{lemma}
For any type there is an identity renaming $\gamma \mid \alpha \yields \id_\alpha : \alpha$, and $\sigma[\id] = \sigma = \id[\sigma]$.
\end{lemma}
\begin{proof}
When $\alpha = \emptyset$, use the empty renaming.

When $\alpha = (\alpha', i : x[\tau])$, inductively form $\id_{\alpha'}$, weaken the minicontext with $i : x[\tau]$, and apply the renaming-extension rule with $(i : x[\tau[\id_{\alpha'}]]) \in (\alpha', i : x[\tau]) $

\mvrnote{todo the properties}
\end{proof}

\begin{lemma}
Given $(i : x[\tau]) \in \alpha$ and $(i' : x[\tau]) \in \alpha$, there is a type $\alpha_{i=i'}$ where the two variables have been identified. This comes with a renaming $\gamma \mid \alpha_{i=i'} \yields \nabla_{i=i'} : \alpha$, and if $\gamma \mid \beta \yields \sigma : \alpha$ identifies $i$ and $i'$, then it factors through $\nabla_{i=i'}$, let us write this factorisation $\sigma = \nabla_{i=i'}[\sigma_{i=i'}]$.
\end{lemma}
\begin{proof}
Without loss of generality $\alpha$ is of the form $\alpha = (\alpha_1, i : x[\tau], \alpha_2, i' : x[\tau], \alpha_3)$. Set 
\begin{align*}
\alpha_{i=i'} &:= (\alpha_1, i : x[\tau], \alpha_2, \alpha_3[i/i']) \\
\nabla_{i=i'} &:= [\alpha_1/\alpha_1, i / i, \alpha_2/\alpha_2, i / i', \alpha_3/\alpha_3]
\end{align*}

\mvrnote{The factorisation thing seems clear to me but annoying to write down}
\end{proof}

\begin{lemma}
We can construct pushouts of renamings:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha}{\gamma \yields \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}\type}
\end{mathpar}
with associated $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ and $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inr : \beta'$, so that $\sigma[\inl] = \sigma'[\inr]$.
\end{lemma}
\begin{proof}
Again induction on $\alpha$. If $\alpha = \emptyset$, then we must have $\sigma = \tau = ()$. We define $\Pushout{\beta}{\emptyset}{\beta'}{()}{()}$ to be just $\beta$ and $\beta'$ concatenated. There are evident $\inl$ and $\inr$ renamings that pick out the $\beta$ or $\beta'$ part, and $\sigma[\inl] = \sigma'[\inr]$ is vacuously true as these are renamings into $\emptyset$.

For the inductive case, suppose:
\begin{align*}
\alpha &= (\alpha, i : x[\tau]) \\
\sigma &= (\sigma, j/i) && \text{where } (j : x [\tau[\sigma]]) \in \beta \\
\sigma' &= (\sigma', j'/i) && \text{where } (j' : x [\tau[\sigma']]) \in \beta'
\end{align*}
Inductively we have $\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$ and the corresponding $\inl/\inr$. Pushing $j$ and $j'$ forward along $\inl$ and $\inr$, and using associativity of renamings, we have 
\begin{align*}
(j[\inl] : x[\tau[\sigma[\inl]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \\
(j'[\inr] : x[\tau[\sigma'[\inr]]]) &\in \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}
\end{align*}
Because $\sigma[\inl] = \sigma'[\inr]$, these variables are a pair that can be identified, and so we do:
\begin{align*}
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma', j'/i)} := (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}
\end{align*}

Now to define $\inl$, we compose the inductively given $\gamma \mid \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'} \yields \inl : \beta$ with the contraction substitution $\gamma \mid (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \yields \nabla : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. Define $\inr$ similarly.

Checking the equation amounts to verifying $\sigma[\inl[\nabla]] = \sigma'[\inr[\nabla]]$, but this is clear by associativity and the inductive hypothesis.
\end{proof}

\begin{lemma}
Universal property for pushout, i.e.:
\begin{mathpar}
\inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \sigma' : \alpha \\\\ 
\gamma \mid \delta \yields \theta : \beta \and \gamma \mid \delta \yields \theta' : \beta' \\\\ 
\sigma[\theta] = \sigma'[\theta']}
{\gamma \mid \delta \yields \case^{\sigma, \sigma'}_\alpha(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}}
\end{mathpar}
\end{lemma}
\begin{proof}
If $\alpha = \emptyset$, then the pushout is $(\beta, \beta')$, and we have the renaming $\gamma \mid \delta \yields (\theta / \beta, \theta' / \beta') : (\beta, \beta')$.

If $\alpha = (\alpha, i : x[\tau])$, we inductively have $\case(\theta, \theta') : \Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'}$. To get the renaming into $(\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]}$, we just have to show that $\case(\theta, \theta')$ identifies $j[\inl]$ and $j'[\inr]$. This follows from the equation $\sigma[\theta] = \sigma'[\theta']$, as $j$ and $j'$ are $i$ pushed forward along $\sigma$ and $\sigma'$. \mvrnote{This is sketchy}. We then have an induced renaming $\case(\theta, \theta')_{j[\inl] = j'[\inr]}$.

Note: it appears we only need existence, not uniqueness.
\end{proof}

The following three lemmas all refer to each other so will be proven by mutual induction. In what follows, if $\gamma \yields \mu : \alpha$ is a term, let $\gamma \mid \bar \mu \yields \mu : \alpha$ be its underlying renaming.

\begin{lemma}\label{inl-sub}
$\inr$ for substitution:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \alpha \yields \tau : \alpha_0 \and (i_0 : x_0[\tau]) \in \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0}
\end{mathpar}
such that $\mu_0[\ini_{i_0}(\mu_0)] = \tau[\mu_0/x_0]$
\end{lemma}
\begin{proof}

Note that because $\tau$ is a substitution for $\alpha_0$, and $x_0$ is not used in $\alpha_0$, $\tau$ can't use any variable in $x_0 : \alpha_0, \gamma'$. This premise could be replaced by something like $\gamma \mid \alpha' \yields \tau : \alpha_0$ where $\alpha'$ the subset of $\alpha$ only containing variables from $\gamma$.

Induction on $\alpha$. We cannot have $\alpha = \emptyset$, as we have assumed $(i_0 : x_0[\tau]) \in \alpha$.

If $\alpha = (\alpha, i : x[\tau])$ with $i \neq i_0$, then $i_0$ must appear earlier in $\alpha$ somewhere and inductively we know $\gamma, \gamma'[\mu_0 / x_0] \mid \alpha[\mu_0 / x_0] \yields \ini_{i_0 \in \alpha}(\mu_0) : \bar \mu_0$, and we can just weaken the minicontext to $(\alpha[\mu_0 / x_0], i : x[\tau[\mu_0 / x_0]])$. Inductively the equation holds, and weakening doesn't change this.

If instead $\alpha = (\alpha, i_0 : x[\tau])$, then by definition $(\alpha, i_0 : x[\tau])[\mu_0/x_0] = \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$ and we can use $\inr$. \mvrnote{todo equation}
\end{proof}

\begin{lemma}
Substitution into types:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \yields \beta \type \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\beta$. If $\beta = \emptyset$ there is nothing to do. \mvrnote{except deal with $\gamma'$}

If $\beta = (\beta, i : x[\sigma])$ for $x \neq x_0$, by the inductive step we have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$. We can then find $(x : \alpha[\mu_0/x_0]) \in \gamma, \gamma'[\mu_0/x_0]$ and reapply the rule.

If $\beta = (\beta, i : x_0[\sigma])$, then $\sigma$ here is $\gamma, x_0 : \alpha_0, \gamma'\mid \beta \yields \sigma : \alpha_0$. Again we inductively have $\gamma, \gamma'[\mu_0/x_0] \yields \beta[\mu_0/x_0] \type$ and $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha_0[\mu_0/x_0]$. Note here that $\alpha_0[\mu_0/x_0] = \alpha_0$ because $x_0$ does not occur in $\alpha_0$. 

We then form the pushout of this $\sigma[\mu_0/x_0]$ along the renaming underlying $\mu_0$, yielding the type \[\Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0}\] as our answer.
\end{proof}

\begin{lemma}
Substitution into renamings:
\begin{mathpar}
\inferrule*[]{\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields \sigma : \alpha \and \gamma \yields \mu_0 : \alpha_0}{\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]}
\end{mathpar}
\end{lemma}
\begin{proof}
Induction on $\sigma$. If $\sigma$ is the empty renaming there is nothing to do.

So suppose we have just applied the renaming-extension rule to get $\gamma, x_0 : \alpha_0, \gamma' \mid \beta \yields (\sigma, j/i) : (\alpha, i : x[\tau])$, where $(j : x[\tau[\sigma]]) \in \beta$. Inductively we have $\gamma, \gamma'[\mu_0/x_0] \mid \beta[\mu_0/x_0] \yields \sigma[\mu_0/x_0] : \alpha[\mu_0/x_0]$. 

Again there are two cases. If $x \neq x_0$, we can reapply the rule with $(j : x[\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]]) \in \beta[\mu_0/x_0]$. (Here we have to use an interchange rule for renamings and substitution: $\tau[\mu_0/x_0][\sigma[\mu_0/x_0]]] = \tau[\sigma][\mu_0/x_0]$)

If $x = x_0$, our goal is a renaming into $(\alpha, i : x_0[\tau])[\mu_0/x_0]$, which is $\Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0}$. For this we use the universal property of pushouts, applied to the following diagram (where confusingly the arrows go the opposite direction of renamings):
\[
\begin{tikzcd}
\alpha_0 \ar[r, "{\tau[\mu_0/x_0]}"] \ar[d, "\mu_0" swap] & \alpha[\mu_0/x_0] \ar[d] \ar[ddr, bend left, "{\sigma[\mu_0/x_0]}"] & \\
\bar \mu_0 \ar[r] \ar[drr, bend right, "\ini_j(\mu_0)" swap]& \Pushout{\alpha[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\tau[\mu_0/x_0]}{\mu_0} \ar[dr, dashed] & \\
& & \beta[\mu_0/x_0]
\end{tikzcd}
\]
\end{proof}

In summary:
\begin{align*}
\Pushout{\beta}{\emptyset}{\beta'}{()}{()} &:= (\beta, \beta') \\
\Pushout{\beta}{(\alpha, i : x[\tau])}{\beta'}{(\sigma, j/i)}{(\sigma, j'/i)} &:= (\Pushout{\beta}{\alpha}{\beta'}{\sigma}{\sigma'})_{j[\inl] = j'[\inr]} \\
\inl^{(), ()}_\emptyset(\beta, \beta') &:= [\beta/\beta] \\
\inl^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inl^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\inr^{(), ()}_\emptyset(\beta, \beta') &:= [\beta'/\beta'] \\
\inr^{(\sigma, j/i), (\sigma', j'/i)}_{(\alpha, i:x[\tau])} (\beta, \beta') &:= \inr^{\sigma, \sigma'}_\alpha (\beta, \beta') [\nabla_{j, j'}] \\
\case^{(),()}_\emptyset(\theta, \theta') &:= (\theta / \beta, \theta' / \beta') \\
\case^{(\sigma,j/i),(\sigma', j'/i)}_{(\alpha,i:x[\tau])}(\theta, \theta') &:= \case^{\sigma, \sigma'}_{\alpha}(\theta, \theta')_{j[\inl]=j'[\inr]} \\
\ini_{i_0 \in (\alpha, i : x[\sigma])}(\mu_0) &:= \ini_{i_0 \in \alpha}(\mu_0)\\
\ini_{i_0 \in (\alpha, i_0 : x[\sigma])}(\mu_0) &:= \inr^{\sigma[\mu_0/x_0],\mu_0}_{\alpha_0}(\alpha[\mu_0/x_0], \bar \mu_0) \\
\\
\emptyset[\mu_0/x_0] &:= \emptyset \\
(\beta, i : x[\sigma])[\mu_0/x_0] &:= (\beta[\mu_0/x_0], i : x[\sigma[\mu_0/x_0]]) \\
(\beta, i : x_0[\sigma])[\mu_0/x_0] &:= \Pushout{\beta[\mu_0/x_0]}{\alpha_0}{\bar \mu_0}{\sigma[\mu_0/x_0]}{\mu_0} \\
\\
()[\mu_0/x_0] &:= () \\
(\sigma, j/i)[\mu_0/x_0] &:= (\sigma[\mu_0/x_0], j[\mu_0/x_0]/i) && \text{where } (j : x[\tau[\sigma]]) \in \beta, x \neq x_0 \\
(\sigma, j/i)[\mu_0/x_0] &:= \case(\sigma[\mu_0/x_0], \ini_j(\mu_0)) && \text{where } (j : x_0[\tau[\sigma]]) \in \beta \\
\\
\end{align*}

\subsubsection{The Variable Rule}
This isn't built in, but we can define it:
\begin{lemma}
Variable rule:
\begin{mathpar}
\inferrule*[]{~}{\gamma, x : \alpha, \gamma' \yields x : \alpha}
\end{mathpar}
\end{lemma}
\begin{proof}
This term is built as a renaming into $\alpha$. For this use \[\gamma, x : \alpha, \gamma' \mid \alpha, i : x[\alpha/\alpha]\yields (\alpha/\alpha) : \alpha\]
\end{proof}
Note that this is a projection, so whatever term rule we have must allow projections.

\subsubsection{Defining $\TrPlus{s}{-}$ and $\TrCirc{s}{-}$}
Continue to use the convention that $\bar \mu$ denotes the type underlying a term $\mu : \alpha$. As suggested by their names, type 2-cells $\TypeTwo{\gamma}{s}{\alpha}{\beta}$ act in the mode theory as follows:
\begin{lemma}
\begin{mathpar}
\inferrule*
    {\gamma \yields \mu : \beta \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrPlus{s}{\mu} : \alpha}

\inferrule*
    {\gamma \yields \mu : \alpha \\
     \TypeTwo{\gamma}{s}{\alpha}{\beta}
    }
    {\gamma \yields \TrCirc{s}{\mu} : \beta}
\end{mathpar}
\end{lemma}
\begin{proof}
For $s^+$, construct the pushout $\Pushout{\bar \mu}{\beta}{\alpha}{\mu}{s}$. The renaming $\gamma \mid \Pushout{\bar \mu}{\beta}{\alpha}{\mu}{s} \yields \inr : \alpha$ is the desired term. 

For $s^\circ$, we compose the renaming $s$ with $\mu$, so: $\gamma \mid \bar \mu \yields s[\mu] : \beta$.
\end{proof}

And we build the unit and counit:
\begin{lemma}
\begin{mathpar}
\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (x : \beta \in \gamma)
    }
    {\TermTwo{\gamma}{\varepsilon}{\TrCirc{s}{\TrPlus{s}{x}}}{x}}

\inferrule*
    {\TypeTwo{\gamma}{s}{\alpha}{\beta} \and (y : \alpha \in \gamma)
    }
    {\TermTwo{\gamma}{\eta}{y}{\TrPlus{s}{\TrCirc{s}{y}}}}
\end{mathpar}
\end{lemma}
\begin{proof}
The counit is the upper right triangle in the following pushout diagram (written in natural transformation direction):
\[
\begin{tikzcd}[column sep={2cm,between origins},row sep={2cm,between origins}]
\beta \ar[r, "x"] \ar[d, "s" swap]  \ar[dr, "\TrCirc{s}{\TrPlus{s}{x}}" near start] & \bar x \ar[d, "\inl"] \\
\alpha \ar[r, "\TrPlus{s}{x}" swap] & \overline{\TrPlus{s}{x}} \\
\end{tikzcd}
\]

The unit is the triangle on the right:
\[
\begin{tikzcd}
\beta \ar[d, "s" swap] \ar[r, "s"]& \alpha \ar[dd, "\TrPlus{s}{\TrCirc{s}{x}}"] \ar[dddr, bend left = 40, "x"] &  \\
\alpha \ar[d, "x" swap] & & \\
\bar x \ar[r, "\inl" swap]  \ar[drr, "\id" swap, bend right] & \overline{\TrPlus{s}{\TrCirc{s}{x}}} \ar[dr, dashed]& \\
& & \bar x
\end{tikzcd}
\]
\end{proof}

\subsubsection{$\Sigma$ and $\Pi$}

$\Sigma$ ought to be the $F$ type for \[\gamma, x : \alpha, y : (\alpha, i : x[\id_\alpha]) \yields (\alpha, i : x[\id_\alpha], j : y[\id_{(\alpha, x)}] \mid \alpha / \alpha) : \alpha\]

Let's call this $\sigma_x(y)$, or something. As a sanity check, we can test this with a simple case of $F$-left.
\begin{mathpar}
\inferrule*[Left=F-left]{\Gamma, x : A, y : B(x) \yields_{\id_{(\alpha, z)}[\sigma_x(y)/z]} c[\FI{x,y}/z] : C[\FI{x,y}/z]}{\Gamma, z : F_{\sigma_x(y)}(x:A, y : B(x)) \yields_{\id_{(\alpha, z)}} c : C}
\end{mathpar}
And presumably $\id_{(\alpha, z)}[\sigma_x(y)/z] = \id_{(\alpha, x, y)}$, as the pushout would identify $x$ and $y$'s dependence on an $\alpha$ with the existing $\alpha$ in $(\alpha, z)$.

And the $F$-intro rule 
\begin{mathpar}
\inferrule*[Left=F-right$^*$]{~}{\Gamma, x : A, y: B(x) \yields_{\sigma_x(y)} \mathsf{pair}(x,y) : F_{\sigma_x(y)}(x:A, y : B(x))}
\end{mathpar}
could be read as saying that the term $\mathsf{pair}(x,y) := \FI{x,y}$ uses exactly what the type $A$ does, plus one usage of $x$ and one usage of $y$.

$\Pi$ ought to be the $U$ type for \[\gamma, x : \alpha, y : \alpha \yields (\alpha, i : x[\id_\alpha], j : y[\id_{\alpha}] \mid \alpha / \alpha, i / i) : (\alpha, i : x[\id_\alpha])\]
If we call this $\pi_x(y)$, we can try the $U$-right rule in a simple case:
\begin{mathpar}
  \inferrule*[Left = U-right]{\Gamma, x : A \yields_{\pi_x(y)[(\alpha \mid \id_\alpha) / y]} N : B}
  {\Gamma \yields_{(\alpha \mid \id_\alpha)} \UI x N : U_{y.\pi_x(y)}(A \vert B)} \\
\end{mathpar}
And then $\pi_x(y)[(\id_\alpha\vert \alpha)/y] = (\alpha, i : x[\id_\alpha] \mid \id) : (\alpha, i : x[\id_\alpha])$, as the $\alpha$ from the $y$ has been glued to the existing one.

\subsubsection{Structurality}

We can change what structural rules are available by changing which renamings we are permitted to promote to 2-cells.

\begin{enumerate}
\item The term rule controls how the dependencies of a term relate to the dependencies of its type. By construction, the dependencies of a term bound the dependencies of the type, but we could restrict this further: Allowing only `relevant' renamings here would say that terms can't use variables that their types didn't.

We could choose to not consider types `up to ordering', so that the order of dependencies mattes. Then, allowing only identity renamings in the term rule would demand that terms have have the same dependencies as their types, in the same order. (Whatever this means!)

\item The type 2-cells control the structural rules in the types
\item The term 2-cells control the structural rules in the terms
\end{enumerate}

E.g., for full structurality, we would use:

\begin{mathpar}
  \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha}
  {\TypeTwo{\gamma}{\sigma}{\beta}{\alpha}}  \and   \inferrule*[]{\gamma \mid \beta \yields \sigma : \alpha \and \gamma \mid \beta' \yields \tau : \beta}
  {
  \TermTwo{\gamma}{s}{(\beta \mid \sigma)}{(\beta' \mid \sigma[\tau])}}
\end{mathpar}

These choices cannot be totally arbitrary: 
\begin{enumerate}
\item The variable rule requires that the term rule at least permits projections. Also, we need a type 2-cell $\TypeTwo{\gamma}{s}{\alpha} {\beta}$ to act on terms via $\TrCirc{s}{-}$ and $\TrPlus{s}{-}$. This means, terms must be closed under composition with and pushout along type 2-cells.
\item We need term 2-cells $\TermTwo{\gamma}{s}{\mu}{\mu'}$ to induce type 2-cells via substitution: $\TypeTwo{\gamma}{s}{\alpha[\mu/x]}{\alpha[\mu'/x]}$. \mvrnote{What exactly is required for this? Enough that term 2-cells are included in type 2-cells?}
\item For each type 2-cell $\TypeTwo{\gamma}{s}{\alpha} {\beta}$, the corresponding unit and counit term 2-cells must exist.
\end{enumerate}

As an example, it appears these choices could allow a type system where the types behave fully structurally and the terms behave linearly, but not vis versa.

\subsection{Modal Type Theories}
\newcommand{\Modes}{\mathcal{M}}

Now let's try to match the idea where we have a small 2-category $\Modes$, and we want a dependent type theory that uses $\Modes$ as the modes. It seems that we want to annotate
\begin{itemize}
\item Types with a mode $p \in \ob \Modes$ so $\gamma \yields \alpha \type_p$
\item Dependencies in a type with a morphism $f : p \to q$, so $\gamma \mid \beta \yields_f \sigma : \alpha$.
\item Variable usages in a renaming with a 2-cell $s : f \Rightarrow g$.
\end{itemize}

A first naive attempt, that doesn't work, is:

\begin{mathpar}
  \inferrule*[]{p \in \ob \Modes}
  {\gamma \yields \emptyset_p \type_p  } \and 
  \inferrule*[]{ \gamma \yields \beta \type_p \and \gamma \yields \alpha \type_q \and f : p \to q \in \Modes \and \gamma \mid \beta \yields_f \sigma : \alpha \and (x : \alpha) \in \gamma }
  {\gamma \yields (\beta, i : x_f[\sigma]) \type_p  } \\

  \inferrule*[]{ \gamma \yields \beta \type_p \and f : p \to q \in \Modes}
  {\gamma \mid \beta \yields_f () : \emptyset_q  } \and
  \inferrule*[]{ \gamma \mid \beta \yields_f \sigma : \alpha \and  \gamma \mid \alpha \yields_g \tau : \delta \and (j : x_h[\tau[\sigma]]) \in \beta \and s : gf \Rightarrow h \in \Modes}
  {\gamma \mid \beta \yields_f (\sigma, j_s/i) : (\alpha, i : x_g[\tau])} \\
\end{mathpar}
But above, saying $x_h[\tau[\sigma]]$ doesn't make sense, as presumably $\tau[\sigma]$ is a renaming that is mapped to $gf$. I think we may need an inductively defined way to extend the $s : f \Rightarrow g$ 2-cells in $\Modes$ to a kind of 2-cell between renamings. 

\subsection{Bunchy Type Theories}

\bibliographystyle{abbrv}
\bibliography{../cs.bib}

\end{document}

