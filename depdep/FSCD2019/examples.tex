\subsection{Mode Theories}\label{sec:mode-theories}

In this section we present a number of dependent type theories and the mode theories used to represent them. 

\subsubsection{Martin-L\"of Type Theory}

We first give the mode theory corresponding to standard Martin-L\"of Type Theory. 

\begin{definition}[Adjoint Mode Terms]
A mode term $\gamma, x : p \yields f : q$ is \emph{left adjoint} to $\gamma, y : q \yields u : p$ if there are specified constants:
\begin{align*}
\gamma, x : p &\yields \eta_x : x \tcell_p u(f(x)) \\
\gamma, y : q &\yields \varepsilon_y : f(u(y)) \tcell_q y
\end{align*}
such that $\eta$ and $\varepsilon$ are natural and the triangle identities hold.
%such that $\eta$ and $\varepsilon$ are natural:
%\begin{align}
%\eta_x ; \ap{u}{\ap{f}{s}} &\equiv s ; \eta_{x'} && \text{for } s : x \tcell_p x'  \\
%\ap{f}{\ap{u}{t}} ; \varepsilon_{y'}  &\equiv \varepsilon_y ; t && \text{for } t : y \tcell_q y'
%\end{align}
%and the triangle identities hold:
%\begin{align}
%\eta_{u(\nu)};\ap{u}{\varepsilon_\nu} &\equiv \id_{u(\nu)} \\
%\ap{f}{\eta_\mu};\varepsilon_{f(\mu)} &\equiv \id_{f(\mu)}
%\end{align}
\end{definition}


\begin{definition}[Comprehension Object]\label{def:comprehension-object}
  A \emph{comprehension object} is specified by the following
  constants:
  \begin{mathpar}
    p \type \and \alpha : p \yields \El{p}{\alpha} \type \and \alpha : p \yields \One_\alpha : \El{p}{\alpha}
    \\ 
    \TypeTwo{\cdot}{\chi}{p}{\sigmacl{\alpha}{p}{\El{p}{\alpha}}} \and
    \TypeTwo{\cdot}{\psi}{p}{1}
  \end{mathpar}
  such that
\begin{align*}
\alpha : p &\yields (\alpha, \One_\alpha) : \sigmacl{\alpha}{p}{\El{p}{\alpha}} \\
\alpha : p &\yields () : 1
\end{align*}
are left adjoints to $\chi^+$ and $\psi^+$ respectively.
\end{definition}

In particular, this supplies us with natural mode term morphisms
\begin{align*}
\eta^\chi_\alpha {}&: &\alpha &\tcell_p \TrPlus{\chi}{(\alpha, \One_\alpha)} \\
\varepsilon^\chi_{(\alpha, \mu)} {}&: &(\TrPlus{\chi}{(\alpha, \mu)}, \One_{\TrPlus{\chi}{(\alpha, \mu)}}) &\tcell_{\sigmacl{\alpha}{p}{\El{p}{\alpha}}} (\alpha, \mu) \\
\eta^\psi_\alpha {}&: &\alpha &\tcell_p \TrPlus{\psi}{()} \\
\varepsilon^\psi_{x} {}&: &x &\tcell_1 ()
\end{align*}
satisfying the triangle identities. We write $\ApOne{s}$ as a short-hand for $\ap{\One_z}{s/z}$. 

\begin{definition}
Any comprehension object supports the following derived forms (where $\gamma \yields \alpha : p$
and $\gamma \yields \beta : p$ and
$\TermTwoT{\gamma}{s}{\beta}{\alpha}{p}$ and $\gamma \yields \mu :
\alpha$ and $\gamma \yields \nu : \beta$):
  \begin{itemize}
  \item A distinguished term $\emptyset : p$ is given by $\emptyset :\equiv \TrPlus{\psi}{()}$
  \item Comprehension is given by $\alpha : p, x : \El{p}{\alpha} \yields \alpha.x :\equiv \TrPlus{\chi}{(\alpha, x)} : p$
  \item Mode term morphisms corresponding to projection and the variable rule are defined via the counit of the adjunction $\chi^\circ \dashv \chi^+$.
\begin{align*}
  \TermTwoT{\alpha:p,x:\El{p}{\alpha}&}{ \pi^\alpha_x :\equiv \ap \fst {\varepsilon^\chi_{(\alpha, x)}}}{\alpha.x}{\alpha}{p} \\
  \TermTwoT{\alpha:p,x:\El{p}{\alpha}&}{\var{x} :\equiv \ap \snd {\varepsilon^\chi_{(\alpha, x)}}}{\One_{\alpha.x}}{\TrPlus{\ApEl{p}{\pi^\alpha_x}}{x}}{\El{p}{\alpha.x}}
\end{align*}
  \item Pairing for the comprehension object is given by ap of
  comprehension on the pairing for $\Sigma$-modes:
  \begin{mathpar}
  \inferrule{\TermTwoT{\gamma}{s}{\alpha}{\beta}{p} \and
             \TermTwoT{\gamma}{m}{\mu}{\TrPlus{\ApEl{p}{s}}{\nu}}{\El{p}{\alpha}}}
            {\TermTwoT{\gamma}{s.m}{\alpha.\mu}{\beta.\nu}{p}} \and
  s \bdot m :\equiv \ApPlus{\chi}{(s, m)}
  \end{mathpar}
  \end{itemize}
\end{definition}

This definition is a type-theoretic analogue of a fibration that \emph{admits comprehension}. This is a fibration $E \to B$ with fibred terminal object $1 : B \to E$ such that the functor $1$ has a right adjoint, see \mvrnote{ref}.

In the type-theoretic definition, $p$ and $\El{p}{\alpha}$ describe a fibration $\fst : \sigmacl{\alpha}{p}{\El{p}{\alpha}} \to p$. The term $(\alpha, \One_\alpha)$ describes a functor $p \to \sigmacl{\alpha}{p}{\El{p}{\alpha}}$ that sends $\alpha$ to a distinguished object $\One_\alpha$ in the fibre over $\alpha$, and this functor has a right adjoint $\TrPlus{\chi}{\alpha,x}$.

The primary difference is that we do not need to assume that $\One_\alpha$ is terminal in $\El{p}{\alpha}$, so $(\alpha, \One_\alpha) : p \to \sigmacl{\alpha}{p}{\El{p}{\alpha}}$ is not right adjoint to $\fst : \sigmacl{\alpha}{p}{\El{p}{\alpha}} \to p$. We also do not assume that $p$ is full, in the sense of there being a bijection between mode term morphisms $x \tcell_{\El{p}{\alpha}} y$ and mode term morphisms $\alpha.x \tcell_p \alpha.y$ that commute with projection.

\begin{theorem}
The judgements and structural rules of MLTT can be interpreted over any comprehension object (Definition \ref{def:comprehension-object}).
\end{theorem}

We now list the requirements on a mode theory framework to model the standard type formers.

\begin{definition}
A comprehension object \emph{supports the unit type} if $\eta^\chi_\alpha : \alpha \tcell_p \alpha.\One$ is an isomorphism, i.e.:
\begin{align}
\pi^\alpha_{\One_\alpha} ; \eta^\chi_\alpha \equiv \id_{\alpha.\One_\alpha}
\end{align}
\end{definition}

\begin{definition}\label{def:supports-sigmas}
A comprehension object \emph{supports $\Sigma$-types} if it supports the unit type and there is a specified mode term
\begin{align*}
\alpha : p, x : \El{p}{\alpha}, y : \El{p}{\alpha.x} \vdash \Sigma_1(\alpha,x,y) : \El{p}{\alpha}
\end{align*}
and mode term morphisms
\begin{align*}
\contract{\alpha} &: \One_\alpha \tcell_{\El{p}{\alpha}} \Sigma_1(\alpha,\One_\alpha,\One_{\alpha.{\One_\alpha}}) \\
\tsplit{\alpha,x,y} &: \alpha.\Sigma_1(\alpha,x,y) \tcell_{p} \alpha.x.y
\end{align*}
such that $\tsplit{\alpha,x,y}$ is an inverse to $\pair{\alpha,x,y}$, defined by:
\begin{align*}
\fibpair{\alpha,x,y} &: \One_{\alpha.x.y} \tcell_{\El{p}{\alpha.x.y}} \TrPlus{(\pi^{\alpha.x}_y;\pi^\alpha_x)}{\Sigma_1(\alpha,x,y)} \\
\fibpair{\alpha,x,y} &:\equiv \contract{\alpha.x.y};\ap{\Sigma_1(\alpha,x,y)}{(\pi^{\alpha.x}_y;\pi^{\alpha}_x,\ApOne{\pi^{\alpha.x}_y};\ApPlus{\ApEl{p}{\pi^{\alpha.x}_y}}{\var{x}}, \ApOne{\pi^{\alpha.x.y}_{\One_{\alpha.x.y}}};\ApPlus{\ApEl{p}{\pi^{\alpha.x.y}_{\One_{\alpha.x.y}}}}{\var{y}})/(\alpha,x,y)} \\
\pair{\alpha,x,y} &: \alpha.x.y \tcell_{p} \alpha.\Sigma_1(\alpha,x,y) \\
\pair{\alpha, x, y} &:\equiv \eta^\chi_{\alpha.x.y};((\pi^{\alpha.x}_y;\pi^\alpha_x) \bdot \fibpair{\alpha,x,y})
\end{align*}
and $\contract{\alpha}$ is natural:
\begin{align}
\contract{\alpha};\ap{\Sigma_1(\alpha,x,y)}{(s, \ApOne{s}, \ApOne{s \bdot \ApOne{s}})/(\alpha,x,y)} \equiv \ApOne{s};\ApPlus{\ApEl{p}{s}}{\contract{\beta}}
\end{align}
for any $s : \alpha \tcell_p \beta$.
\end{definition}

\mvrnote{How does this compare to left adjoint to weakening? I still don't see...}

Only $\contract{\alpha}$ is needed to define $\pair{\alpha,x,y}$, as mode terms are always functorial with respect to mode term morphisms via ap. If the requirement that $\pair{\alpha, x, y}$ be an isomorphism is dropped, we may still interpret weak $\Sigma$-types with a non-dependent eliminator.

\begin{definition}\label{def:supports-pis}
A comprehension object \emph{supports $\Pi$-types} if $\ApOne{\pi^\alpha_x}$ is an isomorphism.
\end{definition}

Let $\alpha : p, x : \El{p}{\alpha}, c : \El{p}{\alpha} \yields \Pi_1(\alpha,x,c) :\equiv \TrPlus{\ApEl{p}{\pi^\alpha_x}}{c} : \El{p}{\alpha.x}$.

\begin{theorem} 
Let $p$ be a comprehension object.
\begin{itemize}
\item If $p$ supports the unit type and the $\mathsf{F}$-types for $\One_\alpha$ exists, then the rules of the unit type may be interpreted in the type theory.
\item If $p$ supports $\Sigma$-types and the $\mathsf{F}$-types for $\Sigma_1(\alpha,x,y)$ exists, then the rules of $\Sigma$-types may be interpreted in the type theory.
\item If $p$ supports $\Pi$-types and the $\mathsf{U}$-types for $\Pi_1(\alpha,x,c)$ exist then the rules for $\Pi$-types may be interpreted in the type theory.
\end{itemize}
\end{theorem}

\subsubsection{Adjoint Type Theory}

We now turn to extensions of MLTT. 

Dependent right adjoint types have previously been studied in \mvrnote{cite}. An operation $\lock$ on contexts and a type former $\Rtype{}$ are added, with $\lock$ adjoint to $\Rtype{}$ in the sense that terms of $\Gamma, \lock \qyields A \TYPE$ correspond bijectively with terms of $\Gamma \qyields \Rtype{A} \TYPE$.

We give the rules of dependent right adjoint types in Figure~\ref{fig:qit-adjoint-rules}. These are presented in an algebraic style with explicit weakenings and substitutions; rules written in this form are more convenient to translate into the framework. The turnstile is written as $\qyields$ to distinguish judgements in the object language from judgements in the framework.

The rules of right adjoint types are mildly generalised to allow an adjoint between two different comprehension objects. Each judgement is marked with the comprehension object to which it belongs. Note that judgements with subscript $p$ necessarily have no $\lock$s in the context, and those with subscript $q$ have exactly one. To recover the type theory of \mvrnote{ref}, erase the subscripts. 

The framework also suggests rules for dependent \emph{left} adjoints $\Ltype{}$, also given in Figure~\ref{fig:qit-adjoint-rules}. In the equations we use $\Theta \uparrow A$ to denote the derived form $\Gamma, A[\Theta] \qyields ((\proj{\Gamma, A[\Theta]}; \Theta) , \qvar{\Gamma, A[\Theta]}) : \Delta, A$, for any substitution $\Gamma \qyields \Theta : \Delta$ and type $\Delta \qyields A \TYPE$.

\begin{figure}
\begin{mathpar}
\inferrule*[left=ctx-$\lock$]{\qyields_p \Gamma \CTX}{\qyields_q \Gamma, \lock \CTX} \and
\inferrule*[left=sub-$\lock$]{\Gamma \qyields_p \Theta : \Delta}{\Gamma, \lock \qyields_q \Theta, \lock : \Delta, \lock} \\
\inferrule*[left=R-form]{\Gamma, \lock \qyields_q A \TYPE}{\Gamma \qyields_p \Rtype{A} \TYPE} \\
\inferrule*[left=R-intro]{\Gamma, \lock \qyields_q a : A}{\Gamma \qyields_p \RI{a} : \Rtype{A}} \and
\inferrule*[left=R-elim]{\Gamma \qyields_p b : \Rtype{B}}{\Gamma, \lock \qyields_q \RE{b} : B} \\
\inferrule*[left=L-form]{\Gamma \qyields_p A \TYPE}{\Gamma, \lock \qyields_q \Ltype{A} \TYPE} \\
\inferrule*[left=L-intro]{~}{\Gamma, A, \lock \qyields_q \LI{A} : \Ltype{A}[\proj{\Gamma, A}, \lock]} \and
\inferrule*[left=L-elim]{\Gamma, A, \lock \qyields_q c : C[\proj{\Gamma, A}, \lock, \LI{A}]}{\Gamma, \lock, \Ltype{A} \qyields_q \LE{c} : C} \\
\end{mathpar}
\begin{align}
\id_\Gamma , \lock &\equiv \id_{\Gamma, \lock} \\
(\Theta, \lock) ; (\kappa, \lock) &\equiv (\Theta ; \kappa), \lock \\
\nonumber \\
\Rtype{A}[\Theta] &\equiv \Rtype{(A[\Theta, \lock])} \\
\RI{a}[\Theta] &\equiv \RI{a[\Theta, \lock]} \\
\RE{\RI{a}} &\equiv a \\
\RI{\RE{b}} &\equiv b \\
\nonumber \\
\Ltype{A}[\Theta, \lock] &\equiv \Ltype{(A[\Theta])} \\
\LI{A}[\Theta \uparrow A, \lock] &\equiv \LI{A[\Theta]} \\
\LE{c}[\Theta, \lock \uparrow \Ltype{A}] &\equiv \LE{c[\Theta \uparrow A, \lock]} \\
\LE{c}[\proj{\Gamma, A}, \lock, \LI{A}] &\equiv c
\end{align}
\caption{Rules for Dependent Adjoints in MLTT}\label{fig:qit-adjoint-rules}
\end{figure}

The requirements on the mode theory are as follows.

\begin{definition}\label{def:morphism-comprehension-object}
A \emph{morphism of comprehension objects} $f$ from $(p, \One^p, \chi^p, \psi^p)$ to $(q, \One^q, \chi^q, \psi^q)$ consists of constants
\begin{align*}
&\yields f : q \tcell p \\
\alpha : p, x : \El{p}{\alpha} &\yields f_1(x) : \El{q}{\TrPlus{f}{\alpha}} \\
\alpha : p &\yields \fone{\alpha} : \One^q_{\TrPlus{f}{\alpha}}  \tcell_{\El{q}{\TrPlus{f}{\alpha}}} f_1(\One^p_\alpha)
\end{align*}
such that $\fone{\alpha}$ is natural:
\begin{align}
\fone{\alpha};\ap{f_1}{s/\alpha, \ApOne{s}} \equiv \ApOne{\ApPlus{f}{s}};\ApPlus{\ApEl{q}{\ApPlus{f}{s}}}{\fone{\beta}}
\end{align}
\end{definition}

\begin{definition}
A morphism of comprehension objects $f$ \emph{supports right adjoint types} if $\fone{\alpha}$ is an isomorphism.
\end{definition}
%Let $\foneinv{\alpha}$ denote the inverse of $\fone{\alpha}$.

\begin{definition}
A morphism of comprehension objects $f$ \emph{supports left adjoint types} if $q$ supports the unit type and 
\begin{align*}
\fdist{\alpha, x} &: \TrPlus{f}{\alpha.x} \tcell_q \TrPlus{f}{\alpha}.f_1(x) \\
\fdist{\alpha, x} &:\equiv \eta^{\chi}_{\TrPlus{f}{\alpha.x}} ; (\ApPlus{f}{\pi^\alpha_x} \bdot \fone{\alpha.x};\ap{f_1}{\pi^\alpha_x/\alpha, \var{x}/x})
\end{align*}
is an isomorphism.
\end{definition}

\mvrnote{Note that these conditions are roughly analogous to those for $\Pi$- and $\Sigma$-types.}

\begin{theorem} 
Suppose $p$ and $q$ are comprehension objects and $f$ is a morphism of  comprehension objects.
\begin{itemize}
\item If $f$ supports right adjoint types and the $\mathsf{U}$-types for $f_1$ exist, then the rules of right adjoint types may be interpreted in the type theory.
\item If $f$ supports left right adjoint types and the $\mathsf{F}$-types for $f_1$ exist, then the rules of right adjoint types may be interpreted in the type theory.
\end{itemize}
\end{theorem}

\subsubsection{Spatial Type Theory}
\mvrnote{intro spatial type theory} In order to interpret spatial type theory, we work with a morphism of comprehension objects $f$ from $p$ to itself and give $\TrPlus{f}{-}$ the structure of an idempotent comonad.

\begin{definition}
A morphism of comprehension objects $f$ \emph{supports spatial types} if there are mode term morphisms
\begin{align*}
\alpha : p &\yields \fcounit{\alpha} : \TrPlus{f}{\alpha} \Rightarrow_p \alpha \\
\alpha : p &\yields \fcomult{\alpha} : \TrPlus{f}{\alpha} \Rightarrow_p \TrPlus{f}{\TrPlus{f}{\alpha}}
\end{align*}
satisfying:
\begin{align}
\fcomult{\alpha};\fcounit{\TrPlus{f}{\alpha}} &\equiv \id_{\TrPlus{f}{\alpha}} \\
\ApPlus{f}{\fcounit{\alpha}} &\equiv \fcounit{\TrPlus{f}{\alpha}}\\
\ApPlus{f}{\fcomult{\alpha}} &\equiv \fcomult{\TrPlus{f}{\alpha}}
\end{align}
\end{definition}

%\begin{figure}
%\begin{mathpar}
%\inferrule*[left=counit-$\lock$]{~}{\Gamma, \lock \qyields \counit{\Gamma} : \Gamma} \and
%\inferrule*[left=comult-$\lock$]{~}{\Gamma, \lock \qyields \comult{\Gamma} : \Gamma, \lock, \lock}
%\end{mathpar}
%\begin{align}
%\counit{\Gamma}; \Theta &\equiv (\Theta, \lock) ; \counit{\Delta} \\
%\comult{\Gamma}; (\Theta, \lock, \lock) &\equiv (\Theta, \lock) ; \comult{\Delta} \\
%\nonumber \\
%\comult{\Gamma} ; \counit{\Gamma, \lock} &\equiv \id_{\Gamma, \lock} \\
%\comult{\Gamma}, \lock &\equiv \comult{\Gamma, \lock} \\
%\counit{\Gamma}, \lock &\equiv \counit{\Gamma, \lock}
%\end{align}
%\caption{Rules for spatial type theory with explicit counit and comultiplication}\label{fig:qit-minimal-spatial-rules}
%\end{figure}

In our algebraic presentation these additions to the mode theory manifest as axiomatic substitutions $\Gamma, \lock \qyields \counit{\Gamma} : \Gamma$ and $\Gamma, \lock \qyields \comult{\Gamma} : \Gamma, \lock, \lock$. These satisfying the same equations as the mode theory, for example, $\comult{\Gamma};\counit{\Gamma, \lock} \equiv \id_{\Gamma, \lock}$.

We now sketch a translation of the rules of spatial type theory \mvrnote{TODO: ref} into algebraic style. A context $\Delta \mid \Gamma$ of spatial type theory is translated such that a $\lock$ is applied after every context extension of the \emph{crisp context}. For example, $x :: A, y :: B \mid w : C, z : D$ becomes $\lock, A, \lock, B, \lock, C, D$. In this way we maintain the invariant that a crisp context $\Delta \mid \cdot$ always ends with a $\lock$. 

In Figure~\ref{fig:qit-spatial-rules} we show each spatial type theory rule and its equivalent in the algebraic style. A number of spatial type theory rules build in cuts or weakenings; as both are explicit in CwF style we leave these out. In the rules for $\sharp$ we give the special case of a $\sharp$-type that depends on a single cohesive variable. The case of a general cohesive context would need a more careful inductive argument.

\begin{figure}
\begin{mathpar}
\inferrule*[left=crisp-var]{~}{\Delta, x :: A \mid \cdot \yields x : A} \and
\inferrule*{~}{\Gamma, \lock, A, \lock \qyields \qcrispvar{A} : A[\counit{\Gamma, \lock, A} ; \proj{\Gamma, \lock, A}] } \\
\inferrule*[left=crisp-ctx-ext]{\Delta \mid \cdot \yields A \TYPE}{\yields \Delta, A \mid \cdot \CTX} \and
\inferrule*{\Gamma, \lock \qyields A \TYPE}{\qyields \Gamma, \lock, A, \lock \CTX} \\
\inferrule*[left=crisp-sub-ext]{(\Delta \mid \cdot) \yields \Theta : (\Delta' \mid \cdot) \and (\Delta \mid \cdot) \yields a : A[\Theta]}{(\Delta \mid \cdot) \yields (\Theta, a) : (\Delta', A \mid \cdot)} \and
\inferrule*{\Gamma, \lock \qyields \Theta : \Gamma', \lock \and \Gamma, \lock \yields a : A[\Theta]}{\Gamma, \lock \qyields (\Theta, a) : \Gamma', \lock, A, \lock} \\
\inferrule*[left=$\flat$-form]{\Delta \mid \cdot \yields A \TYPE}{\Delta \mid \cdot \yields \Flattype{A} \TYPE} \and
\inferrule*{\Gamma, \lock \qyields A \TYPE}{\Gamma, \lock \qyields \Flattype{A} \TYPE} \\
\inferrule*[left=$\flat$-intro]{\Delta \mid \cdot \yields a : A}{\Delta \mid \cdot \yields \FlatI{a} : \Flattype{A}} \and
\inferrule*{\Gamma, \lock \qyields a : A}{\Gamma, \lock \qyields \FlatI{a} : \Flattype{A}} \\
\inferrule*[left=$\flat$-elim]{\Delta, u :: A \mid \cdot \yields c : C[\FlatI{u}/x]}{\Delta \mid x : \Flattype{A} \yields \FlatE{c} : C} \and
\inferrule*{\Gamma, \lock, A, \lock \qyields c : C[(\counit{\Gamma, \lock, A} ; \proj{\Gamma, \lock, A}), \FlatI{\qcrispvar{A}}]}{\Gamma, \lock, \Flattype{A} \qyields \FlatE{c} : C} \\
\inferrule*[left=$\sharp$-form]{\Delta, x :: B \mid \cdot \yields A \TYPE}{\Delta \mid x : B \yields \Sharptype{A} \TYPE} \and
\inferrule*{\Gamma, \lock, B, \lock \qyields A \TYPE}{\Gamma, \lock, B \qyields \Sharptype{A} \TYPE} \\
\inferrule*[left=$\sharp$-intro]{\Delta, x :: B \mid \cdot \yields a : A}{\Delta \mid x : B \yields \SharpI{a} : \Sharptype{A}} \and
\inferrule*{\Gamma, \lock, B, \lock \qyields a : A}{\Gamma, \lock, B \qyields \SharpI{a} : \Sharptype{A}} \\
\inferrule*[left=$\sharp$-elim]{\Delta, x :: B \mid \cdot \yields a : \Sharptype{A}}{\Delta, x :: B \mid \cdot \yields \SharpE{a} : A} \and
\inferrule*{\Gamma, \lock, B, \lock \qyields a : \Sharptype{A}[\counit{\Gamma, \lock, B}]}{\Gamma, \lock, B, \lock \qyields \SharpE{a} : A}
\end{mathpar}
\caption{Spatial type theory rules and their algebraic equivalent}\label{fig:qit-spatial-rules}
\end{figure}

\begin{proposition}
The rules on the right are derivable in the algebraic syntax for adjoint type theory with counit and comultiplication.
\end{proposition}

For example, $\flat$-types are derived by
\begin{mathpar}
\inferrule*[Left=cut]{
\inferrule*[Left=$\Ltype{}$-form]
{\Gamma, \lock \qyields A \TYPE}
{\Gamma, \lock, \lock \qyields \Ltype{A} \TYPE}}
{\Gamma, \lock \qyields \Ltype{A}[\comult{\Gamma}] \TYPE}
\end{mathpar}


\subsection{Example Translations}\label{sec:demonstration}

For each judgement in the object language $J$, we write its translation as $\upstairs{J}$. In the translations of the above type theories, we maintain the following invariants:
\begin{itemize}
\item A context $\qyields \Gamma \CTX$ is represented by a framework type $\cdot \yields_p \upstairs{\Gamma}$.
\item A type $\Gamma \qyields A \TYPE$ is represented by a framework type $\alpha : \upstairs{\Gamma} \yields_{\El{p}{\alpha}} \upstairs{A} \TYPE$.
\item A term $\Gamma \qyields a : A$ is represented by a framework term $\alpha : \upstairs{\Gamma} \yields_{\One_\alpha} \upstairs{a} : \upstairs{A}$.
\item A substitution $\Gamma \qyields \Theta : \Delta$ is represented by a framework term $\alpha : \upstairs{\Gamma} \yields_\alpha \upstairs{\Theta} : \upstairs{\Delta}$.
\end{itemize}
This allows us to translate object-language substitution into types and terms as a total framework substitution into the unique variable in the framework context.

This is a change from \mvrnote{LSR}, in which object-language contexts are translated to framework contexts. \mvrnote{This didn't work because ... Something like, in principle there could be many non-equivalent ways to package a collection of types into a single context (as an object in the category of contexts), and a framework context does not have enough information in it?}

The general schema is as follows: context formers are specified by mode type morphisms, structural rules are specified by mode term morphisms and type formers are specified by mode terms. We give an example of each of these in turn.

\begin{itemize}
\item Context formers are translated to $s$-types for a mode type morphism. For example, the context extension rule
\begin{mathpar}
\inferrule*[left=ctx-ext]{\qyields \Gamma \CTX \and \Gamma \qyields A \TYPE}{\qyields \Gamma, A \CTX}
\end{mathpar}
is derived by
\begin{mathpar}
\inferrule*[Left=s-intro]{
\inferrule*[Left=()-intro]{\cdot \yields_p \upstairs{\Gamma} \TYPE \and \alpha : \upstairs{\Gamma} \yields_{\El{p}{\alpha}} \upstairs{A} \TYPE}
{\cdot \yields_{\Sigma \alpha:p.\El{p}{\alpha}} \telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}} \TYPE}}
{\cdot \yields_p \St{\chi}{\telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}}} \TYPE}
\end{mathpar}
Where $\TypeTwo{\cdot}{\chi}{p}{\Sigma \alpha:p.\El{p}{\alpha}}$ is of the right shape to move $\telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}}$ back over mode $p$.

\item Structural rules are translated to rewrites by a mode term morphism. For example, projection
\begin{mathpar}
\inferrule*[left=sub-proj]{~}{\Gamma, A \qyields \proj{\Gamma,A} : \Gamma}
\end{mathpar}
is derived as follows:
\begin{mathpar}
\inferrule*[Left=s-elim]{
\inferrule*[Left=cut]{
            \inferrule*[Left=rewrite]{\alpha : \upstairs{\Gamma}, x : \upstairs{A}  \vdash_\alpha \alpha : {\upstairs{\Gamma}}}
                       {\alpha : \upstairs{\Gamma}, x : \upstairs{A}  \vdash_{\TrPlus{\chi}{\alpha, x}} \rewrite{\pi^\alpha_x}{\alpha} : {\upstairs{\Gamma}}}}
                       {w : \telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}} \yields_{ \TrPlus{\chi}{\fst w, \snd w}} \rewrite{\pi^\alpha_x}{\alpha}[\fst w / \alpha, \snd w / x] : \upstairs{\Gamma}}
           }
           {
             \beta : \St{\chi}{\telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}}} \yields_\beta \StE{\chi}{\beta}{w}{\rewrite{\pi^\alpha_x}{\alpha}[\fst w / \alpha, \snd w / x]} : \upstairs{\Gamma}
           }
\end{mathpar}
Here pullback along $\pi^\alpha_x : \alpha.x \tcell_p \alpha$ allows us to consider the term in mode $\alpha$ as a term in mode $\alpha.x \equiv \TrPlus{\chi}{\alpha, x}$, which is of the correct form to apply $s$-elimination to.

\item Type formation rules are translated to formation rules for the appropriate framework type. The $\Sigma$-elimination rule
\begin{mathpar}
\inferrule*[left=$\Sigma$-form]{\Gamma \qyields A \TYPE \and \Gamma, A \qyields B \TYPE}{\Gamma \qyields \Sigma_A B \TYPE}
\end{mathpar}
is derived by 
\begin{mathpar}
\inferrule*[Left=F-form]
{\inferrule*[Left=$()$-form]
{\alpha : \upstairs{\Gamma} \yields_{\El{p}{\alpha}} \upstairs{A} \TYPE \and 
\inferrule*[left=cut]{
\alpha : \upstairs{\Gamma}, x : \upstairs{A} \yields_{\alpha.x} \StI{\chi}{(\alpha, x)} : \upstairs{\Gamma, A}
\and 
\beta : \upstairs{\Gamma, A} \yields_{\El{p}{\beta}} \upstairs{B} \TYPE
}{
\alpha : \upstairs{\Gamma}, x : \upstairs{A} \yields_{\El{p}{\alpha.x}} \upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta] \TYPE
}
}
{\alpha : \upstairs{\Gamma} \yields_{\telety{x}{\El{p}{\alpha}}{\El{p}{\alpha.x}}} \telety{x}{\upstairs{A}}{\upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta]} \TYPE}}
{\alpha : \upstairs{\Gamma} \yields_{\El{p}{\alpha}} \F{w. \Sigma_1(\alpha,\fst w, \snd w)}{\telety{x}{\upstairs{A}}{\upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta]}} \TYPE}
\end{mathpar}
As framework $\mathsf{F}$-types are unary, we first construct a telescope type from containing both $\upstairs{A}$ and $\upstairs{B}$. The type $\upstairs{B}$ is defined in context $\beta : \St{\chi}{\telety{\alpha}{\upstairs{\Gamma}}{\upstairs{A}}}$, so some unpacking is required before we can form the framework telescope type. 

\item Term introduction and elimination rules are translated to framework-level introduction and elimination rules, together with rewrites along mode term morphisms used to maintain the invariants of the translation.

For example, for $\Sigma$-introduction
\begin{mathpar}
\inferrule*[left=$\Sigma$-pair]{~}{\Gamma, A, B \qyields \mathsf{pair}_{A, B} : (\Sigma_A B)[\proj{\Gamma, A, B};\proj{\Gamma, A}]}
\end{mathpar}
the central steps in the derivation are as follows:
\begin{mathpar}
\inferrule*[Left=rewrite]{
\inferrule*[Left=cut]{
\inferrule*[Left=F-intro]
{\alpha : \upstairs{\Gamma}, x : \upstairs{A}, y : \upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta] \yields_{(x, y)} (x, y) : \telety{x}{\upstairs{A}}{\upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta]}}
{\alpha : \upstairs{\Gamma}, x : \upstairs{A}, y : \upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta] \yields_{\Sigma_1(\alpha, x, y)} \FI{x, y} : \F{w. \Sigma_1(\alpha,\fst w, \snd w)}{\telety{x}{\upstairs{A}}{\upstairs{B}[\StI{\chi}{(\alpha, x)}/\beta]}}}}
{\delta : \upstairs{\Gamma,A,B} \yields_{\Sigma_1(\delta, \One_\delta, \One_{\delta.\One})} \FI{x, y}[\dots/\alpha,x,y] : \upstairs{(\Sigma_A B)[\proj{\Gamma, A, B};\proj{\Gamma, A}]}}}
{\delta : \upstairs{\Gamma,A,B} \yields_{\One_\delta} \rewrite{\contract{\delta}}{\FI{x, y}[\dots/\alpha,x,y]} : \upstairs{(\Sigma_A B)[\proj{\Gamma, A, B};\proj{\Gamma, A}]}}
\end{mathpar}
where we have omitted the particular substitution required here. 
\end{itemize}