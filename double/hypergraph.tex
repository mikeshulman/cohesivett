\documentclass{article}
\usepackage{amsthm,hyperref,mathtools,mathpartir,cleveref,mathrsfs,amssymb,url,paralist,xspace,braket,ifmtarg}
\usepackage[status=draft]{fixme}
\newtheorem{thm}{Theorem}[section]
\crefname{thm}{Theorem}{Theorems}
\newtheorem{lem}[thm]{Lemma}
\crefname{lem}{Lemma}{Lemmas}
\newtheorem{cor}[thm]{Corollary}
\crefname{cor}{Corollary}{Corollaries}
\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\crefname{defn}{Definition}{Definitions}
\newtheorem{defns}[thm]{Definitions}
\crefname{defns}{Definitions}{Definitions}
\newtheorem{eg}[thm]{Example}
\crefname{eg}{Example}{Examples}
\theoremstyle{remark}
\newtheorem{rmk}[thm]{Remark}
\crefname{rmk}{Remark}{Remarks}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{decorations.markings}
\tikzset{edge/.style={decoration={markings,mark=at position 0.5 with {\arrow{>}}},postaction={decorate}}}
\tikzset{vertex/.style={circle,draw,inner sep=1pt}}
\usetikzlibrary{shapes.geometric}
\tikzset{outer/.style={regular polygon,regular polygon sides=3,inner sep=1pt,draw,shape border rotate=180}}
\tikzset{houter/.style={regular polygon,regular polygon sides=3,inner sep=1pt,draw,shape border rotate=270}}
\tikzset{cross/.style={white,line width=3pt}}
\let\sto\looparrowright
\def\M{\mathcal{M}}
\def\A{\mathcal{A}}
\def\B{\mathcal{B}}
\def\C{\mathcal{C}}
\def\P{\mathcal{P}}
\def\Q{\mathcal{Q}}
\def\D{\mathcal{D}}
\def\G{\mathcal{G}}
\def\H{\mathcal{H}}
\def\K{\mathcal{K}}
\def\L{\mathcal{L}}
\def\R{\mathcal{R}}
% \def\Cat{\ensuremath{\mathcal{C}\mathit{at}}}
\let\setof\Set
\def\Set{\mathbf{Set}}
\def\Cat{\ensuremath{\mathbf{Cat}}}
\def\Fib{\mathcal{F}\mathit{ib}}
\def\Prof{\mathcal{P}\mathit{rof}}
\def\cpg{\ensuremath{\mathbf{CPG}}\xspace}
\def\dom{\mathrm{dom}}
\def\cod{\mathrm{cod}}
\def\id{\mathrm{id}}
\def\side#1{{\scriptstyle(#1)}}
\def\sid{\side{\id}}
% \def\twocell#1#2#3#4{\inferrule*[Left={$\side{#1}$},Right={$\side{#4}$}]{#2}{#3}}
% \def\twocelll#1#2#3#4{\inferrule*[left={$\side{#1}$},Right={$\side{#4}$}]{#2}{#3}}
% \def\twocellr#1#2#3#4{\inferrule*[Left={$\side{#1}$},right={$\side{#4}$}]{#2}{#3}}
% \def\twocelllr#1#2#3#4{\inferrule*[left={$\side{#1}$},right={$\side{#4}$}]{#2}{#3}}

\def\op{^{\mathrm{op}}}
\def\lan{\operatorname{Lan}}

\newcounter{nodemaker}
\setcounter{nodemaker}{0}
\def\twocell#1{%
  \global\edef\mynodeone{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \global\edef\mynodetwo{twocell\arabic{nodemaker}}%
  \stepcounter{nodemaker}%
  \ar[#1,phantom,shift left=3,""{name=\mynodeone}]%
  \ar[#1,phantom,shift right=3,""'{name=\mynodetwo}]%
  \ar[Rightarrow,from=\mynodeone,to=\mynodetwo]%
}
\newcommand{\drpullback}[1][dr]{\ar[#1,phantom,near start,"\lrcorner"]}
\newcommand{\dlpullback}[1][dl]{\ar[#1,phantom,near start,"\llcorner"]}
\newcommand{\urpullback}[1][ur]{\ar[#1,phantom,near start,"\urcorner"]}
\newcommand{\ulpullback}[1][ul]{\ar[#1,phantom,near start,"\ulcorner"]}

\let\ot\leftarrow
\let\xto\xrightarrow
\let\xot\xleftarrow
\let\tot\leftrightarrow
\def\o{^{\circ}}
\tikzset{horiz/.style={"\mathclap\bullet" description}}
\def\genus{\mathsf{genus}}
\def\degree{\mathsf{degree}}
\def\rank{\mathsf{rank}}
\def\N{\mathbb{N}}
\def\Np{\N_{\bullet}}
% \def\hy{\mathcal{H}\mathit{y}\mathcal{G}\mathit{ph}}
\def\hyrel{\mathcal{H}\mathit{y}\mathcal{R}\mathit{el}}
\def\hy{\mathbf{HyGph}}
\def\RGph{\mathbf{RGph}}
\def\GCtx{\mathbf{GCtx}}
\def\hohy{\mathbf{HyGph}}
\def\thy{\mathcal{T}}
\def\dhy{\mathcal{D}}
\def\fhy{\mathcal{F}}
\def\ehy{\mathcal{E}\mathit{xt}\mathcal{H}\mathit{y}\mathcal{G}\mathit{ph}}

\makeatletter
\def\ins#1#2#3#4{#1 \underset{\@ifmtarg{#2}{#3}{#3\in #2}}{\circ} #4}
\def\insy{\circ}
\makeatother
\def\bE{\mathbf{E}}
\def\bC{\ensuremath{\mathbf{C}}\xspace}
\def\bS{\ensuremath{\mathbf{S}}\xspace}
\def\Ebar{\overline{\mathbf{E}}}
\def\Gbar{\overline{\mathcal{G}}}
\def\Cbar{\overline{\mathcal{C}}}
\def\Hbar{\overline{\mathcal{H}}}
\def\Kbar{\overline{\mathcal{K}}}
\def\Lbar{\overline{\mathcal{L}}}
\def\dhybar{\overline{\mathcal{D}}}

\def\ec{\diamond}
\def\edgectx{\;\mathsf{edgectx}}
\def\loopctx{\;\mathsf{loopctx}}
\def\vertex{\;\mathsf{vertex}}
\def\ctx{\;\mathsf{ctx}}
\def\graph{\;\mathsf{graph}}
\def\type{\;\mathsf{type}}
\let\types\vdash
\let\jdeq\equiv

\hyphenation{hyper-graph}
\hyphenation{hyper-graphs}

\title{Hypercategories and some kind of type theory}
\author{Dan Licata \and\ Mitchell Riley \and\ Patrick Schultz \and\ Michael Shulman}
\begin{document}
\maketitle

\section{Hypergraphs}
\label{sec:hypergraphs}

Intuitively, a hypergraph is like a graph, but where an ``edge'' can be incident to any number of vertices, not only two.
An incidence between a vertex and an edge is called a \emph{flag}.
For directed hypergraphs, which we will mainly be concerned with, each flag is marked as ``incoming'' or ``outgoing'' (to the associated vertex).
When drawing a hypergraph, we draw vertices as dots and edges as lines connecting them, which are allowed to ``branch'' in order to connect more than two vertices.
Here is an example:
\[
\begin{tikzpicture}
  \node[vertex] (f) at (0,1) {$f$};
  \node[vertex] (g) at (0,-1) {$g$};
  \node[vertex] (h) at (2,0) {$h$};
  \coordinate (e) at (1,0);
  \draw[edge] (f) to[out=0,in=180] (e);
  \draw[edge] (g) to[out=30,in=180] (e);
  \draw[edge] (e) to[out=0,in=180] node[auto] {$e_1$} (h);
  \coordinate (e2) at (1,2);
  \draw[edge] (h) to[out=30,in=0] node[auto,swap] {$e_2$} (e2);
  \draw[edge] (e2) to[out=180,in=180,looseness=2] (g);
  \coordinate (e3) at (3,-1);
  \draw[edge] (h) to[out=-30,in=180] (e3);
  \draw[edge] (g) to[out=-30,in=180] node[auto,swap] {$e_3$} (e3);
  \draw[edge] (h) -- node[auto,very near end] {$e_4$} +(1,0);
  \draw[edge] (f) to[out=-60,in=-120,looseness=5] node[auto] {$e_5$} (f);
  \draw (-1,-.5) -- node[auto] {$e_6$} (0,-.5);
\end{tikzpicture}
\]
Here $e_1$ is incident to $f$ and $g$ outgoing and to $h$ incoming, $e_2$ is adjacent to $h$ outgoing and $g$ incoming, $e_3$ is adjacent to $g$ and $h$ both outgoing, $e_4$ is adjacent to only $h$ outgoing, $e_5$ is adjacent to $f$ once outgoing and once incoming, and $e_6$ is not adjacent to any vertices at all.

There are many possible variations on hypergraphs.
Unlike in the combinatorial literature, but like the ``graphs'' usually used in category theory, our edges are not uniquely determined by the vertices they are incident to, i.e.\ we can have ``parallel edges''.
Also, we will assume that each vertex is incident to a finite set of edges, but in general place no such restriction on the edges; this will be convenient because it makes polygraphs a special case of directed hypergraphs.

We will also allow edges to contain ``loops''.
In particular, this distinguishes between the following two edges, neither of which is adjacent to any vertices, but of which one contains a loop and one does not:
\[
\begin{tikzpicture}
  \draw (0,0) -- (1,0);
  \draw (3,0) to[out=90,in=90,looseness=2] (4,0) to[out=-90,in=-90,looseness=2] (3,0);
\end{tikzpicture}
\]
Moreover, the hyper-ness of our graphs means that once we allow loops, we need to allow edges adjacent to vertices to also contain loops, and some edges to contain multiple loops.
The presence of loops turns out to make the definition of hypergraph very tricky to get right, in particular as regards the notion of morphism between such graphs.

First I tried just marking each edge with a natural number ``genus''; but in defining labeled hypergraphs as morphisms we need to be able to collapse loops, and automorphisms of hypergraphs need to be able to permute loops.
Then I thought of just assigning to each edge a pointed set of ``loops'', but when inserting one hypergraph into another we can create ``loops'' of a sort for which there is no obvious way to choose a ``basepoint'' to get an actual ``set of loops''; what arises naturally is a directed graph, or equivalently a free groupoid.
So I tried defining a hypergraph to have a (free) groupoid of edges rather than a set; but free groupoids have too many automorphisms.
At present the most promising approach seems to be to define a hypergraph to have a reflexive directed graph of edges, although the treatment of isomorphisms is still not completely satisfactory.

\begin{defn}
  A \textbf{hypergraph} $\G$ is a span
  \[ V \ot F \to E \]
  in which $V$ and $F$ are sets, each fiber of the map $F\to V$ is a finite set equipped with a linear ordering, and $E$ is a reflexive directed graph (with $F$ mapping into its vertices).

  The vertices of $E$ are called \textbf{edge representatives} of $\G$, the edges of $E$ are called \textbf{edge identifications} of $\G$, and the connected components of $E$ are called the \textbf{edges} of $\G$.
  The elements of $V$ are called the \textbf{vertices} of $\G$, and those of $F$ are called its \textbf{flags}.
  If a vertex and an edge (representative) are the image of a common flag, we say they are \textbf{incident}; thus the flags are the ``witnesses of incidence''.
  We also speak of a flag as being \textbf{incident} to its associated edge (representative) and vertex.
\end{defn}

We allow vertices that are not incident to any edges, and edges that are not incident to any vertices.
Also a vertex and an edge can be ``incident more than once'', i.e.\ the image of more than one common flag.

We write $\pi E$ for the set of edges, i.e.\ the set of connected components of $E$.

\begin{defn}
  Let $\G=(V\ot F\to E)$ be a hypergraph.
  \begin{itemize}
  \item The \textbf{degree} of a vertex in $\G$ is the cardinality of the set of flags adjacent to it, which is a natural number.
    The \textbf{rank} of an edge in $\G$ is the cardinality of the set of flags adjacent to it, which in general can be finite or infinite.
    We say $\G$ %has \textbf{finite rank} if all its ranks are finite, and $\G$
    is \textbf{finite} if $V$ and $E$ (hence also $F$) are finite.
  \item The free rank of the fundamental group of an edge (meaning that of its geometric realization, considered as a 1-truncated simplicial set, or equivalently of the free groupoid that it generates) is called its \textbf{genus}.
    We say $\G$ has \textbf{genus zero} if all of its edges have genus zero, i.e.\ $E$ is a forest.
  \item The \textbf{connected components} of $\G$ are the connected components of the groupoid pushout of the span $V \leftarrow F \to \pi E$.
    We say $\G$ is \textbf{connected} if it has exactly one connected component.
    % In particular, vertices not incident to any edges, and edges not incident to any vertices, lie in their own connected components.
  \item We say $\G$ is \textbf{simple} if no edge is incident to any vertex more than once, so that the span $V \ot F \to \pi E$ is a relation.
  \item We say $\G$ is \textbf{reduced} if every edge has exactly one representative.
  \end{itemize}
\end{defn}

The (directed) hypergraphs of~\cite{glpn:directed-hypergraphs} are our (directed) finite simple reduced hypergraphs of genus zero, but without the orderings on the flags adjacent to each vertex.
We include the orderings because we eventually want a correspondence to linear syntax, and to definitions of prop and polycategory using ordered lists of objects, but they are not essential to the theory.

\begin{defn}
  A \textbf{morphism of hypergraphs} is a diagram
  \[
  \begin{tikzcd}
    V' \ar[d] & F' \ar[d] \ar[r] \ar[l] \dlpullback[dl] & E' \ar[d]\\
    V  & F \ar[r] \ar[l] & E
  \end{tikzcd}
  \]
  in which the left-hand square is a pullback and preserves the linear orderings on the fibers.
  This defines the category $\hy$.
\end{defn}

The fact that the left-hand square is a pullback means in particular that a morphism of hypergraphs preserves the degree of vertices.
However, it does not preserve the rank or the genus of edges.

Let $\Np$ be the set $\setof{(k,n) \in \N\times \N | k<n}$, with $\ell:\Np\to \N$ the second projection.
Thus the fiber of $\ell$ over $n\in\N$ is the canonical $n$-element linear order.
Let $P_\ell$ be the polynomial endofunctor of $\Set$ defined by $\ell$, i.e.\ the composite
\[ \Set \xto{(\Np)^*} \Set/\Np \xto{\Pi_\ell} \Set/\N \xto{\Sigma_\N} \Set.\]
Thus an element of $P_\ell(E)$ is a finite list of elements of $E$.

Let $\RGph$ denote the category of reflexive directed graphs, with $U:\RGph\to\Set$ the functor taking the underlying set of vertices.

\begin{lem}
  The category $\hy$ of hypergraphs is equivalent to the comma category
  \[
  \begin{tikzcd}
    \hy \ar[rr] \ar[d] \twocell{drr} && \Set \ar[d,equals] \\
    \RGph \ar[r,"U"'] & \Set \ar[r,"P_\ell"'] & \Set.
  \end{tikzcd}
  \]
\end{lem}
\begin{proof}
  An object of the comma category consists of a reflexive graph $E$ together with a set $V$ and a map $V \to P_\ell U E$.
  By definition of $P_\ell$, the latter map is equivalent to a map $f:V\to \N$ together with a map $f^*\Np \to UE$.
  And the set of maps $f:V\to\N$ is equivalent to the groupoid of maps $F\to V$ with finite linearly ordered fibers (via the equivalence $F=f^*\Np$), so this corresponds exactly to the above definition of a hypergraph.

  A morphism in the comma category consists of a map $E'\to E$ of reflexive graphs and a map $V'\to V$ making the evident square commute.
  The composite $V'\to V\to P_\ell U E$ corresponds to precomposing the maps $V' \to V \to \N$, which means taking the pullback
  \[
  \begin{tikzcd}
    V' \ar[d] & F' \dlpullback \ar[d] \ar[l] \ar[dr] \\
    V & F \ar[l] \ar[r] & U E
  \end{tikzcd}
  \]
  Whereas the composite $V' \to P_\ell U E' \to P_\ell U E$ corresponds to taking the composite
  \[
  \begin{tikzcd}
    V' & F' \ar[l] \ar[r] \ar[dr] & U E' \ar[d] \\
    && U E
  \end{tikzcd}
  \]
  Thus saying that they are equal reproduces exactly the above definition of hypergraph morphism.
\end{proof}

\begin{cor}
  $\hy$ is a presheaf topos.
  In particular, it is complete and cocomplete.
\end{cor}
\begin{proof}
  The functor $P_\ell \circ U : \RGph \to \Set$ is a parametric right adjoint, since $P_\ell$ is a polynomial functor and $U$ is a right adjoint.
  Thus, since $\RGph$ is a presheaf topos, by~\cite{cj:clfrag} the comma category $\hy$ is again a presheaf topos.
\end{proof}

In the comma category presentation, the terminal hypergraph $\thy$ has $E$ the terminal reflexive graph, with $V = P_\ell U E = P_\ell 1$ with $V\to P_\ell U E$ the identity.
That is, there is exactly one edge representative and only its reflexivity identification, and for each natural number $n$ there is exactly one vertex adjacent to the unique edge representative $n$ times.

Let $\dhy$ denote the hypergraph with $E=1$ and $V=\N\times \N$, with the vertex $(n,m)$ having $n+m$ flags, which we think of as partitioned into the first $k$ elements and the last $n-k$ elements.

\begin{defn}
  The category of \textbf{directed hypergraphs} is the slice category $\hy/\dhy$.
\end{defn}

Thus, a directed hypergraph is a hypergraph in which at each vertex the list of adjacent flags is partitioned into two linear orders, which we call the \textbf{incoming} and \textbf{outgoing} flags respectively.
The numbers of incoming and outgoing flags are respectively called the \textbf{in-degree} and \textbf{out-degree} of the vertex.
Similarly, the \textbf{in-rank} and \textbf{out-rank} of an edge are respectively the cardinalities of the sets of outgoing (from their vertices, hence incoming to the edge) and incoming (to their vertices, hence outgoing from the edge) flags adjacent to it.

The unique projection $\dhy\to\thy$ to the terminal object has a section $\thy\to\dhy$ that sends the vertex $n$ to $(0,n)$.
Thus, we have
\[\hy \simeq \hy/\thy \simeq (\hy/\dhy)/(\thy\to\dhy).\]
In other words, arbitrary hypergraphs can also be regarded as particular directed ones, namely those in which all flags are outgoing.
These equivalences make the directed and undirected cases almost interchangeable, which is one advantage of hypergraphs over ordinary graphs.
Another is the ease of the following definitions.

\begin{defn}
  A reduced hypergraph of genus zero is called a \textbf{cycligraph}.
  A directed cycligraph is called a \textbf{polygraph}.
  A polygraph in which each vertex has out-degree equal to 1 is a \textbf{multigraph}.

  In all of these cases, the edges are called \textbf{objects} and the vertices are called \textbf{morphisms}.
\end{defn}

A polygraph is the underlying data of a polycategory or a (colored) prop: each morphism has a finite list of ``source'' objects and a finite list of ``target'' objects.
Similarly, a multigraph is the underlying data of a multicategory: each morphism has a finite list of source objects and a single target object.
And a cycligraph is the underlying data of a cyclic multicategory, in which sources and targets are not distinguished; we speak instead of the \textbf{legs} of a morphism.

Our graph-theoretic representation of these objects invokes the Poincar\'e dual ``string diagram convention'', in which objects are 1-dimensional and morphisms are 0-dimensional.
The categories of cycligraphs, polygraphs, and multigraphs are presheaf toposes.
Also, cycligraphs are a reflective subcategory of $\hy$, and polygraphs are a reflective subcategory of $\hy/\dhy$.

The above definitions of cycligraphs, polygraphs, and multigraphs make the following definitions very easy.

\begin{defn}\label{thm:labeled}
  If $P$ is a cycligraph, then a \textbf{$P$-labeled hypergraph} is a hypergraph $\G$ equipped with a hypergraph morphism $\G\to P$.
\end{defn}

Note that if $P$ is a polygraph, it is by definition simply a cycligraph equipped with a morphism $P\to \dhy$.
Therefore, for any $P$-labeled hypergraph $\G\to P$ in the above sense, the composite $\G\to P\to\dhy$ automatically makes $\G$ a directed hypergraph and $\G\to P$ a directed hypergraph morphism.
So the directed case is subsumed by the undirected one.

Other conditions on hypergraphs are not as naturally expressed categorically.
For instance:

\begin{defn}
  A hypergraph is \textbf{rooted} if it is equipped with a specified vertex called the \textbf{root}.
\end{defn}

In general, we think of the root as ``not really there'' and the flags adjacent to it as ``free''.
In a directed rooted hypergraph, we think of the incoming or outgoing edges of the root as ``incoming/outgoing to the entire graph''.
For instance, given the graph on the left with $\ast$ the root:
\begin{equation}
  \begin{tikzpicture}
    \node[vertex] (r) at (0,0) {$\ast$};
    \node[vertex] (f) at (2,1) {$f$};
    \node[vertex] (g) at (1,-1) {$g$};
    \node[vertex] (h) at (3,-1) {$h$};
    \draw[edge] (1,2) to[out=-90,in=90] (f);
    \draw[edge] (1,2) to[out=-90,in=90] node[auto,swap] {$e_1$} (r);
    \draw[edge] (r) to[out=-90,in=90] (3,-3);
    \draw[edge] (h) to[out=-90,in=90] node[auto] {$e_5$} (3,-3);
    \draw[cross] (g) to[out=-90,in=90] (1,-3);
    \draw[edge] (g) to[out=-90,in=90] (1,-3);
    \draw[edge] (r) to[out=-90,in=90] node[auto,swap] {$e_4$} (1,-3);
    \draw[edge] (f) to[out=-90,in=90] node[auto,swap] {$e_2$} (g);
    \draw[edge] (f) to[out=-90,in=90] node[auto] {$e_3$} (h);
  \end{tikzpicture}
  \qquad
  \begin{tikzpicture}
    \node[outer] (e1) at (2,2) {};
    \node[vertex] (f) at (2,1) {$f$};
    \node[vertex] (g) at (1,-1) {$g$};
    \node[vertex] (h) at (3,-1) {$h$};
    \node[outer] (e4) at (1,-3) {};
    \node[outer] (e5) at (3,-3) {};
    \draw[edge] (e1) to[out=-90,in=90] node[auto,swap] {$e_1$} (f);
    \draw[edge] (h) to[out=-90,in=90] node[auto] {$e_5$} (e5);
    \draw[edge] (g) to[out=-90,in=90] node[auto,swap] {$e_4$} (e4);
    \draw[edge] (f) to[out=-90,in=90] node[auto,swap] {$e_2$} (g);
    \draw[edge] (f) to[out=-90,in=90] node[auto] {$e_3$} (h);
  \end{tikzpicture}\label{eq:rooted-graph}
\end{equation}
we think of the edge $e_1$ as ``incoming to the graph'' and the edges $e_4,e_5$ as ``outgoing from the graph'', as drawn above on the right.

Note that an edge like $e_1$ that is ``incoming to the graph'' is \emph{incoming} to the root (as well as to other vertices like $f$), and one like $e_4$ or $e_5$ that is ``outgoing from the graph'' is \emph{outgoing} from the root (as well as from other vertices such as $g$ or $h$).
This choice, which as we will see makes the definition of insertion somewhat simpler, is only possible when using \emph{hyper}graphs, where edges can be incoming to multiple vertices and outgoing from multiple vertices.

% \begin{defn}\label{defn:loop}
%   A \textbf{loop} in a directed hypergraph is a sequence of flags
%   \[(f_0,g_0,f_1,g_1,\dots,f_n,g_n),\]
%   for $n\ge 0$, such that
%   \begin{enumerate}
%   \item Each $f_i,g_i$ are incident on the same edge, and
%   \item Each $g_i,f_{i+1}$ (including $g_n,f_0$ by mod-$n$ arithmetic) are incident on the same vertex, with $g_i$ incoming and $f_{i+1}$ outgoing.
%   \end{enumerate}
%   In particular, a loop with $n=0$ is an edge that is both incoming and outgoing to the same vertex.
%   A directed hypergraph is \textbf{loop-free} if it contains no loops.
% \end{defn}

% The left-hand rooted graph in~\eqref{eq:rooted-graph} is loop-free, which makes sense when considering the right-hand ``graph with free flags'' that it represents.
% If we chose to represent edges ``incoming to the graph'' by edges \emph{outgoing} to the root, then we would have to represent the right-hand ``graph with free flags'' in~\eqref{eq:rooted-graph} by the following rooted graph:
% \begin{equation}
%     \begin{tikzpicture}
%     \node[vertex] (r) at (0,0) {$\ast$};
%     \node[vertex] (f) at (2,1) {$f$};
%     \node[vertex] (g) at (1,-1) {$g$};
%     \node[vertex] (h) at (3,-1) {$h$};
%     \draw[edge] (r) to[out=90,in=90] node[auto] {$e_1$} (f);
%     \draw[edge] (h) to[out=-90,in=-90,looseness=2] node[auto] {$e_5$} (r);
%     \draw[edge] (g) to[out=-90,in=-90] node[auto,very near start] {$e_4$} (r);
%     \draw[edge] (f) to[out=-90,in=90] node[auto,swap] {$e_2$} (g);
%     \draw[edge] (f) to[out=-90,in=90] node[auto] {$e_3$} (h);
%   \end{tikzpicture}\label{eq:loop}
% \end{equation}
% which is not loop-free according to \cref{defn:loop} as written; thus we would have had to special-case the root vertex in \cref{defn:loop}.
% In fact, we regard~\eqref{eq:loop} as representing the following ``graph with free flags'':
% \begin{equation}
%   \begin{tikzpicture}
%     \node[vertex] (f) at (2,1) {$f$};
%     \node[vertex] (g) at (1,-1) {$g$};
%     \node[vertex] (h) at (3,-1) {$h$};
%     \draw[edge] (1,2) to[out=-90,in=90] (f);
%     \draw[edge] (1,2) to[out=-90,in=90] node[auto,swap,near end] {$e_1$} (-1,-4);
%     \draw[edge] (5,3) to[out=-90,in=90] node[auto] {$e_5$} (3,-3);
%     \draw[edge] (h) to[out=-90,in=90] (3,-3);
%     \draw[edge] (g) to[out=-90,in=90] (1,-3);
%     \draw[cross] (-1,3) to[out=-90,in=90] (1,-3);
%     \draw[edge] (-1,3) to[out=-90,in=90] node[auto,swap,near start] {$e_4$} (1,-3);
%     \draw[edge] (f) to[out=-90,in=90] node[auto,swap] {$e_2$} (g);
%     \draw[edge] (f) to[out=-90,in=90] node[auto] {$e_3$} (h);
%   \end{tikzpicture}\label{eq:loops2}
% \end{equation}
% in which $e_4$ and $e_5$ are ``incoming to the graph'' and $e_1$ is ``outgoing from the graph''.
% We do want to consider~\eqref{eq:loops2} as containing ``loops'', because there are paths from ``in'' to ``out'' that travel some paths ``backwards''.\fxnote{Is that right?}

Note also that we allow edges that are not adjacent to any vertices, or that are adjacent to only one vertex, but are \emph{not} adjacent to the root and hence not ``incoming'' or ``outgoing'' to the graph.
The following example shows a number of distinct degenerate possibilities in a directed (reduced) hypergraph (where $\ast$ is the root):
\begin{center}
  \begin{tikzpicture}
    \node[vertex] (r) at (0,0) {$\ast$};
    \draw[edge] (r) to[out=-120,in=-90] +(-1,0) to[out=90,in=120] node[auto] {$e_1$} (r);
    \draw[edge] (1,1) to[out=-120,in=30] node[auto] {$e_2$} (r);
    \draw[edge] (r) to[out=-30,in=120] node[auto] {$e_3$} (1,-1);
    \node[vertex] (h) at (1,2) {$h$};
    \draw[edge] (h) to[out=-90,in=60] node[auto,swap,near start] {$e_6$} (r);
    \node[vertex] (k) at (1,-2) {$k$};
    \draw[edge] (r) to[out=-60,in=90] node[auto,swap,near end] {$e_7$} (k);
    \node[vertex] (m) at (0,2) {$m$};
    \draw[edge] (-1,1.5) to[out=0,in=-120] node[auto,near start] {$e_4$} (m);
    \draw[edge] (-1,1.5) to[out=0,in=90] (r);
    \node[vertex] (n) at (0,-2) {$n$};
    \draw[edge] (n) to[out=120,in=0] node[auto,swap,near start] {$e_5$} (-1,-1.5);
    \draw[edge] (r) to[out=-90,in=0] (-1,-1.5);
    \node[vertex] (f) at (2,0) {$f$};
    \draw[edge] (2,1) -- node[auto] {$e_8$} (f);
    \node[vertex] (g) at (3,0) {$g$};
    \draw[edge] (g) -- node[auto] {$e_9$} +(0,-1);
    \node[vertex] (l) at (4,0) {$l$};
    \draw (5,1) -- node[auto,near end] {$e_{10}$} (5,-1);
    \draw (6.5,0) to[out=90,in=90,looseness=1.5] node[auto,swap] {$e_{11}$} (6,0) to[out=-90,in=-90,looseness=1.5] (6.5,0);
    \draw (7.5,0) to[out=90,in=90,looseness=1.5] node[auto,swap] {$e_{12}$} (7,0) to[out=-90,in=-90,looseness=1.5] (7.5,0);
    \draw (7.5,0) to[out=90,in=90,looseness=1.5] (8,0) to[out=-90,in=-90,looseness=1.5] (7.5,0);
  \end{tikzpicture}
\end{center}
Here $e_{10}$, $e_{11}$, and $e_{12}$ are all edges not adjacent to any vertices, with genera 0, 1, and 2 respectively.
We did not draw any arrows on them because only flags, not edges, are directed as ``incoming'' or ``outgoing''.
When interpreted as incoming or outgoing to the entire graph, the edges $e_1$--$e_7$ adjacent to the root above would be drawn as follows (preserving the ordering on incoming and outgoing edges to the root by drawing the incoming and outgoing edges to the graph in the same order).
\begin{center}
  \begin{tikzpicture}
    \node[outer] (e1a) at (2,1) {};
    \node[outer] (e1b) at (2,-1) {};
    \draw[edge] (e1a) -- node[auto] {$e_1$} (e1b);
    \node[outer] (e2) at (8,1) {};
    \draw[edge] (e2) -- node[auto] {$e_2$} (8,0);
    \node[outer] (e3) at (9,-1) {};
    \draw[edge] (9,0) -- node[auto] {$e_3$} (e3);
    \node[vertex] (m) at (3,0) {$m$};
    \node[outer] (e4) at (3,1) {};
    \draw[edge] (e4) -- node[auto] {$e_4$} (m);
    \node[vertex] (n) at (4,0) {$n$};
    \node[outer] (e5) at (4,-1) {};
    \draw[edge] (n) -- node[auto] {$e_5$} (e5);
    \node[vertex] (h) at (5,.2) {$h$};
    \node[outer] (e6) at (5.5,1) {};
    \draw[edge] (e6) -- node[auto] {$e_6$} (5.5,-.7);
    \draw[edge] (h) to[out=-90,in=90]  (5.5,-.7);
    \node[vertex] (k) at (6.5,-.2) {$k$};
    \node[outer] (e7) at (7,-1) {};
    \draw[edge] (7,.7) -- node[auto] {$e_7$} (e7);
    \draw[edge] (7,.7) to[out=-90,in=90] (k);
  \end{tikzpicture}
\end{center}

We note that there are many ways in which a hypergraph can have nontrivial automorphisms.
One simple example is the graph with two vertices and no edges:
\begin{center}
\begin{tikzpicture}
  \node[circle,fill,inner sep=1pt] at (0,0) {};
  \node[circle,fill,inner sep=1pt] at (1,0) {};
\end{tikzpicture}
\end{center}
in which the two vertices can be swapped by an automorphism.
However, it is not necessary to be disconnected to have nontrivial automorphisms:
\begin{center}
  \begin{tikzpicture}[scale=2]
    \node[vertex] (f) at (0,0) {$f$};
    \node[vertex] (g) at (1,0) {$g$};
    \node[vertex] (h) at (0,1) {$h$};
    \node[vertex] (k) at (1,1) {$k$};
    \draw[edge] (h) to[out=-120,in=120] (f);
    \draw[edge] (k) to[out=-60,in=30,looseness=2] (f);
    \draw[cross] (h) to[out=-60,in=60] (g);
    \draw[edge] (h) to[out=-60,in=60] (g);
    \draw[cross] (k) to[out=-120,in=120] (g);
    \draw[edge] (k) to[out=-120,in=120] (g);
  \end{tikzpicture}
\end{center}
Here there is an automorphism that swaps $f$ with $g$ and swaps $h$ with $k$.
Moreover, if we orient this graph by giving the edges the left-to-right ordering in the picture, then this automorphism preserves the orientation.
This example cannot be rooted (the automorphism has no fixed points) --- or more precisely, it cannot occur in the connected component of the root --- but if we use edges that are incident on more than two vertices then we can have nontrivial automorphisms with fixed points:
\begin{center}
  \begin{tikzpicture}
    \node[vertex] (f) at (0,0) {$\ast$};
    \node[vertex] (g) at (1,2) {$g$};
    \node[vertex] (h) at (-1,2) {$h$};
    \draw[edge] (g) to[out=-90,in=90] (0,1);
    \draw[edge] (h) to[out=-90,in=90] (0,1);
    \draw[edge] (0,1) -- (f);
  \end{tikzpicture}
\end{center}
Here there is an automorphism that swaps $g$ and $h$ and fixes the root $\ast$.
The most restrictive thing we can say about about automorphisms is the following.

\begin{defn}
  A hypergraph is \textbf{binary}, or simply a \textbf{graph}, if % for each edge $e$ we have
  % \[ \rank(e) + 2 \cdot \genus(e)  = 2, \]
  % i.e.\ if
  every edge either has rank 2 and genus 0, or rank 0 and genus 1.
\end{defn}

Amusingly, this condition can be reformulated by saying that the rank of an edge is the same as its ``Euler characteristic'' $\chi=2-2g$.

\begin{lem}
  A connected rooted directed reduced binary hypergraph of genus zero has no nontrivial automorphisms.
\end{lem}
\begin{proof}
  Suppose $\phi$ is an automorphism of $\G$.
  By assumption, it must preserve the root.
  Since it is locally-ordered, it must preserve all edges adjacent to the root.
  But since each of those edges is adjacent to exactly one other vertex, it must preserve those vertices too.
  Proceeding inductively we find that it must preserve all edges and vertices in the connected component of the root, which is all of them since the graph is connected.
  Finally, since $\G$ is reduced and of genus zero, preserving all the edges means that it is the identity on the reflexive graph $E$.
\end{proof}

The presence of nontrivial automorphisms means that in general, we cannot simply ``pass to isomorphism classes'' of hypergraphs, and thus structures over hypergraphs are not definable using ``set-based shapes'', such as polynomial monads on the category of polygraphs.
In~\cite{bb:htapm} isomorphism classes and polynomial monads are shown to work for certain subclasses of graphs, but even when it works such a restriction is technical and error-prone.
Thus, we will generally work instead with categories and groupoids, never passing to isomorphism classes, and using a pseudomonad rather than a strict one.

% The directed version of the binary condition is a little kludgy to state due to our convention about the orientations of flags adjacent to the root.

% \begin{defn}
%   Let $\G$ be a directed rooted hypergraph.
%   \begin{enumerate}
%   \item $\G$ is \textbf{weakly binary} if it is binary (in the undirected sense) and moreover every edge not adjacent to the root has equal in-rank and out-rank (i.e.\ either both 1 or both 0).
%   \item $\G$ is \textbf{strongly binary} if it is binary (in the undirected sense) and moreover if we switched the direction of all flags adjacent to the root then every edge would have equal in-rank and out-rank.
%   \end{enumerate}
% \end{defn}

% Here is an example of a strongly binary directed rooted hypergraph:
% \[
% \begin{tikzpicture}
%   \node[vertex] (f) at (0,0) {$f$};
%   \node[vertex] (g) at (1,-1) {$g$};
%   \node[vertex] (h) at (0,-2) {$h$};
%   \node[outer] (in1) at (0,1) {};
%   \node[outer] (in2) at (2,1) {};
%   \node[outer] (in3) at (1,1) {};
%   \node[outer] (out2) at (2,-3) {};
%   \node[outer] (out3) at (1,-3) {};
%   \node[outer] (out1) at (0,-3) {};
%   \draw[edge] (f) -- (g);
%   \draw[edge] (in1) -- (f);
%   \draw[edge] (g) -- (h);
%   \draw[edge] (f) -- (h);
%   \draw[edge] (h) -- (out1);
%   \draw[edge] (in3) -- (g);
%   \draw[edge] (in2) -- (out2);
%   \draw[edge] (h) -- (out3);
% \end{tikzpicture}
% \]
% Here is one that is weakly binary but not strongly binary:
% \[
% \begin{tikzpicture}
%   \node[vertex] (f) at (0,0) {$f$};
%   \node[vertex] (g) at (1,-1) {$g$};
%   \node[vertex] (h) at (0,-2) {$h$};
%   \node[outer] (in1) at (0,1) {};
%   \node[outer] (in2) at (3,1) {};
%   \node[outer] (in4) at (2,1) {};
%   \node[outer] (in3) at (1,1) {};
%   \node[outer] (out2) at (3,-4) {};
%   \node[outer] (out3) at (1,-4) {};
%   \node[outer] (out4) at (2,-4) {};
%   \node[outer] (out1) at (0,-4) {};
%   \draw[edge] (f) -- (g);
%   \draw[edge] (in1) -- (f);
%   \draw[edge] (g) -- (h);
%   \draw[edge] (f) -- (h);
%   \draw[edge] (h) -- (out1);
%   \draw[edge] (in3) -- (g);
%   \draw[edge] (in2) -- (out2);
%   \coordinate (four) at (1,-3);
%   \draw[edge] (h) to[out=-90,in=90] (four);
%   \draw[edge] (in4) to[out=-90,in=90] (four);
%   \coordinate (five) at (2,-3);
%   \draw[edge] (five) to[out=-90,in=90] (out3);
%   \draw[edge] (five) to[out=-90,in=90] (out4);
% \end{tikzpicture}
% \]
% And here is a directed rooted hypergrah that is binary in the undirected sense, but not even weakly binary in the directed sense:
% \[
% \begin{tikzpicture}
%   \node[vertex] (f) at (0,0) {$f$};
%   \node[vertex] (g) at (1,-1) {$g$};
%   \node[vertex] (h) at (0,-2) {$h$};
%   \node[outer] (in1) at (0,1) {};
%   \node[outer] (in3) at (1,1) {};
%   \node[outer] (out3) at (1,-4) {};
%   \node[outer] (out1) at (0,-4) {};
%   \draw[edge] (f) -- (g);
%   \draw[edge] (in1) -- (f);
%   \draw[edge] (g) -- (h);
%   \draw[edge] (h) -- (out1);
%   \draw[edge] (in3) -- (g);
%   \draw[edge] (h) -- (out3);
%   \coordinate (two) at (-1,-3);
%   \draw[edge] (f) to[out=-90,in=90] (two);
%   \draw[edge] (h) to[out=-120,in=90] (two);
% \end{tikzpicture}
% \]

We end this section by comparing our graphs to others in the literature.
Graphs with ``free flags'' have been used in defining many kinds of operads, but usually only of the binary sort, corresponding to non-cartesian multicategories and operads.

In a reduced binary rooted hypergraph, we can define an involution on the set of flags not adjacent to the root by sending each flag to the other flag of its corresponding edge, if that flag is not adjacent to the root, or to itself otherwise.
The quotient of this involution is then isomorphic to the set of edges that are adjacent to some non-root vertex.
Thus, we can equivalently define a binary rooted hypergraph by giving
\begin{itemize}
\item a set $F$ of flags (the flags not adjacent to the root),
\item an involution on $F$,
\item a set of ``exceptional linear edges'' (the edges adjacent to the root twice),
\item a set of ``exceptional loops'' (the edges not adjacent to any vertex --- the only ones with genus 1), and
\item a set $V$ of (non-root) vertices and a function $F\to V$ with finite linearly ordered fibers (equivalently, a ``partition'' of $F$ into finite linearly ordered blocks, some of which are allowed to be empty).
\end{itemize}
This is the definition of ``graph'' used commonly in operad theory, e.g.~\cite{bm:gen-opds,km:gwcqceg,costello:ainf,mms:wheeled-props,gk:modular-operads}, although often exceptional loops and edges are omitted or treated inconsistently.

Alternatively, if we remove the root but not the flags adjacent to it, then the function $F\to V$ becomes a partial function, which is defined on a flag just when that flag is not adjacent to the root.
Now we still have the exceptional edges (those adjacent to two flags that are not adjacent to any vertices) and the exceptional loops (those not adjacent to any flags).
This is essentially how binary rooted hypegraphs are encoded in~\cite{bb:htapm}, except that their exceptional loops are ``adjacent to a single flag twice'' rather than to no flags at all.

Another possibility is to express the partial function $F\rightharpoonup V$ as a relation, i.e.\ a span $F \ot H \to V$ in which $H\to F$ is injective.
If we exclude the possibility of exceptional loops, then the function $F\to E$ is a 2-to-1 surjection and hence can be encoded up to isomorphism by a fixed-point-free involution of $F$.
This is the definition of graph from~\cite{jk:feynman} (though they call the elements $H$ the ``flags'' and those of $F$ the ``(directed) edges'').
Their graph morphisms are similar to ours, although theirs are not required to preserve the ``degree of the root''.


\section{Type theory for hypergraphs}
\label{sec:tt-hy}

For all of this section, let $P$ be a fixed cycligraph; we will describe a type theory for $P$-labeled hypergraphs.
This includes unlabeled hypergraphs as the degenerate case when $P$ is terminal, and also the directed case if $P$ happens to be a polygraph or a multigraph.

An \textbf{edge context} $\Delta$ is a finite list of distinct variables, each labeled with an object of $P$ as its type.

\begin{mathpar}
  \inferrule{ }{\ec \edgectx}
  \and
  \inferrule{\Delta\edgectx \\ p\in P \\ x\notin \Delta}{(\Delta,x:p) \edgectx}
\end{mathpar}

A \textbf{loop context} $\Xi$ in an edge context $\Delta$ is a finite list of equalities between variables of the same type.

\begin{mathpar}
  \inferrule{ }{\Delta \types \ec\loopctx}
  \and
  \inferrule{\Delta\types\Xi\loopctx \\ (x:p)\in \Delta \\ (y:p)\in\Delta}{\Delta\types (\Xi,x\doteq y) \loopctx}
\end{mathpar}

A \textbf{vertex} in an edge context is a morphism of $P$ with variables of appropriate type assigned as its legs.

\begin{mathpar}
  \inferrule{\alpha\in P(p_1,\dots,p_n) \\ (x_i\in p_i)\in\Delta}{\Delta \types \alpha(x_1,\dots,x_n) \vertex}
\end{mathpar}

A \textbf{graph context} is an edge context, a loop context, and a finite list of variables assigned to vertices.

\begin{mathpar}
  \inferrule{\Delta \edgectx \\ \Delta\types \Xi\loopctx}{\Delta \mid\Xi\types \ec\graph}
  \and
  \inferrule{\Delta \mid\Xi\types \Gamma\graph \\ \Delta\types M\vertex \\ (f\notin \Gamma)}{\Delta\mid\Xi\types (\Gamma,f:M)\graph}
\end{mathpar}

\begin{thm}\label{thm:ctx-hy}
  A graph context determines, and is determined by, a finite $P$-labeled hypergraph $\G\to P$.
\end{thm}
\begin{proof}
  The variables in the edge context correspond to the edge representatives, and their assignment to types corresponds to the action of the labeling morphism $\G\to P$ on these.
  The equalities in the loop context correspond to non-reflexivity edges in the reflexive graph $E$.
  The variables in the graph context correspond to the vertices of $\G$, and their type assignment to a morphism of $P$ is the action of $\G\to P$ on vertices.
  Finally, the list of variables in a syntactic vertex $\alpha(x_1,\dots,x_n)$ specifies the flags of $\G$.
\end{proof}

In order to enhance \cref{thm:ctx-hy} to some sort of equivalence, we need to introduce morphisms between graph contexts.

\begin{defn}
  Given two graph contexts
  \begin{mathpar}
    \Delta\mid\Xi\types \Gamma\graph \and
    \Delta'\mid\Xi'\types \Gamma'\graph \and
  \end{mathpar}
  an \textbf{morphism} or \textbf{substitution} $\Gamma\to\Gamma'$ consists of:
  \begin{enumerate}
  \item A function $\sigma : \Delta' \to \Delta$ that respects types.
  \item A partial function $\tau : \Xi' \rightharpoonup \Xi$ such that
    \begin{enumerate}
    \item If $\tau(x\doteq y)$ is defined, then it is of the form $\sigma(x)\doteq \sigma(y)$.
    \item If $\tau(x\doteq y)$ is undefined, then $\sigma(x)=\sigma(y)$.
    \end{enumerate}
  \item A function $\nu : \Gamma' \to \Gamma$ that respects types modulo $\sigma$, i.e.\ if $f:\alpha(\vec x)$ then $\nu(f) : \alpha(\sigma(\vec x))$.
  \end{enumerate}
  This defines the category $\GCtx_P$ of $P$-labeled graph contexts.
\end{defn}

\begin{thm}
  There is an equivalence of categories
  \[ (\hy/P)\op \simeq \GCtx_P. \]
\end{thm}
\begin{proof}
  The contravariance of the equivalence is because context morphisms were defined to go the opposite way from their underlying functions on contexts (we think of the morphism as substituting $\sigma(x)$ for $x$ and so on).
  The function $\sigma$ corresponds to the map on edge representatives and the function $\nu$ corresponds to the map on vertices.
  The partial function $\tau$ corresponds to the action on edge identifications; where it is undefined, we send the corresponding edge to reflexivity.
\end{proof}

% In particular, note that self-equalities $(x\doteq x)$ in the loop context correspond to automorphisms in the groupoid $E$, hence to edges of nontrivial genus.
% Thus, it is only reasonable to simplify by substituting along equalities of \emph{distinct} variables:
% \begin{equation}\label{eq:subst}
%   \inferrule{\Delta,y:p\mid\Xi,x\doteq y \types \Gamma\graph \\ x\not\jdeq y}{\Delta\mid\Xi[x/y]\types \Gamma[x/y] \graph}
% \end{equation}
% This should change the corresponding hypergraph into an \emph{equivalent} one by contracting an object along an isomorphism.


\section{Insertion of hypergraphs}
\label{sec:insertion}

We now define an operation of \emph{insertion} of hypergraphs, which replaces some of the vertices in one graph by entire new graphs having the same ``flag structure''.
To clarify the abstract properties of this operation, we phrase it as a bicategorical composition.

\begin{defn}
  If $E_1 \xot{s} F \xto{t} E_2$ is a span of reflexive graphs in which $F$ is discrete (has only reflexivity edges), then its \textbf{collage} $E_1 *_F E_2$ is the disjoint union reflexive graph $E_1+E_2$ augmented by a new edge for each $x\in F$, attaching $s(x)$ to $t(x)$.
\end{defn}

\begin{defn}
  A \textbf{corolla} is a reduced hypergraph of genus zero of the form $1 \ot F = F$, i.e.\ having one vertex, each flag of which is adjacent to a unique edge.
  A disjoint union of corollas, i.e.\ a hypergraph of the form $V \ot F = F$, is called an \textbf{inflorescence}.\footnote{A corolla is the whorl of petals in a flower; an inflorescence is a cluster of flowers on a single stem.}
\end{defn}

Note that an inflorescence is uniquely determined, up to isomorphism, by giving a set of vertices and their degrees.

\begin{defn}
  A \textbf{laxly unital bicategory} is like a bicategory, but its unit transformations $f \circ 1_x \to f$ and $1_y\circ f \to f$ are not necessarily invertible (though it associativity isomorphisms are).
  We still ask for the same coherence axioms.
\end{defn}

\begin{thm}
  There is a laxly unital bicategory $\hyrel$ in which
  \begin{itemize}
  \item The objects are inflorescences.
  \item The morphisms are cospans $\A \to \G \ot \B$ of hypergraphs such that $(\A+\B) \to \G$ is bijective on vertices.
    Equivalently, they are simply hypergraphs $\G$ equipped with a partition of their vertices into two disjoint subsets; the inflorescences $\A$ and $\B$ are then uniquely determined.
  \item The composite $\G *_{\B} \H$ of $\A \to \G \ot \B$ and $\B \to \H \ot \C$ is defined to be
    \[ V_{\A}  + V_{\B} \longleftarrow F_{\A} + F_{\B} \longrightarrow E_{\G} *_{E_\B} E_{\H} \]
    In other words:
    \begin{enumerate}
    \item The vertices and flags of $\G *_{\B} \H$ the disjoint unions of those of $\A$ and those of $\C$.
    \item The reflexive graph of edges of $\G *_{\B} \H$ is the collage of those of $\G$ and $\H$ under that of $\B$.
      Thus, an edge representative is either one in $\G$ or one in $\H$, while an edge identification is either one in $\G$, one in $\H$, or one identifying the images in $\G$ and $\H$ of an edge in $\B$.
    \end{enumerate}
  \item The unit $1_{\A}$ of an inflorescence $\A=(V\ot F = F)$ is $V+V \ot F+F \to F$, with the two evident inclusions from $\A$.
  \end{itemize}
\end{thm}
\begin{proof}
  Associativity follows from the associativity of coproducts and collages.
  The latter means that if we have $E_1 \ot F_1 \to E_2 \ot F_2 \to E_3$ with $F_1,F_2$ discrete, then $(E_1 *_{F_1} E_2) *_{F_2} E_3 \cong E_1 *_{F_1} (E_2 *_{F_2} E_3)$, and the pentagon equation is satisfied if we have another span $E_3 \ot F_3 \to E_4$.
  This is a straightforward verification.

  The composite $1_{\A} *_{\A} \G$ has the same vertices and flags as $\G$ (up to isomorphism), but its edge graph has been augmented by a new edge representative $\bar{x}$ for each flag $x\in F_{\A}$, and new identifications connecting $\bar{x}$ to the edge representative adjacent to the image of $x$ in $\G$.
  Thus, it is not isomorphic to $\G$, but admits a map to $\G$ that contracts each of these new identifications to reflexivity.
  The other unit constraint is dual, and the coherence axiom is straightforward to check.
\end{proof}

The most common situation in which we apply this is the following.
Suppose $\G = (V\ot F \to E)$ is a hypergraph, and that for some subset $V_0 \subseteq V$ and each $v\in V_0$ we have a rooted hypergraph $\H_v = (V_v \ot F_v \to E_v)$ whose root $\ast_v$ has the same degree as $v$.
%In the directed case, we require it to have the same in-degree and out-degree separately.
(Usually, $V_0$ will be either a single vertex or the set of all non-root vertices.)

We regard $\G$ as a morphism from $\A$ to $\B$ in $\hyrel$, where $\A$ is determined by the vertices not in $V_0$ and $\B$ is determined by the vertices in $V_0$.
Similarly, we regard $\sum_v \H_v$ as a morphism from $\B'$ to $\C$, where $\B'$ is determined by the roots $\setof{ \ast_v | v\in V_0}$ and $\C$ by the non-root vertices.
The assumption tells us that $\B'\cong \B$, so we can compose $\G *_{\B} \sum_v \H_v$ in $\hyrel$; we call this the \textbf{insertion} of the hypergraphs $\H_v$ into $\G$ at the vertices $v\in V_0$.

\fxnote{Add some examples.}



\section{Type theory for insertion}
\label{sec:tt-insertion}

In type theory it is easiest to describe insertion when $V_0$ is a single vertex.
We represent a rooted hypergraph as a graph context together with another vertex judgment in the same edge/loop context.
The fact that two vertices have the same degree is automatic when in the labeled case they have the same label.
This leads to the following insertion/substitution (admissible) rule:

\begin{mathpar}
  \inferrule{\Delta_1\mid\Xi_1 \types \Gamma_1 \graph\\
    \Delta_1\mid\Xi_1 \types \alpha(\vec x;\vec y)\vertex \\
    \Delta_2\mid\Xi_2 \types \Gamma_2, \alpha(\vec u;\vec v) \graph}
  {\Delta_1,\Delta_2 \mid \Xi_1,\Xi_2, \vec x\doteq \vec u, \vec y \doteq \vec v \types \Gamma_1, \Gamma_2 \graph}
\end{mathpar}

The equalities $\vec x\doteq \vec u, \vec y \doteq \vec v$ correspond to the isomorphisms inserted by the pseudo-pushout of groupoids.
We are assuming $\Delta_1\cap \Delta_2=\emptyset$, so all of these are equalities between distinct variables, and thus at least some of them can be substituted away by~\eqref{eq:subst} (a ``unification algorithm'' for the arguments of the two $\alpha$-labeled vertices).
However, we may still be left with additional self-loops, for instance:

\begin{mathpar}
  \inferrule*{\inferrule*{x:p \mid\cdot \types \Gamma_1 \graph\\
    x:p \mid\cdot \types \alpha(x,x;) \vertex \\
    u:p \mid\cdot \types \Gamma_2, \alpha(u,u;) \graph}
  {x:p,u:p \mid x\doteq u, x\doteq u \types \Gamma_1,\Gamma_2\graph}}
{x:p \mid x\doteq x \types \Gamma_1,\Gamma_2[x/u] \graph}
\end{mathpar}

We can also state a simultaneous insertion rule:

\begin{mathpar}
  \inferrule{\Delta_i\mid\Xi_i \types \Gamma_i \graph\\
    \Delta_i\mid\Xi_i \types \alpha_i(\vec x_i;\vec y_i)\vertex \\\\
    \Delta'\mid\Xi' \types (\alpha_1(\vec u_1;\vec v_1),\dots,\alpha_n(\vec u_n;\vec v_n)) \graph}
  {\Delta_1,\dots,\Delta_n,\Delta' \mid \Xi_1,\dots,\Xi_n,\Xi', \vec x_1\doteq \vec u_1, \vec y_1 \doteq \vec v_1,\dots,\vec x_n\doteq \vec u_n, \vec y_n \doteq \vec v_n \types \Gamma_1,\dots, \Gamma_n \graph}
\end{mathpar}


\section{The pseudomonad for hypercategories}
\label{sec:hypercats}

We would like to build a monad out of labeled hypergraphs.
Our first thought may be that it should be a polynomial monad, since each hypergraph should give a ``constructor'' whose ``arguments'' are a labeling of it.
However, in a categorical situation where labelings have dependency, polynomial functors are too restrictive; they work in the ``one-object'' clase of generalized operads (as in~\cite{bb:htapm}), but for generalized multicategories (``colored operads'') we need the more general \emph{parametric right adjoints} of~\cite{weber:parmrep,weber:fam-pra}.

As shown in~\cite{weber:fam-pra}, a parametric right adjoint between presheaf categories $[I\op,\Set]\to [J\op,\Set]$ can be represented by a polynomial in \Cat:
\[ I \xot{d} E \xto{c} K \xto{p} J \]
in which $K\to J$ is a discrete fibration and $(d,c)$ is a two-sided discrete fibration (i.e.\ $d$ is a fibration, $c$ is an opfibration, and $(d,c): E \to I\times K$ has discrete fibers).
These conditions ensure that the polynomial functor $p_! c_* d^* : \Cat/I \to \Cat/J$ restricts to discrete fibrations, hence to presheaves.
If we write $H:I\op\times K\to \Set$ for the profunctor corresponding to $(d,c)$, then the functor on presheaves can equivalently be described as
\[ [I\op,\Set] \xto{\hom_I(H,-)} [K\op,\Set] \xto{\lan_p} [J\op,\Set]. \]
where $\hom_I(H,X)(k) = \lim_{i\in I} \hom(H(i,k),X(i))$.

In fact, hypergraphs do not quite give such a parametric right adjoint either: the presence of automorphisms prevents $p$ from being a \emph{discrete} fibration.
However, we still get a polynomial in \Cat, which we can reflect into a monad on a presheaf category, although the result will no longer be polynomial or even parametric right adjoint.
The situation is analogous to how the definition of symmetric monoidal category is not obtained from that of a commutative monoid by ``using the same operations and imposing axioms only up to isomorphism'' (the way that of an ordinary monoidal category is obtained from that of an ordinary monoid); instead the operations have to be ordered and the symmetry only imposed up to isomorphism as well.

We will treat only the directed case explicitly, and find the undirected case inside it using ``outgoing-only'' graphs.
For simplicity we will start with a purely polycategorical monad, with composition operations on morphisms but no operations on objects, and then later add the monoidal structure on objects.

Let $J$ be the category such that presheaves on $J$ are polygraphs.
That is, $J$ has an object $0$ and objects $(n,m)$ for $n,m\in\N$, with $n+m$ nonidentity morphisms $0\to (n,m)$.

Let $\hohy$ be the homotopy 1-category of $\hy$, obtained by identifying isomorphic 1-cells and discarding the 2-cells.
We pass to this quotient since for a polygraph $P$, the $P$-labeled hypergraphs depend only on the image of $P$ in $\hohy$.
By an \textbf{$(n,m)$-hypergraph} we will mean a directed rooted object of $\hohy$ whose root has in-rank $n$ and out-rank $m$.

We define a functor $J\op\to\Cat$ (i.e.\ an internal polygraph in $\Cat$) by sending $(n,m)$ to the groupoid of such $(n,m)$-hypergraphs and isomorphisms between them, and $0$ to the terminal category with unique object $\star$.
Let $p:K_1 \to J$ be the (split, groupoidal, but not discrete) fibration corresponding to this functor.

We define a profunctor $H_1 : J\op\times K_1 \to \Set$ as follows:
\begin{align*}
  H_1(0,\G) &= \text{edges of $\G$}\\
  H_1((n,m),\G) &= \text{non-root vertices in $\G$ with in-rank $n$ and out-rank $m$}.\\
  H_1(0,\star) &= 1\\
  H_1((n,m),\star) &= \emptyset
\end{align*}
The automorphisms of graphs in $K_1$ act on $\H_1(-,\G)$ in the obvious way.
The $n+m$ morphisms $\star\to\G$ in $K_1$ induce the maps $H_1(0,\star) \to H_1(0,\G)$ picking out the edges associated to the incoming and outgoing flags of the root.
The $n+m$ morphisms $(n,m)\to 0$ in $J$ induce the maps $H_1((n,m),\G) \to H_1 (0,\G)$ selecting the incoming and outgoing edges of each vertex.

We denote the two-sided discrete fibration corresponding to $H_1$ by $J \xot{d} E_1 \xto{c} K_1$.
We now have an induced polynomial functor
\[ \Cat/J \xto{d^*} \Cat/E_1 \xto{c_*} \Cat/K_1 \xto{p_!} \Cat/J. \]
Although $p_!$ does not preserve discrete fibrations, it does preserve \emph{split} fibrations, i.e.\ functors $J\op\to\Cat$, since $p$ is split.
And since $c$ is a discrete, hence split, opfibration, $c_*$ also preserves split fibrations; while $d^*$ certainly does.
Thus we have an induced endofunctor of the category $[J\op,\Cat]$ of \textbf{\Cat-polygraphs}, i.e.\ internal polygraphs in \Cat, or equivalently internal categories in polygraphs.


Thus a \Cat-polygraph has a category $P(0)$ of objects together with, for each $n,m\in\N$, a category $P(n,m)$ of $n$-ary $m$-coary morphisms, equipped with $n+m$ functors $P(n,m) \to P(0)$.
We may regard an ordinary polygraph as a discrete \Cat-polygraph.
\fxnote{How does this categorical direction interact with the groupoid direction in $E$?}

A \textbf{bracketing} of $n$ things is a list of natural numbers whose sum is $n$, regarded as as giving the number of things in each bracket.
The \textbf{arity} of the bracketing is the length of the list.
For instance, the bracketing $(2,0,3,1)$ of $6$, of arity $4$, should be thought of as $(xx)()(xxx)(x)$.

A \textbf{bracketed hypergraph} is a rooted locally-ordered directed hypergraph together with bracketings of the incoming and outgoing edges at the root.
An isomorphism of bracketed hypergraphs must, of course, preserve the bracketings.
If the incoming and outgoing bracketings have arities $n$ and $m$ respectively, we call it an $(n,m)$-bracketed hypergraph.

If $G$ is a rooted hypergraph, we write $G_0$ for the result of removing the root and all flags adjacent to it (but not removing any edges).
If $k\in\N$, we write $\mathbf{k}$ for the polygraph with $n$ objects (i.e.\ edges) and no morphisms (i.e.\ vertices), hence no flags.
If $G$ is an $(n,m)$-bracketed hypergraph, then we have $n+m$ polygraph morphisms $\mathbf{k}\to G_0$, as $k$ varies over the numbers in the bracketings, which are pairwise disjoint and together enumerate the edges adjacent to the root, grouped according to the specified bracketing.

Now, given a \Cat-polygraph $P$, define a new \Cat-polygraph $T P$ as follows.
\begin{enumerate}
\item The category of objects $T P(0)$ is the free strict monoidal category on the category of objects $P(0)$.
  Thus its objects and arrows are finite lists of those in $P(0)$.
  Equivalently, its objects are \Cat-polygraph maps $\mathbf{k}\to P$ for some $k\in\N$, and its arrows are natural transformations (2-cells in \cpg)
  \[
  \begin{tikzcd}
    \mathbf{k} \ar[rr,equals] \ar[dr] & ~ \ar[d,phantom,"\Rightarrow"] & \mathbf{k} \ar[dl] \\ & P
  \end{tikzcd}
  \]
\item The objects of $TP(n,m)$ are morphisms of polygraphs $G_0\to P$, where $G$ is an $(n,m)$-bracketed hypergraph.
  An arrow in $TP(n,m)$ from $G_0\to P$ to $H_0\to P$ consists of an equivalence of $(n,m)$-bracketed hypergraphs $G\cong H$ together with a transformation
  \[
  \begin{tikzcd}
    G_0 \ar[rr,"\cong"] \ar[dr] & ~ \ar[d,phantom,"\Rightarrow"] & H_0 \ar[dl] \\ & P
  \end{tikzcd}
  \]
\item The $n+m$ functors $TP(n,m) \to TP(0)$ are obtained by precomposing with the $n+m$ polygraph morphisms $\mathbf{k}\to G_0$ described above.
  These morphisms commute with any isomorphism of bracketed hypergraphs, so this precomposition acts on arrows as well as on objects.
\end{enumerate}

\begin{lem}
  This defines a 2-functor $T:\cpg\to\cpg$ that preserves connected limits and groupoidal objects.
\end{lem}
\begin{proof}
  Functoriality is easy by postcomposition.
  If $P = \lim P_i$ is a connected limit, then an object or arrow of $\lim T P_i(0)$ must have the same $\mathbf{k}$ everywhere and hence lift uniquely to an element of $T P(0)$.
  Similarly, the $G$ and $H$ must be constant for any object or arrow $\lim T P_i(n,m)$ so that it lifts uniquely to $T P (n,m)$.
  Finally, it is clear from the definition that if all arrows in $P$ are invertible, the same is true for $TP$.
\end{proof}

Let $\C_{n,m}$ denote the rooted $(n,m)$-corolla:
\begin{center}
  \begin{tikzpicture}
    \node[outer] (a1) at (-1,1) {};
    \node[outer] (a2) at (-.5,1) {};
    \node at (0.3,1) {$\overset{n}{\dots}$};
    \node[outer] (an) at (1,1) {};
    \node[vertex] (f) at (0,0) {$f$};
    \node[outer] (b1) at (-1,-1) {};
    \node[outer] (b2) at (-.5,-1) {};
    \node at (0.3,-1) {$\overset{m}{\dots}$};
    \node[outer] (bn) at (1,-1) {};
    \draw[edge] (a1) to[out=-90,in=150] (f);
    \draw[edge] (a2) to[out=-90,in=120] (f);
    \draw[edge] (an) to[out=-90,in=30] (f);
    \draw[edge] (f) to[out=-150,in=90] (b1);
    \draw[edge] (f) to[out=-120,in=90] (b2);
    \draw[edge] (f) to[out=-30,in=90] (bn);
  \end{tikzpicture}
\end{center}
This is an $(n,m)$-bracketed hypergraph with exactly one non-root vertex and with bracketings $n=\overbrace{1+1+\cdots+1}^n$ and $m=\overbrace{1+1+\cdots+1}^m$.
For any polygraph $P$, morphisms $(C_{n,m})_0 \to P$ are in bijection with vertices of $P$ having in-degree $n$ and out-degree $m$.

Now, for any polygraph $P$, we define $\eta_P : P \to T P$ as follows:
\begin{enumerate}
\item $\eta:P(0) \to TP(0)$ sends an object $x\in P(0)$ to its classifying map $x:\mathbf{1}\to P$, and similarly on arrows.
\item $\eta:P(n,m) \to TP(n,m)$ sends an object $f\in P(n,m)$ to its classifying map $f:(C_{n,m})_0\to P$, and similarly on arrows.
\end{enumerate}

\begin{thm}
  This defines a fully faithful cartesian 2-natural transformation $\eta: 1\to T$.
\end{thm}
\begin{proof}
  Naturality is easy, since postcomposing classifying maps is the same as acting on objects and arrows.
  Full faithfulness on $0$-parts is easy, while on $(n,m)$-parts it follows from the fact that $C_{n,m}$ has no nontrivial automorphisms.
  Finally, $\eta$ is cartesian, meaning that its naturality squares are pullbacks, since its image consists precisely of the objects and arrows involving $\mathbf{1}$ or $C_{n,m}$.
\end{proof}

Of course, there are many different (isomorphic) $(n,m)$-corollas.
However, the theorem is true as long as we fix a \emph{particular} such corolla for each $(n,m)$ to use in defining $\eta$.
The existence of other corollas means that $\eta$, though fully faithful, is not replete: objects of $TP$ defined using other corollas are isomorphic to ones in the image of $\eta$ but are not in the image of $\eta$ themselves.

Using insertion of hypergraphs, we define a cartesian 2-natural transformation $\mu:T^2\to T$.
\fxnote{Incomplete}

However, the monad laws hold only up to coherent isomorphism, so that we have a ``cartesian pseudomonad'' of a fairly strict sort (the functor and transformations are strict and strictly cartesian; only the monad laws are pseudo).
\fxnote{Incomplete}

\begin{defn}
  A $T$-pseudoalgebra is called a \textbf{double hypercategory}.
\end{defn}

A double hypercategory $H$ has the following structure:
\begin{itemize}
\item A set of \emph{objects}, the objects of the category $H(0)$.
\item A set of \emph{vertical arrows}, the arrows of $H(0)$, which can be composed in the usual way.
\item An (unbiased, non-strict) monoidal structure on the category of objects and vertical arrows.
\item For each $n,m$, a set of \emph{horizontal arrows} with lists of $n$ objects as source and $m$ objects as target (the objects of the category $H(n,m)$).
\item For each $n,m$, a set of \emph{2-cells} with horizontal arrows as ``vertical source and target'', and lists of $n$ vertical arrows and $m$ vertical arrows as ``horizontal source and target''.
  These can be composed vertically.
\item ``Horizontal composition'' operations on horizontal arrows and 2-cells, parametrized by bracketed hypergraphs.
  That is, if we label the non-root vertices of any rooted locally-ordered directed hypergraph by horizontal arrows of $H$, in such a way that the edges are labeled compatibly by objects, and bracket the incoming and outgoing edges to the root, then we obtain a composed horizontal arrow whose source and target are obtained by applying the monoidal structure on objects to the groups in the brackets.
  We can similarly compose hypergraphs labeled by 2-cells, and this operation is functorial with respect to vertical composition.
\item Moreover, isomorphisms of bracketed hypergraphs induce isomorphisms of composed horizontal arrows, naturally.
  In particular, this applies to \emph{automorphisms}.
\end{itemize}

\begin{defn}
  If a double hypercategory has only identity vertical arrows, we call it a \textbf{2-hypercategory}.
  If it additionally has only identity 2-cells, we call it a \textbf{hypercategory}.%
  \footnote{The word ``hypercategory'' was also used by~\cite{hmt:strict-n-hypercats,mt:omega-hypergraphs}.
    Our meaning is somewhat different, but not unrelated since they also use a kind of hypergraph.
    The ``hyperstructures'' of~\cite{baas:higher-structures} are also related, although in contrast to both of these references we consider here only one dimension of hyper-dependency.}
\end{defn}

\begin{eg}
  Let \bC be a symmetric monoidal category in which every object is equipped with the structure of a Frobenius algebra (but we do \emph{not} assume that all morphisms of \bC are monoid or comonoid homomorphisms).
  Then \bC has the structure of a hypercategory.
  In fact, it could be that this is exactly what a hypercategory is.
\end{eg}

\begin{eg}
  More generally, a sufficiently strictly monoidal 2-category in which every object has the structure of a Frobenius pseudomonoid~\cite{street:frob-psmon} gives rise to a 2-hypercategory.
  In particular, this applies to any cartesian bicategory~\cite{ckww:cartbicats-ii} in which every object is Frobenius~\cite{ww:frob-cart} and in which the monoidal structure is strict enough.

  In general, what can we take the vertical arrows to be?
  Arbitrary left adjoints?
  Morphisms that are colax for both monoid and comonoid structures?
\end{eg}

\begin{eg}
  If \bS has finite products, then an \bS-indexed monoidal category with indexed homotopy coproducts preserved by the tensor product on both sides, in the sense of~\cite{ps:indexed}, gives rise to a double hypercategory whose vertical category is \bS.
\end{eg}




\section{Virtual double hypercategories}
\label{sec:vdhc}

Our main purpose in defining the pseudomonad $T$ was to consider $T$-multicategories.
Leinster~\cite{leinster:higher-opds} defines $T$-multicategories with respect to a cartesian monad on any category with pullbacks.
Here we have only a pseudomonad on \cpg, but this causes little difficulty, especially since we are interested in the ``object-discrete'' case.

\begin{defn}
  A \textbf{virtual double hypercategory} $M$ consists of the following.
  \begin{enumerate}
  \item A polygraph $M_0$.
  \item A discrete fibration of \Cat-polygraphs $M_1 \to M_0 \times TM_0$.
  \item A composition operation $M_1 \times_{TM_0} TM_1 \to M_1$ over $1\times \mu$:
    \[
    \begin{tikzcd}
      M_1 \times_{TM_0} TM_1 \ar[r,dashed] \ar[d] & M_1\ar[d]\\
      M_0 \times TTM_0 \ar[r,"1\times \mu"'] & M_0\times TM_0.
    \end{tikzcd}
    \]
  \item A unit $M_0 \to M_1$ over $(1,\eta)$:
    \[
    \begin{tikzcd}
      M_0 \ar[r,dashed] \ar[d,equals] & M_1 \ar[d] \\
      M_0\ar[r,"{(1,\eta)}"'] & M_0\times TM_0.
    \end{tikzcd}
    \]
  \item An associativity isomorphism lying over the pseudomonad coherence isomorphism:
    \[\hspace{-2cm}
    \begin{tikzcd}
      & M_1 \times_{TM_0} TM_1 \ar[drr] \ar[ddd]\\
      M_1 \times_{TM_0} TM_1 \times_{TTM_0} TTM_1 \ar[ur] \ar[drr] \ar[ddd] \ar[rrr,phantom,"\cong"] &&&
      M_1 \ar[ddd] \\
      && M_1 \times_{TM_0} TM_1  \ar[ur]\ar[ddd]\\
      & M_0\times TTM_0\ar[drr] \\
      M_0 \times TTTM_0 \ar[ur] \ar[drr] \ar[rrr,phantom,"\cong"] &&&
      M_0\times TM_0 \\
      && M_0\times TTM_0\ar[ur]
    \end{tikzcd}\hspace{-2cm}
    \]
  \item Unit isomorphisms lying over the pseudomonad coherence isomorphisms:
    \[
    \begin{tikzcd}
      & M_1 \times_{TM_0} TM_1 \ar[dr] \ar[dddr,phantom,"\cong" very near start] \ar[dd] \\
      M_1 \ar[rr,equals] \ar[ur]\ar[dd] &~ & M_1\ar[dd]\\
      & M_0\times TM_0 \times TTM_0 \ar[dr] \ar[d,phantom,"\cong"] \\
      M_0\times TM_0 \ar[rr,equals]\ar[ur] &~& M_0\times TM_0
    \end{tikzcd}
    \]
    (There are two such isomorphisms, but the pictures look the same except that the omitted labels on the arrows should be different.)
  \end{enumerate}
\end{defn}

Since $M_1 \to M_0\times TM_0$ is assumed to be a discrete fibration, the coherence isomorphisms are unique, and automatically satisfy any axioms we might wish them to; thus we do not bother writing down those axioms (which would simply lift the corresponding pseudomonad axioms).
Explicitly, a virtual double hypercategory has the following structure.

\begin{enumerate}
\item A set of \emph{objects} (the objects of $M_0$).
\item A set of \emph{vertical multi-arrows}, with source a finite list of objects and target a single object (the objects of $M_1$).
  These can be composed as in an ordinary (non-symmetric) multicategory.
\item For each $n,m$, a set of \emph{horizontal arrows} with lists of $n$ objects as source and $m$ objects as target (the morphisms in the polygraph $M_0$).
\item A set of \emph{2-cells}, each of which has a bracketed hypergraph labeled by horizontal arrows as its vertical source, a single horizontal arrow as its vertical target, and lists of vertical multi-arrows as its horizontal source and target.
\item Each horizontal arrow has an identity 2-cell.
\item A composition operation on 2-cells that involves hypergraph insertion, which is appropriately associative and unital.
\end{enumerate}

We also have algebras over generalized multicategories, for which again we restrict to the discrete case.
Here there is no room for nontrivial isomorphisms at all.

\begin{defn}
  If $M$ is a virtual double hypercategory, an \textbf{$M$-algebra} consists of the following.
  \begin{enumerate}
  \item A polygraph $A$ with a map $A \to M_0$.
  \item An action map $M_1 \times_{TM_0} TA \to A$ over $M_0$.
  \item The action is associative and unital:
    \[\hspace{-2cm}
    \begin{tikzcd}
      M_1 \times_{TM_0} TM_1 \times_{TTM_0} TTA \ar[r] \ar[d] &M_1 \times_{TM_0} TA \ar[d]\\
      M_1 \times_{TM_0} TA \ar[r] & A
    \end{tikzcd}
    \qquad
    \begin{tikzcd}
      A \ar[r] \ar[dr,equals] & M_1 \times_{TM_0} TA\ar[d] \\ & A
    \end{tikzcd}\hspace{-2cm}
    \]
  \end{enumerate}
\end{defn}


\section{Undirected hypercategories and kits}
\label{sec:kits}

Can define similar monad using undirected hypergraphs.
The virtual undirected ones are a special case of directed virtual ones in which all sources are empty.
Kits should be a virtual undirected ones living over a ``shape'' one that marks variance.


\section{Type theory of virtual double hypercategories}
\label{sec:type-theory}

We adopt a ``type-theoretic rule'' notation for 2-cells in virtual double hypercategories.
To describe a labeled hypergraph, we assign a variable to each edge, and declare the variables as having the corresponding objects as ``types'' with their genera as annotations on the typing declaration, for instance
\begin{mathpar}
  x :^0 p \and y:^1 p \and z:^0 q
\end{mathpar}
where $p,q,r$ are objects of $M$.
In practice the genera will almost always be $0$, in which case we omit to notate them.
We notate the vertices as sequents with their labeling horizontal arrow as a term, and with their incident edges as the input and output variables:
\begin{mathpar}
  (x,y,x) \types \alpha: (x,z) \and
  (z,z,y) \types \beta:()
\end{mathpar}
Thus, we must have $\alpha:(p,p,p) \to (p,q)$ and $\beta : (q,q,p) \to ()$.
These declarations all occur in the ``premises''.
Finally, we treat vertical multi-arrows as function symbols and ``apply'' them to the variables denoting the corresponding edges, then place the resulting terms in a ``conclusion'' sequent, labeled again by a horizontal arrow:
\begin{mathpar}
  (F(x,y),x) \types \gamma : (z,G())
\end{mathpar}
For vertical identity arrows, we simply write the variable itself, i.e.\ $x$ means $1_p(x)$ and $z$ means $1_q(z)$.
If $F:(p,p)\to q$ and $G:() \to p$, then we must have $\gamma : (q,p) \to (q,p)$.
Putting the above examples together, we obtain the rule
\begin{mathpar}
  \inferrule{x :^0 p \\ y:^1 p \\ z:^0 q \\
    (x,y,x) \types \alpha: (x,z) \\ (z,z,y) \types \beta:()}
  {(F(x,y),x) \types \gamma : (z,G())}
\end{mathpar}
which corresponds to the following graphically drawn 2-cell:
\begin{center}
  \begin{tikzpicture}
    \node[houter] (Fxy) at (.5,0) {};
    \node[houter] (idx) at (2,-1) {};
    \node[vertex] (gm) at (5.5,-.5) {$\gamma$};
    \node[houter] (idz) at (9,0) {};
    \node[houter] (G) at (10,-1) {};
    \draw[edge] (Fxy) -- (gm);
    \draw[edge] (idx) -- (gm);
    \draw[edge] (gm) -- (idz);
    \draw[edge] (gm) -- (G);
    \node[kite,draw,inner sep=1pt] (Gin) at (10,1) {$G$};
    \draw[->] (Gin) -- (G);
    \node[houter] (zout) at (9,3) {};
    \draw[double,double equal sign distance] (zout) -- (idz);
    \node[houter] (xin) at (2,2) {};
    \draw[double,double equal sign distance] (xin) -- (idx);
    \node[houter] (xyinx) at (0,3) {};
    \node[houter] (xyiny) at (1,2.5) {};
    \node[kite,draw,inner sep=1pt] (F) at (.5,1.5) {$F$};
    \draw (xyinx) -- (F);
    \draw (xyiny) -- (F);
    \draw[->] (F) -- (Fxy);
    \node[vertex] (be) at (8,2) {$\beta$};
    \node[vertex] (al) at (6,3) {$\alpha$};
    \coordinate (x) at (3.5,3);
    \coordinate (y) at (3.5,2);
    \draw[edge] (xyinx) to[out=0,in=180] node[auto] {$p$} (x);
    \draw[edge] (xin) to[out=0,in=180] (x);
    \draw[cross] (xyiny) to[out=0,in=180] (y);
    \draw[edge] (xyiny) to[out=0,in=180] node[auto,swap,very near end] {$p$} (y);
    \draw[edge] (x) to[out=0,in=120] (al);
    \draw[edge] (x) to[out=0,in=-120] (al);
    \coordinate (y2) at (4.5,2);
    \draw[cross] (y2) to[out=0,in=-180] (al);
    \draw[edge] (y2) to[out=0,in=-180] (al);
    \draw (y) to[out=0,in=180] (4,2.2) to[out=0,in=180] (y2);
    \draw (y) to[out=0,in=180] (4,1.8) to[out=0,in=180] (y2);
    \draw[edge] (al) to[out=30,in=0] (4,4) to[out=180,in=180,looseness=2] (x);
    \coordinate (z) at (7,2.5);
    \draw[edge] (al) to[out=-30,in=180] (z);
    \draw[edge] (z) to[out=0,in=120] (be);
    \draw[edge] (z) to[out=0,in=180] (be);
    \draw[edge] (y2) to[out=0,in=-150] (be);
    \draw[edge] (z) to[out=0,in=-180] node[auto] {$q$} (zout);
    \node at (5.5,1) {$\Downarrow$};
  \end{tikzpicture}
\end{center}

Identity 2-cells are easy:
\[ \inferrule{ (x,y,z) \types \alpha : (u,v,w) }{ (x,y,z) \types \alpha : (u,v,w) }\]
Composition of 2-cells is, thankfully, well-notated by combining rules in derivation trees, and \emph{substituting} the terms such as $F(x,y)$ in the conclusion of one rule into the variables occurring in the premises of another.
We do have to be careful that the vertical arrow parts match up between all the 2-cells we are precomposing with.
\fxnote{Some examples?}

It is important to note that when we write a 2-cell as a ``rule'' we are not ``deriving the conclusion from the premises''.
Instead each ``rule'' is a datum, namely the 2-cell, and putting together rules into derivation trees is an operation on these data.

When we get to \emph{$M$-algebras}, however, the rules become operations on sequents.
Here we notate the objects lying over an object $p$ by
\[A \type_p \qquad\text{or}\qquad A_p,\]
and the morphisms lying over $\alpha : (p,q,r) \to (u,v)$ by
\[(A_p,B_q,C_r) \types_\alpha f : (D_u,E_v).\]
Now the 2-cell considered above \emph{acts} on morphisms in the algebra, which we can interpret as a rule of the usual sort that produces a conclusion from the premises:
\begin{mathpar}
  \inferrule{A \type_p \\ B \type^1_p \\ C \type_q \\\\
    (A,B,A) \types_\alpha f : (A,C) \\ (C,C,B) \types_\beta g :()}
  {(F(A,B),A) \types_\gamma g\circ_\rho f : (C,G())}
\end{mathpar}
where $g\circ_\rho f$ denotes a sort of ``composition'' of $f$ and $g$ parametrized by the rule $\rho$.
Note that the vertical arrows $F$ and $G$ act similarly on \emph{types}, which we can notate with type formation rules:
\begin{mathpar}
  \inferrule{A\type_p \\ B\type_p}{F(A,B) \type_q}
  \and
  \inferrule{ }{G() \type_p}
\end{mathpar}

In this way, we can interpret a virtual double hypercategory as a reasonably general sort of \emph{specification of a sequent calculus}.
The objects are the \emph{modes} to which the types can belong.
The horizontal arrows are the \emph{mode morphisms}, or \emph{sequent forms}.
The vertical arrows are the \emph{type formation rules}.
And the 2-cells are the \emph{derivation rules} for sequents.
Each derivation rule takes as premises some number of types, each with a specified mode, and some number of sequents containing those types, each with a specified form, and yields as a conclusion a sequent with a specified form containing some of the types from the premises together with potentially other new types formed from them by the formation rules.
We call this a ``sequent calculus'' because the type formation operators can only appear in the conclusion; all types in the premises must be (meta-)variables.

Note that all the contraction, weakening, composition, and identities are performed formally in the vertical domain.
We contract two types by making the corresponding flags incident on the same edge, and so on.
In the type-theoretic notation, this is indicated by using the same (meta-)variable for the types in the corresponding places.
Even the symmetric action (exchange) is performed formally in the domain, since the incoming and outgoing edges on the root are ordered, and the vertical multi-arrows preserve ordering --- but this ordering is not visible in the premises of the type-theoretic notation, instead being indicated by the order in which the (meta-)variables appear in the conclusion.

The fact that vertical arrows and 2-cells have an algebraic structure of composition means that all \emph{derivable} rules are present on an equal footing with the primitive ones, along with all equations that hold between such derivations.
The primitive rules and primitive equality axioms between composites of these form a \emph{presentation} of a virtual double hypercategory by generators and relations.


\section{Examples}
\label{sec:examples}

For now, we consider only examples without type formation rules.

\subsection{Intuitionistic type theories}
\label{sec:intuitionistic}

We obtain intuitionistic type theories simply by requiring all mode morphisms to have unary targets.
If we have one mode $p$ and one such morphism $p^n \to p$ for each $n$, we can express the identity and cut rules of ordered logic:
\begin{mathpar}
  \inferrule{A\type}{A\types A}
  \and
  \inferrule{\Gamma\types A \\ \Delta,A,\Psi\types B}{\Delta,\Gamma,\Psi\types B}
\end{mathpar}
We can assert axioms on the composites of these to obtain the semantic structure of a non-symmetric multicategory.

We can then add the exchange rule of intuitionistic linear logic:
\begin{mathpar}
  \inferrule{\Gamma,A,B,\Delta\types C}{\Gamma,B,A,\Delta\types C}
\end{mathpar}
with axioms yielding a symmetric multicategory.

\subsection{Flavors of operad}
\label{sec:operads}

All of these use only binary directed graphs.
A summary is in~\cite{bb:htapm}.

Directed sorts:
\begin{itemize}
\item Wheeled props~\cite{mms:wheeled-props} use arbitrary directed graphs.
\item Props use directed graphs with no directed loops.
\item Properads~\cite{vallette:properads} use connected directed graphs with no directed loops.
\item Wheeled properads use arbitrary connected directed graphs.
\item Dioperads~\cite{gan:dioperads} / polycategories~\cite{szabo:polycats,koslowski:polycats,garner:polycats} have no directed loops and are connected and simply connected (no undirected loops either), or equivalently contractible.~\cite{markl:operads-props}
\item Symmetric operads/multicategories use arbitrary directed trees.
\item Non-symmetric operads/multicategories use planar directed trees.
\end{itemize}

Undirected sorts:
\begin{itemize}
\item Cyclic operads~\cite{gk:cyclic-operads} use undirected trees; compare to~\cite{co:flang-cyclic}.
\item Modular operads~\cite{gk:modular-operads} use arbitrary connected graphs (plus a ``stability'' condition).
\item Compact symmetric multicategories~\cite{jk:feynman} use arbitrary graphs.
  This is a somewhat misleading name as it doesn't indicate that the objects are actually \emph{self-}dual (the undirectedness).
\end{itemize}

\bibliography{../all.bib}
\bibliographystyle{alpha}

\end{document}
